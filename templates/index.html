<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>エリたま編成ジェネレーター</title>

    <meta name="description"
        content="このツールは「エイリアンのたまご(エリたま)」の編成支援ジェネレーターです。チームに加えたエイリアンの個性発動条件が満たされているかをリアルタイムでシミュレーションできます。">
    <meta name="google-site-verification" content="rN0Cu7smvs0R4SD-s216F1z3JjXi0aG3WSrqoGzEkeU" />
    <meta name="theme-color" content="#0f172a">
    <link rel="manifest" href="/static/manifest.json">
    <link rel="icon" type="image/png" href="/static/main_icon.webp">
    <link rel="apple-touch-icon" href="/static/main_icon.webp">

    <style>
        /* ==========================================================================
            基本設定・変数定義
           ========================================================================== */
        :root {
            --header-height: 4.739vh;
            --dark-bg: #2a3a4a;
            --light-text: #fff;
            --accent-green: #00ffc8;
            --border-color: #4a5a6a;
            --slot-bg: #1a2a3a;
        }

        /* ==========================================================================
           ローディング画面
           ========================================================================== */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--dark-bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1002;
            color: var(--light-text);
            font-weight: bold;
            text-align: center;
        }

        #loading-overlay p:first-child {
            font-size: 7vw;
        }

        #loading-message {
            font-size: 5vw;
            margin-top: 1rem;
            color: var(--accent-green);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--dark-bg);
            color: var(--light-text);
            margin: 0;
            padding: 0;
            font-size: 1.895vh;
            overflow: hidden;
            /* スクロールバーを隠す（デスクトップ） */
            width: 100vw;
            /* ビューポート幅に固定 */
            height: 100vh;
            /* ビューポート高さに固定 */
            overscroll-behavior-x: none;
            /* 横方向のオーバースクロール（戻るジェスチャー）を無効化 */
            touch-action: pan-y pinch-zoom;
            /* 縦スクロールとピンチズームのみ許可 */
        }

        /* モバイルブラウザではスクロールを許可（ブラウザのヘッダーを無視してスクロール可能にする） */
        @media (max-width: 768px) {
            body {
                overflow-y: auto;
                /* 縦スクロールを許可 */
                overflow-x: hidden;
                /* 横スクロールは禁止 */
                /* height: 100vh のまま（UIの高さは変更しない） */
            }
        }

        * {
            box-sizing: border-box;
        }

        button,
        a {
            -webkit-tap-highlight-color: transparent;
        }

        button:focus,
        a:focus {
            outline: none;
        }

        /* ==========================================================================
            全体レイアウト
           ========================================================================== */
        #main-content {
            display: none;
            flex-direction: column;
            height: 100vh;
            /* ビューポート全体の高さ */
        }

        .header {
            position: sticky;
            top: 0;
            z-index: 3000;
            height: var(--header-height);
            background-color: var(--dark-bg);
            border-bottom: 0.237vh solid var(--accent-green);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 0;
            flex-shrink: 0;
        }

        .header-title-container {
            display: flex;
            align-items: center;
            gap: 0.8vh;
        }

        .header-title-icon {
            height: calc(var(--header-height) * 0.6);
            width: auto;
            object-fit: contain;
        }

        /* 管理モード時はネオンカラーをすべてオレンジに */
        body.admin-mode,
        body.admin-mode * {
            --accent-green: #ff8800 !important;
        }

        #header-title {
            cursor: pointer;
            user-select: none;
        }

        #header-title.has-changes {
            color: var(--accent-green);
            text-decoration: underline;
        }

        #header-title.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .layout-wrapper {
            max-width: 100vw;
            /* 画面幅いっぱいまで広げる */
            width: 100%;
            /* 横幅いっぱいに広がるようにする */
            margin: 0 auto;
            position: relative;
            z-index: 1;
            overflow: hidden;
            /* 画面幅を超える部分は隠す */
            flex-grow: 1;
            /* 残りの高さをすべて埋める */
        }

        .main-container {
            display: flex;
            height: 100%;
            width: 100%;
            /* 親要素の幅に収める */
            overflow: hidden;
            /* はみ出しを隠す */
        }

        /* ==========================================================================
            パーティ表示エリア
        ========================================================================== */
        .party-display-area {
            width: 46.208vh;
            /* 固定幅 */
            max-width: 100%;
            /* モバイルでは画面幅に収める */
            height: 100%;
            overflow: visible;
            /* この領域からはみ出したパーティも見えるように */
            position: relative;
            padding: 0 0.947vh 0.947vh 0.947vh;
            /* 上余白なし、左右下に余白 */
            margin: 0 auto;
            /* 中央配置 */
            overscroll-behavior-x: none;
            /* 横方向のオーバースクロールを無効化 */
        }

        /* --- ▼▼▼ 追加 ▼▼▼ --- */
        /* 5つのパーティを横に並べるためのラッパー */
        #party-slider-wrapper {
            display: flex;
            width: 100%;
            /* 表示エリアに対して100% */
            height: 100%;
            transition: transform 0.15s ease-in-out;
            /* アニメーション速度2倍速 */
        }

        /* --- ▲▲▲ 追加 ▲▲▲ --- */

        .party-container {
            flex-direction: column;
            gap: 0.474vh;
            height: 100%;
            min-width: 100%;
            /* 各パーティが表示エリアの100%を占める */
            max-width: 100%;
            /* はみ出しを防ぐ */
            flex-shrink: 0;
            /* 縮小を防ぐ */
            display: flex;
            padding: 0 0.5vh;
            /* 左右に余白を追加 */
        }

        .party-container.active {
            display: flex;
        }

        /* activeクラスで表示 */
        .party-slot {
            position: relative;
            background-color: var(--slot-bg);
            border: 0.118vh solid var(--border-color);
            border-radius: 0.947vh;
            display: grid;
            padding: 0.947vh;
            height: calc((100% - 1.895vh) / 5);
            gap: 0.474vh 0.947vh;
            grid-template-columns: 9.478vh 13.033vh 1fr;
            grid-template-rows: 1fr;
            grid-template-areas: "character stats skills";
            overflow: visible;
            max-width: 100%;
            transition: transform 0.15s ease-in-out;
            /* リオーダー時のFLIP用 */
        }

        /* 左列: キャラクターエリア（名前 + アイコンの縦配置） */
        .slot-character-area {
            grid-area: character;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            border-radius: 0.474vh;
            padding: 0.474vh;
            gap: 0.474vh;
        }

        /* 属性に応じたアイコン枠の色 */
        .slot-character-area[data-attribute="1"] .slot-character-icon {
            border-color: #ffcccc;
            border-width: 0.355vh;
        }

        /* 動物 */
        .slot-character-area[data-attribute="2"] .slot-character-icon {
            border-color: #c4e5a0;
            border-width: 0.355vh;
        }

        /* 昆虫 */
        .slot-character-area[data-attribute="3"] .slot-character-icon {
            border-color: #c4d9ff;
            border-width: 0.355vh;
        }

        /* 機械 */
        .slot-character-area[data-attribute="4"] .slot-character-icon {
            border-color: #e0ccff;
            border-width: 0.355vh;
        }

        /* ナゾ */

        .slot-character-name {
            width: 100%;
            text-align: center;
            font-weight: bold;
            font-size: 0.93vh;
            color: white;
            line-height: 1.2;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin-top: 0.5vh;
        }

        .slot-character-icon {
            width: 100%;
            max-width: 8.293vh;
            height: auto;
            border: 0.237vh solid var(--border-color);
            border-radius: 0.947vh;
            cursor: pointer;
            -webkit-user-drag: element;
            touch-action: none;
            flex-shrink: 0;
            margin-top: auto;
            margin-bottom: auto;
        }

        .slot-character-icon-placeholder {
            width: 100%;
            max-width: 8.293vh;
            aspect-ratio: 1 / 1;
            border: 0.237vh dashed var(--border-color);
            border-radius: 0.947vh;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
            flex-shrink: 0;
            margin-top: auto;
            margin-bottom: auto;
        }

        /* 編成解除ボタン */
        .remove-button {
            width: 100%;
            max-width: 8.293vh;
            padding: 0.3vh 0;
            background-color: #dc3545;
            border: 0.118vh solid #c82333;
            border-radius: 0.474vh;
            color: white;
            font-size: 1vh;
            font-weight: bold;
            cursor: pointer;
            text-align: center;
            -webkit-tap-highlight-color: transparent;
            transition: background-color 0.2s;
        }

        .remove-button:hover {
            background-color: #c82333;
        }

        .remove-button:active {
            background-color: #bd2130;
        }

        /* 中列: ステータスエリア */
        .slot-stats-area {
            grid-area: stats;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 0.9vh;
        }

        .stats-block {
            font-size: 0.855em;
        }

        .stats-hp-power-block {
            background-color: #1a252a;
            border: 0.118vh solid #0a1a1a;
            border-radius: 0.474vh;
            padding: 0.474vh;
            box-shadow: inset 0 0.118vh 0.237vh rgba(0, 0, 0, 0.5);
        }

        .stats-value-row {
            font-size: 0.81em;
            line-height: 1.4;
            white-space: nowrap;
            display: flex;
            justify-content: space-between;
        }

        .stats-value-label {
            text-align: left;
        }

        .stats-value-number {
            text-align: right;
            font-weight: bold;
        }

        .stats-block-label {
            font-size: 0.532em;
        }

        /* 30%削減: 0.76 * 0.7 = 0.532 */
        .stats-block-divider {
            border-bottom: 0.118vh solid var(--border-color);
            margin: 0.237vh 0;
        }

        .icon-container {
            display: flex;
            flex-wrap: wrap;
            margin-top: 0.474vh;
        }

        .info-icon {
            width: 2.369vh;
            height: 2.369vh;
            margin-right: -0.059vh;
        }

        .icon-placeholder-small {
            width: 2.369vh;
            height: 2.369vh;
            margin-right: -0.059vh;
        }

        img.info-icon[src*="/f"]+img.info-icon[src*="/e"] {
            margin-left: 0.592vh;
        }

        .slot-skills-area {
            grid-area: skills;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            position: relative;
            overflow: hidden;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }

        .skill-block {
            font-size: 0.855em;
            border-bottom: 0.118vh solid var(--border-color);
            padding-bottom: 0.237vh;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            min-height: 25%;
            width: 100%;
            max-width: 100%;
            overflow: hidden;
            box-sizing: border-box;
        }

        .skill-block:last-child {
            border-bottom: none;
        }

        /* 特技と個性1の境界線を強調（通常の2倍） */
        .skill-block.special-skill {
            border-bottom: 0.237vh solid var(--border-color);
        }

        .skill-label {
            font-size: 0.9vh;
            color: #9aabac;
        }

        .skill-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .skill-name {
            font-weight: bold;
            font-size: 1.125vh;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* ▽▽▽ 既存の .req-icon-wrapper 関連のCSS (231～248行目あたり) を削除し、以下に置き換え ▽▽▽ */
        .skill-req-icons {
            display: flex;
            gap: 0.237vh;
            flex-shrink: 0;
            margin-left: 0.474vh;
            margin-right: 0.8vh;
            position: relative;
            bottom: 0.5vh;
        }

        .req-icon {
            position: relative;
            /* ◯✕ (::after) の基準位置 */
            width: 2.137vh;
            height: 2.137vh;
            /* ！！！ (★削除★) filter: grayscale は使いません ！！！ */
        }

        .req-icon img {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* ！！！ (★修正★) "以外" の場合に画像をひっくり返す ！！！ */
        .req-icon[style*="scaleY(-1)"] img {
            /* (注: style属性で transform: scaleY(-1) が直接 .req-icon に付与されます) */
            filter: drop-shadow(0 0 1px #fff);
            /* 反転が分かりやすいよう少し光らせる */
        }

        /* (★復活★) 元の◯✕ アイコンの表示 */
        .req-icon::after {
            content: '';
            position: absolute;
            bottom: -0.32vh;
            right: -0.37vh;
            width: 1.185vh;
            height: 1.185vh;
            border-radius: 50%;
            background-color: grey;
            color: white;
            font-size: 0.947vh;
            font-weight: bold;
            display: none;
            /* 普段は隠す */
            align-items: center;
            justify-content: center;
            border: 0.118vh solid white;
            z-index: 1;
        }

        /* met または unmet クラスが付いたら表示 */
        .req-icon.met::after,
        .req-icon.unmet::after {
            display: flex;
        }

        .req-icon.met::after {
            content: '◯';
            background-color: #28a745;
        }

        .req-icon.unmet::after {
            content: '✕';
            background-color: #dc3545;
        }

        .req-count {
            position: absolute;
            top: -0.5vh;
            right: -0.2vh;
            z-index: 2;
            color: white;
            font-weight: bold;
            font-size: 1.3vh;
            line-height: 1;
            text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
        }

        /* △△△ ここまでを置き換え △△△ */
        .skill-description {
            display: none;
            font-size: 1.14vh;
            padding: 0.474vh;
            background-color: #00000030;
            white-space: normal;
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-all;
            /* 強制的に折り返す */
            overflow-y: auto;
            border-radius: 0.474vh;
            line-height: 1.5;
            max-width: 100%;
            width: 100%;
            box-sizing: border-box;
        }

        /* 特技/個性を開いたときの名前表示エリア */
        .skill-name-display {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background-color: var(--slot-bg);
            padding: 0.474vh;
            border-bottom: 0.118vh solid var(--border-color);
            z-index: 10;
        }

        .skills-area-detail-view .skill-block.is-active .skill-name-display {
            display: flex;
            flex-direction: row;
            gap: 0.5vh;
            align-items: center;
        }

        .skill-name-display .skill-name {
            flex: 1;
        }

        .skill-name-display .skill-req-icons {
            display: flex;
            gap: 0.3vh;
        }

        .skills-area-detail-view .skill-item,
        .skills-area-detail-view .skill-block>.skill-label {
            display: none;
        }

        .skills-area-detail-view .skill-name-display .skill-label {
            display: block;
        }

        .skills-area-detail-view .skill-block:not(.is-active) {
            display: none;
        }

        .skills-area-detail-view .skill-block.is-active {
            height: 100%;
            border-bottom: none;
            display: flex;
            flex-direction: column;
            position: relative;
            padding-top: 3.5vh;
            /* 名前表示エリアの高さ分 */
        }

        .skills-area-detail-view .skill-description {
            display: block;
            flex: 1;
            overflow-y: auto;
        }

        .skills-area-detail-view {
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .skill-description::-webkit-scrollbar {
            width: 6px;
        }

        .skill-description::-webkit-scrollbar-track {
            background: transparent;
        }

        .skill-description::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        /* ==========================================================================
            エイリアン一覧ドロワー
           ========================================================================== */
        .alien-drawer {
            position: fixed;
            top: var(--header-height);
            left: 0;
            width: 95vw;
            max-width: 42.65vh;
            height: calc(100vh - var(--header-height));
            background-color: var(--dark-bg);
            border-right: 2px solid var(--accent-green);
            transform: translateX(-100%);
            transition: transform 0.1s ease-in-out;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }

        .alien-drawer.open {
            transform: translateX(0);
        }

        .drawer-header {
            padding: 0.947vh 1.421vh;
            border-bottom: 0.118vh solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        /* ドロップゾーン（編成解除エリア） */
        .drop-zone {
            position: absolute;
            top: 100%;
            left: 15%;
            width: 70%;
            display: none;
            background: #2a2a2a;
            color: var(--light-text);
            font-size: 1.5vh;
            font-weight: bold;
            height: 3vh;
            margin-top: 0.5vh;
            text-align: center;
            border-radius: 1vh;
            transition: background 0.2s, box-shadow 0.2s;
            box-shadow: 0 0 2vh rgba(0, 0, 0, 0.8);
            z-index: 100;
        }

        .drop-zone.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .drop-zone.hover {
            background: linear-gradient(135deg, #d9534f 0%, #c9302c 100%);
            box-shadow: 0 0 2vh rgba(217, 83, 79, 0.6);
        }

        /* パーティプレビューエリア */
        .party-preview-area {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1vh 0.5vh;
            border-bottom: 0.118vh solid var(--border-color);
            background-color: #1a2a3a;
            gap: 0;
            flex-shrink: 0;
            position: relative;
        }

        .preview-arrow {
            background: var(--border-color);
            color: var(--light-text);
            border: none;
            border-radius: 0;
            width: 2.5vh;
            height: 100%;
            font-size: 1.1vh;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            flex-shrink: 0;
            margin: 0;
            padding: 1vh 0;
        }

        .preview-arrow:hover {
            background-color: #5a6a7a;
        }

        .preview-party-label {
            font-size: 1.5vh;
            font-weight: bold;
            color: var(--accent-green);
            min-width: 4vh;
            text-align: center;
            flex-shrink: 0;
            padding: 1vh 1.2vh;
        }

        .preview-slots {
            display: flex;
            gap: 0.7vh;
            flex-grow: 1;
            justify-content: center;
            padding: 0 0.8vh;
        }

        .preview-slot {
            width: 5.6vh;
            height: 5.6vh;
            border: 0.3vh solid var(--border-color);
            border-radius: 0.7vh;
            background-color: var(--slot-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            position: relative;
            overflow: visible;
            touch-action: none;
        }

        .preview-slot.empty {
            border-style: dashed;
            cursor: default;
        }

        .preview-slot img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 0.4vh;
        }

        .preview-slot:not(.empty) {
            cursor: grab;
        }

        .preview-slot:not(.empty):active {
            cursor: grabbing;
        }

        /* 属性別の枠線色 */
        .preview-slot[data-attribute="1"] {
            border-color: #ffcccc;
        }

        .preview-slot[data-attribute="2"] {
            border-color: #c4e5a0;
        }

        .preview-slot[data-attribute="3"] {
            border-color: #c4d9ff;
        }

        .preview-slot[data-attribute="4"] {
            border-color: #e0ccff;
        }

        .preview-slot.drag-over {
            background-color: rgba(0, 255, 200, 0.2);
            border-color: var(--accent-green);
        }

        .drawer-controls,
        .sort-controls {
            display: flex;
            gap: 0.71vh;
        }

        .control-button {
            padding: 0.71vh 1.421vh;
            background-color: #f0ad4e;
            border: 0.118vh solid #eea236;
            color: var(--light-text);
            border-radius: 1.777vh;
            cursor: pointer;
            font-size: 1.658vh;
            font-weight: bold;
            -webkit-tap-highlight-color: transparent;
            transition: background-color 0.2s, border-color 0.2s;
            white-space: nowrap;
        }

        #sort-button {
            min-width: 5.5vh;
            flex-shrink: 0;
        }

        .control-button.filtered {
            background-color: #d9534f;
            border-color: #d43f3a;
        }

        .effect-tab-button.filtered {
            color: #d9534f !important;
        }

        .effect-tab-button.selected.filtered {
            background-color: #1a2a3a !important;
            border-color: #d9534f !important;
            color: #d9534f !important;
        }

        .effect-tab-button:not(.selected).filtered {
            color: #d9534f !important;
        }

        /* タブ行全体のスタイル */
        .effect-tab-row {
            background-color: #2a3a4a;
            border-radius: 0.474vh;
            margin: 0;
            padding: 0.6rem;
            margin-bottom: 0;
        }

        /* 対象帯以下の背景色を暗く（トレー風） */
        #filter-section-effects .effect-skill-header {
            background-color: #1a2a3a;
            padding: 0.6rem;
            border-radius: 0.474vh;
            margin-bottom: 0;
            margin-top: 0;
        }

        #filter-section-effects .effect-options {
            background-color: #1a2a3a;
            padding: 0 1rem 1rem 1rem;
            /* 上余白を0に */
            border-radius: 0.474vh;
            margin-top: 0;
        }

        .effect-tab-button {
            background-color: transparent;
            border: 0.118vh solid transparent;
            color: rgba(255, 255, 255, 0.7);
            transition: all 0.2s;
        }

        .effect-tab-button.selected {
            background-color: #1a2a3a !important;
            border-color: var(--accent-green);
            border-width: 0.2vh;
            font-weight: bold;
            border-radius: 0.474vh;
            position: relative;
            z-index: 2;
            color: var(--accent-green);
        }

        /* 未選択のタブのスタイル */
        .effect-tab-button:not(.selected) {
            background-color: transparent;
            border-color: transparent;
            color: rgba(255, 255, 255, 0.7);
        }

        .effect-tab-button:not(.selected):hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .sort-order-button {
            background-color: #6a7a8a;
            border-color: #5a6a7a;
        }

        .filter-menu {
            display: none;
            padding: 0.947vh;
            background-color: #1a2a3a;
            border-bottom: 0.118vh solid var(--border-color);
        }

        .effect-filter-menu {
            display: none;
            padding: 0.947vh;
            background-color: #1a2a3a;
            border-bottom: 0.118vh solid var(--border-color);
            overflow-y: auto;
        }

        .filter-row {
            display: flex;
            gap: 0.947vh;
        }

        .filter-section {
            margin-bottom: 0.947vh;
            flex: 1;
        }

        .filter-row .filter-section {
            min-width: 0;
        }

        .filter-label {
            font-size: 1.421vh;
            font-weight: bold;
            margin-bottom: 0.474vh;
            display: flex;
            align-items: center;
            gap: 0.947vh;
        }

        .filter-options {
            display: flex;
            flex-wrap: wrap;
            gap: 0.474vh;
        }

        .name-search-input {
            width: 100%;
            padding: 0.7vh 0.9vh;
            font-size: 1.4vh;
            background-color: #2a3a4a;
            border: 0.118vh solid var(--border-color);
            border-radius: 0.474vh;
            color: var(--light-text);
            box-sizing: border-box;
            min-height: 2.5vh;
        }

        .name-search-input:focus {
            outline: none;
            border-color: var(--accent-green);
        }

        .filter-button {
            background-color: transparent;
            border: none;
            padding: 0;
            cursor: pointer;
            border-radius: 0.474vh;
            -webkit-tap-highlight-color: transparent;
        }

        .filter-button img {
            width: 3.791vh;
            height: 3.791vh;
            display: block;
            opacity: 0.4;
            transition: opacity 0.2s, filter 0.2s;
        }

        .filter-button.selected img {
            opacity: 1;
            filter: drop-shadow(0 0 0.3vh var(--accent-green)) drop-shadow(0 0 0.3vh var(--accent-green));
        }

        .all-button {
            width: auto;
            padding: 0.237vh 0.947vh;
            height: auto;
            border: 0.118vh solid var(--border-color);
            border-radius: 0.474vh;
            color: var(--light-text);
            font-size: 1.3vh;
            font-weight: normal;
            background-color: #4a5a6a;
            transition: background-color 0.2s;
        }

        .all-button.selected {
            background-color: #f0ad4e;
        }

        /* 効果ボタンのスタイル */
        .effect-button {
            width: auto;
            padding: 0.35vh 1.2vh;
            height: auto;
            border: 0.118vh solid var(--border-color);
            border-radius: 0.474vh;
            color: var(--light-text);
            font-size: 1.35vh;
            font-weight: normal;
            background-color: #4a5a6a;
            transition: background-color 0.2s, border-color 0.2s;
            cursor: pointer;
            white-space: nowrap;
        }

        .effect-button:hover {
            background-color: #5a6a7a;
        }

        .effect-button.selected {
            background-color: #f0ad4e;
            border-color: var(--accent-green);
        }

        /* 個性ボタンのスタイル */
        .effect-skill-button {
            width: auto;
            padding: 0.237vh 0.947vh;
            height: auto;
            border: 0.118vh solid var(--border-color);
            border-radius: 0.474vh;
            color: var(--light-text);
            font-size: 1.2vh;
            font-weight: normal;
            background-color: #4a5a6a;
            transition: background-color 0.2s, border-color 0.2s;
            cursor: pointer;
        }

        .effect-skill-button:hover {
            background-color: #5a6a7a;
        }

        .effect-skill-button.selected {
            background-color: #f0ad4e;
            border-color: var(--accent-green);
        }

        /* バフ・デバフ見出し UI */
        .effect-main-category-title {
            display: block;
            width: 100%;
            text-align: center;
            cursor: pointer;
            user-select: none;
            position: relative;
            padding: 0.45rem 0.8rem;
            margin: 0 auto;
            box-sizing: border-box;
            background-color: #223242;
            border: 0.118vh solid var(--border-color);
            border-radius: 0.474vh;
            color: var(--accent-green);
            transition: all 0.3s ease;
            -webkit-tap-highlight-color: transparent;
        }

        /* サブカテゴリの左側の余白をメインカテゴリタイトルと同じ幅に */
        .effect-sub-category {
            padding-left: 0.8rem;
            /* effect-main-category-titleのpadding-leftと同じ */
        }

        .effect-main-category-title:active {
            background-color: #2a3a4a;
            transform: scale(0.98);
        }

        .effect-main-category-title::after {
            content: '▼';
            position: absolute;
            right: 0.6rem;
            top: 50%;
            transform: translateY(-50%);
            transition: all 0.3s ease;
        }

        .effect-main-category-title.collapsed::after {
            content: '▶';
        }

        .effect-sub-category-title {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
            font-weight: 600;
            color: var(--light-text);
            transition: all 0.3s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .effect-sub-category-title:active {
            color: #88ffd4;
            transform: scale(0.98);
        }

        .effect-sub-category-title::after {
            content: '▼';
            transition: all 0.3s ease;
        }

        .effect-sub-category-title.collapsed::after {
            content: '▶';
        }

        /* サブカテゴリ（トレー風） */
        .effect-sub-category {
            background-color: #1f2f3f;
            border: 0.118vh solid var(--accent-green);
            border-radius: 0.474vh;
            padding: 0.6rem;
            padding-left: 0.8rem;
            margin-bottom: 0.6rem;
            margin-left: 0;
            /* JavaScriptで設定されたmarginLeftを上書き */
        }

        .effect-buttons-container {
            margin-top: 0.35rem;
        }

        /* 折りたたみアニメーション用 */
        .effect-main-category-content {
            overflow: hidden;
            max-height: 9999px;
            opacity: 1;
            transition: max-height 0.3s ease, opacity 0.3s ease;
        }

        .effect-main-category-content.collapsed {
            max-height: 0;
            opacity: 0;
        }

        .effect-sub-category-container {
            overflow: hidden;
            max-height: 9999px;
            opacity: 1;
            transition: max-height 0.3s ease, opacity 0.3s ease;
        }

        .effect-sub-category-container.collapsed {
            max-height: 0;
            opacity: 0;
        }

        .sort-menu {
            display: none;
            position: absolute;
            top: 5.924vh;
            right: 1.421vh;
            background-color: #1a2a3a;
            border: 0.118vh solid var(--border-color);
            border-radius: 0.592vh;
            z-index: 1002;
            padding: 0.592vh;
        }

        .sort-menu button {
            display: block;
            width: 100%;
            text-align: left;
            -webkit-tap-highlight-color: transparent;
        }

        .alien-grid {
            padding: 0.947vh;
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.592vh;
            overflow-y: auto;
            flex-grow: 1;
            align-content: start;
        }

        .alien-card {
            text-align: center;
            cursor: pointer;
            position: relative;
            min-width: 0;
            -webkit-tap-highlight-color: transparent;
            height: fit-content;
        }

        .alien-card img {
            width: 100%;
            border: 0.237vh solid transparent;
            border-radius: 0.947vh;
            display: block;
            aspect-ratio: 1 / 1.15;
            object-fit: cover;
            object-position: center;
        }

        .alien-card:hover img {
            border-color: var(--accent-green);
        }

        .alien-name {
            display: block;
            font-size: 1.184vh;
            font-weight: bold;
            margin-top: 0.237vh;
            line-height: 1.1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: 100%;
            height: fit-content;
        }

        .alien-name.invalid-data {
            color: #ff6666;
            /* 不整合データを持つエイリアンの名前を赤く表示 */
        }

        .alien-card.selected {
            filter: contrast(60%);
        }

        .alien-card.selected::after {
            content: '編成中';
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 0.474vh 0.947vh;
            border-radius: 0.474vh;
            font-size: 1.303vh;
            font-weight: bold;
            white-space: nowrap;
            pointer-events: none;
        }

        .alien-card.drag-swap-target img {
            border-color: #ffc107;
            box-shadow: 0 0 1.5vh rgba(255, 193, 7, 0.8);
        }

        .drawer-toggle {
            position: fixed;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            width: 3.554vh;
            height: 7.109vh;
            background-color: var(--dark-bg);
            color: var(--light-text);
            border: 0.237vh solid var(--accent-green);
            border-left: none;
            border-radius: 0 0.947vh 0.947vh 0;
            cursor: pointer;
            z-index: 1001;
            transition: left 0.1s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
        }

        .alien-drawer {
            position: fixed;
            top: var(--header-height);
            left: 0;
            width: 95vw;
            max-width: 42.65vh;
            height: calc(100vh - var(--header-height));
            background-color: var(--dark-bg);
            border-right: 2px solid var(--accent-green);
            transform: translateX(-100%);
            transition: transform 0.1s ease-in-out;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }

        @media (min-width: 0px) {
            .alien-drawer.open+.drawer-toggle {
                left: 42.65vh;
            }
        }

        .filter-row .filter-section#filter-section-attribute {
            flex: 4;
        }

        .filter-row .filter-section#filter-section-affiliation {
            flex: 5;
        }

        .filter-row .filter-section#filter-section-attack_area {
            flex: 2;
        }

        .filter-row .filter-section#filter-section-attack_range {
            flex: 3;
        }

        .filter-row .filter-section#filter-section-role {
            flex: 2;
        }

        .filter-row .filter-section#filter-section-search {
            flex: 2.5;
            margin-right: 0.5vh;
        }

        .sort-value-display {
            position: absolute;
            bottom: 1.6vh;
            left: 0;
            right: 0;
            margin: 0 auto;
            font-size: 1.05vh;
            font-weight: bold;
            color: var(--accent-green);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.4;
        }

        .sort-value-display:not(:empty) {
            background-color: rgba(0, 0, 0, 0.8);
            padding: 0.1vh 0;
        }

        .header-button {
            background: var(--border-color);
            color: var(--light-text);
            border: none;
            border-radius: 50%;
            width: 3.2vh;
            height: 3.2vh;
            font-size: 1.6vh;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
        }

        .header-help-container {
            position: absolute;
            right: 1.5vh;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .help-button-label {
            font-size: 0.9vh;
            font-weight: bold;
            margin-top: 0.2vh;
        }

        /* 管理ボタン（ヘッダー左端） */
        .header-admin-container {
            position: absolute;
            left: 1.5vh;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .admin-button-label {
            font-size: 0.9vh;
            font-weight: bold;
            margin-top: 0.2vh;
        }

        /* 辞書管理ボタン（管理ボタンの右隣、管理モード時のみ表示） */
        .header-dictionary-container {
            position: absolute;
            left: 6.5vh;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            display: none;
            /* デフォルトで非表示 */
        }

        .header.admin-mode .header-dictionary-container {
            display: flex;
            /* 管理モード時のみ表示 */
        }

        .dictionary-button-label {
            font-size: 0.9vh;
            font-weight: bold;
            margin-top: 0.2vh;
        }

        /* 全体スクレイピングボタン（辞書ボタンの右隣、管理モード時のみ表示） */
        .header-scrape-container {
            position: absolute;
            left: 11.5vh;
            top: 50%;
            transform: translateY(-50%);
            display: none;
            /* デフォルトで非表示 */
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .header.admin-mode .header-scrape-container {
            display: flex;
            /* 管理モード時のみ表示 */
        }

        .scrape-button-label {
            font-size: 0.9vh;
            font-weight: bold;
            margin-top: 0.2vh;
        }

        .header-scrape-container.active-menu .header-button {
            background: #ff8800;
            border-color: #ffb347;
        }

        .scrape-dropdown {
            position: absolute;
            top: 4.2vh;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--dark-bg);
            border: 0.237vh solid var(--accent-green);
            border-radius: 0.6vh;
            padding: 0.6vh 0;
            display: none;
            flex-direction: column;
            gap: 0.4vh;
            min-width: 16vh;
            z-index: 2001;
            box-shadow: 0 0 1vh rgba(0, 0, 0, 0.6);
        }

        .scrape-dropdown.open {
            display: flex;
        }

        .scrape-dropdown button {
            background: none;
            border: none;
            color: var(--light-text);
            text-align: left;
            padding: 0.8vh 1.2vh;
            font-size: 1.2vh;
            cursor: pointer;
            width: 100%;
        }

        .scrape-dropdown button:hover {
            background-color: rgba(255, 136, 0, 0.2);
        }

        /* 一覧表示ボタン（使い方ボタンのすぐ左） */
        .header-overview-container {
            position: absolute;
            right: 6.5vh;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .overview-button-label {
            font-size: 0.9vh;
            font-weight: bold;
            margin-top: 0.2vh;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .modal-content {
            background: var(--dark-bg);
            padding: 2.5vh;
            border-radius: 1vh;
            border: 0.2vh solid var(--accent-green);
            width: 90%;
            max-width: 45vh;
            color: var(--light-text);
        }

        .modal-content h2 {
            text-align: center;
            margin-top: 0;
            font-size: 1.5em;
        }

        .modal-content ol {
            padding-left: 2.5vh;
        }

        .modal-content li {
            margin-bottom: 1.2vh;
            line-height: 1.5;
        }

        .modal-content #close-modal-button {
            display: block;
            margin: 1.5vh auto 0;
            background-color: #6a7a8a;
            border-color: #5a6a7a;
        }

        .modal-overview {
            font-size: 1.3vh;
            line-height: 1.6;
            margin-bottom: 2vh;
            text-align: center;
        }

        .modal-links {
            margin-top: 2.5vh;
            font-size: 1.4vh;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 0.3vh;
            align-items: center;
        }

        .modal-links a {
            color: var(--accent-green);
            text-decoration: none;
        }

        .modal-links p {
            margin: 0;
            line-height: 1.4;
        }

        .modal-links button {
            width: 100%;
            max-width: 26vh;
            font-size: 1.3vh;
            margin: 0.2vh 0 0;
        }

        .scrape-modal-content {
            background: var(--dark-bg);
            padding: 2vh;
            border-radius: 1vh;
            border: 0.2vh solid var(--accent-green);
            width: 90%;
            max-width: 40vh;
            color: var(--light-text);
            display: flex;
            flex-direction: column;
            gap: 1.2vh;
        }

        .scrape-modal-content h3 {
            margin: 0;
            font-size: 1.6vh;
        }

        .scrape-modal-content p {
            margin: 0;
            font-size: 1.3vh;
            line-height: 1.6;
        }

        .scrape-modal-content input {
            width: 100%;
            padding: 0.9vh;
            font-size: 1.4vh;
            background-color: var(--dark-bg);
            border: 0.2vh solid var(--border-color);
            border-radius: 0.6vh;
            color: var(--light-text);
        }

        .scrape-modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 1vh;
        }

        .scrape-modal-error {
            color: #ff6666;
            font-size: 1.2vh;
            min-height: 1.6vh;
        }

        /* ヘルプモーダル ページネーション */
        .modal-content {
            display: flex;
            flex-direction: column;
            height: 70vh;
            max-height: 70vh;
            overflow: hidden;
        }

        .help-content-wrapper {
            flex: 1;
            overflow-y: auto;
            min-height: 0;
            max-height: 100%;
        }

        .help-page {
            font-size: 1.4vh;
        }

        .help-page h3 {
            font-size: 1.3em;
            margin-top: 1.5vh;
            margin-bottom: 0.8vh;
            border-bottom: 0.118vh solid var(--border-color);
            padding-bottom: 0.5vh;
        }

        .help-page h4 {
            font-size: 1.1em;
            margin-top: 1.2vh;
            margin-bottom: 0.6vh;
            color: var(--accent-green);
        }

        .help-page ul,
        .help-page ol {
            font-size: 1.4vh;
            line-height: 1.5;
        }

        .help-page li {
            margin-bottom: 0.8vh;
        }

        .help-page p {
            font-size: 1.4vh;
            line-height: 1.5;
            margin-bottom: 1vh;
        }

        .help-pagination {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 2.5vh;
            margin-bottom: 1.5vh;
            gap: 1vh;
        }

        .help-pagination button {
            min-width: 8vh;
        }

        .help-page-dots {
            display: flex;
            gap: 0.5vh;
            align-items: center;
        }

        .help-page-dot {
            width: 0.8vh;
            height: 0.8vh;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .help-page-dot.active {
            background-color: var(--accent-green);
        }

        .help-page-dot:hover {
            background-color: rgba(255, 255, 255, 0.5);
        }

        #help-page-indicator {
            font-size: 1.4vh;
            color: var(--light-text);
        }

        #help-prev-button:disabled,
        #help-next-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .modal-links a:hover {
            text-decoration: underline;
        }

        /* ==========================================================================
            パーティセレクター と ドラッグ＆ドロップ
           ========================================================================== */
        .party-selector {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2vh;
            margin: 0.947vh 0;
            height: 3vh;
            flex-shrink: 0;
        }

        .party-nav-button {
            background: none;
            border: none;
            color: var(--light-text);
            font-size: 2vh;
            cursor: pointer;
            padding: 0 1.5vh;
            touch-action: manipulation;
        }

        .party-nav-button:disabled {
            opacity: 0.3;
            cursor: default;
        }

        .party-dots {
            display: flex;
            gap: 1.5vh;
        }

        .dot {
            width: 1.2vh;
            height: 1.2vh;
            border-radius: 50%;
            background-color: var(--border-color);
            transition: background-color 0.2s;
            cursor: pointer;
        }

        .dot.active {
            background-color: var(--accent-green);
        }

        .party-slot.drag-over {
            border-color: #f0ad4e;
            transform: scale(1.02);
        }

        .slot-icon {
            -webkit-user-drag: element;
        }

        .icon-placeholder.drag-over {
            border-color: #f0ad4e;
            transform: scale(1.02);
        }

        /* ==========================================================================
            長押しプレビュー機能
           ========================================================================== */
        #preview-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 95vw;
            max-width: 42.65vh;
            height: 100vh;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        #preview-overlay.active {
            display: flex;
        }

        #preview-slot-container {
            width: 90%;
            max-width: 38.385vh;
            /* 42.65vh * 0.9 */
            background-color: var(--slot-bg);
            border: 0.237vh solid var(--accent-green);
            border-radius: 0.947vh;
            padding: 0.947vh;
            position: relative;
            z-index: 3001;
        }

        #preview-slot-container .party-container {
            display: flex;
            flex-direction: column;
            gap: 0.947vh;
        }

        /* 一覧表示オーバーレイ */
        #party-overview-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        #party-overview-overlay.active {
            display: flex;
        }

        /* パスワード入力モーダル（一覧表示と同じスタイル） */
        #password-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        #password-modal-overlay.active {
            display: flex;
        }

        #password-modal-container {
            width: auto;
            max-width: 90vw;
            background-color: var(--slot-bg);
            border: 0.237vh solid var(--accent-green);
            border-radius: 0.947vh;
            padding: 2vh;
            color: var(--light-text);
        }

        #password-modal-container h2 {
            text-align: center;
            margin-top: 0;
            margin-bottom: 1.5vh;
        }

        #password-modal-container input {
            width: 100%;
            padding: 1vh;
            background-color: var(--dark-bg);
            border: 0.237vh solid var(--border-color);
            border-radius: 0.5vh;
            color: var(--light-text);
            font-size: 1.5vh;
            margin-bottom: 1.5vh;
        }

        #password-modal-container button {
            width: 100%;
            padding: 1vh;
            background-color: var(--border-color);
            border: 0.237vh solid var(--accent-green);
            border-radius: 0.5vh;
            color: var(--light-text);
            font-size: 1.5vh;
            cursor: pointer;
        }

        #password-modal-container button:hover {
            background-color: #5a6a7a;
        }

        #password-modal-container .error-message {
            color: #ff6666;
            font-size: 1.2vh;
            margin-top: 0.5vh;
            min-height: 1.6vh;
            visibility: hidden;
        }

        #password-modal-container .error-message.show {
            visibility: visible;
        }

        #party-overview-container {
            width: auto;
            max-width: 90vw;
            background-color: var(--slot-bg);
            border: 0.237vh solid var(--accent-green);
            border-radius: 0.947vh;
            padding: 1.5vh;
            max-height: 85vh;
            overflow-y: auto;
        }

        .overview-party-row {
            display: flex;
            align-items: center;
            gap: 0.947vh;
            margin-bottom: 1.2vh;
            padding: 0.6vh;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 0.474vh;
            width: fit-content;
        }

        .overview-party-label {
            font-weight: bold;
            font-size: 1.8vh;
            min-width: 4vh;
            text-align: center;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
        }

        .overview-party-label:active {
            cursor: grabbing;
        }

        .overview-party-slots {
            display: flex;
            gap: 0.474vh;
        }

        .overview-mini-slot {
            width: 5.6vh;
            height: 5.6vh;
            border: 0.237vh solid var(--border-color);
            border-radius: 0.474vh;
            background-color: var(--dark-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .overview-mini-slot img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .overview-mini-slot.empty {
            background-color: rgba(0, 0, 0, 0.5);
        }

        .overview-mini-slot[data-attribute="1"] {
            border-color: #ffcccc;
        }

        .overview-mini-slot[data-attribute="2"] {
            border-color: #c4e5a0;
        }

        .overview-mini-slot[data-attribute="3"] {
            border-color: #c4d9ff;
        }

        .overview-mini-slot[data-attribute="4"] {
            border-color: #e0ccff;
        }

        .overview-party-row.drag-over {
            background-color: rgba(255, 255, 0, 0.2);
            border: 0.237vh dashed var(--accent-green);
        }
    </style>
</head>

<body>
    <!-- ローディング画面 -->
    <div id="loading-overlay">
        <div>
            <p>エリたま編成ジェネレーター</p>
            <p id="loading-message">データベース接続中...</p>
        </div>
    </div>

    <!-- メインコンテンツ -->
    <div id="main-content">
        <!-- ヘッダー -->
        <header class="header" id="main-header">
            <div class="header-admin-container">
                <button id="admin-button" class="header-button">管</button>
                <div class="admin-button-label">管理</div>
            </div>
            <div class="header-dictionary-container">
                <button id="dictionary-button" class="header-button">辞</button>
                <div class="dictionary-button-label">辞書</div>
            </div>
            <div class="header-scrape-container">
                <button id="scrape-button" class="header-button" aria-haspopup="true" aria-expanded="false">実</button>
                <div class="scrape-button-label">実行</div>
                <div class="scrape-dropdown" id="scrape-dropdown" role="menu">
                    <button type="button" data-action="full" role="menuitem">全体スクレイピング</button>
                    <button type="button" data-action="partial" role="menuitem">部分スクレイピング</button>
                </div>
            </div>
            <div class="header-overview-container">
                <button id="overview-button" class="header-button">一</button>
                <div class="overview-button-label">一覧表示</div>
            </div>
            <div class="header-title-container">
                <span id="header-title">エリジェネ</span>
                <img src="/static/main_icon.webp" alt="エリジェネアイコン" class="header-title-icon">
            </div>
            <div class="header-help-container">
                <button id="help-button" class="header-button">？</button>
                <div class="help-button-label">使い方</div>
            </div>
        </header>

        <!-- パーティ切り替えセレクター -->
        <div class="party-selector">
            <button id="prev-party-btn" class="party-nav-button">◀</button>
            <div id="party-dots" class="party-dots">
                <span class="dot active" data-party-id="1"></span>
                <span class="dot" data-party-id="2"></span>
                <span class="dot" data-party-id="3"></span>
                <span class="dot" data-party-id="4"></span>
                <span class="dot" data-party-id="5"></span>
            </div>
            <button id="next-party-btn" class="party-nav-button">▶</button>
        </div>
        <div class="layout-wrapper">
            <div class="main-container" id="main-container">
                <div class="party-display-area" id="party-display">
                    <div id="party-slider-wrapper">
                        <div id="party-container-1" class="party-container"></div>
                        <div id="party-container-2" class="party-container"></div>
                        <div id="party-container-3" class="party-container"></div>
                        <div id="party-container-4" class="party-container"></div>
                        <div id="party-container-5" class="party-container"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- エイリアン一覧ドロワー -->
        <div class="alien-drawer" id="alien-drawer">
            <div class="drawer-header">
                <div class="drawer-controls">
                    <button class="control-button" id="effect-filter-button">バフ・デバフ▼</button>
                    <button class="control-button" id="filter-button">絞り込み▼</button>
                </div>
                <div class="sort-controls">
                    <button class="control-button" id="sort-button">ID</button>
                    <button class="control-button sort-order-button" id="sort-order-button">降順</button>
                </div>
            </div>

            <div class="sort-menu" id="sort-menu">
                <button class="control-button" data-sort-key="id">ID</button>
                <button class="control-button" data-sort-key="attribute">属性</button>
                <button class="control-button" data-sort-key="affiliation">所属</button>
                <button class="control-button" data-sort-key="hp">たいりょく</button>
                <button class="control-button" data-sort-key="power">つよさ</button>
                <button class="control-button" data-sort-key="motivation">やるき</button>
                <button class="control-button" data-sort-key="size">おおきさ</button>
                <button class="control-button" data-sort-key="speed">いどう</button>
                <button class="control-button" data-sort-key="attack_area">攻撃はんい</button>
                <button class="control-button" data-sort-key="attack_range">攻撃きょり</button>
            </div>
            <div class="effect-filter-menu" id="effect-filter-menu">
                <div class="filter-section" id="filter-section-effects"></div>
            </div>
            <div class="filter-menu" id="filter-menu">
                <div class="filter-row">
                    <div class="filter-section" id="filter-section-attribute"></div>
                    <div class="filter-section" id="filter-section-affiliation"></div>
                </div>
                <div class="filter-row">
                    <div class="filter-section" id="filter-section-attack_area"></div>
                    <div class="filter-section" id="filter-section-attack_range"></div>
                </div>
                <div class="filter-section" id="filter-section-types"></div>
                <div class="filter-row">
                    <div class="filter-section" id="filter-section-role"></div>
                    <div class="filter-section" id="filter-section-search">
                        <div class="filter-label">
                            <span>名前検索欄</span>
                            <button class="filter-button all-button" id="search-reset-button">リセット</button>
                        </div>
                        <div class="filter-options">
                            <input type="text" id="name-search-input" class="name-search-input" placeholder="エイリアン名を入力">
                        </div>
                    </div>
                </div>
            </div>

            <!-- パーティプレビューエリア -->
            <div class="party-preview-area" id="party-preview-area">
                <button class="preview-arrow preview-arrow-left" id="preview-arrow-left">◀</button>
                <div class="preview-party-label" id="preview-party-label">P1</div>
                <div class="preview-slots" id="preview-slots">
                    <!-- JavaScriptで動的に生成 -->
                </div>
                <button class="preview-arrow preview-arrow-right" id="preview-arrow-right">▶</button>

                <!-- ドロップゾーン（編成解除エリア） -->
                <div class="drop-zone" id="drop-zone">
                    編成解除
                </div>
            </div>

            <div class="alien-grid" id="alien-grid">
                {% for alien in aliens %}
                <div class="alien-card" data-id="{{ alien.id }}" data-name="{{ alien.name }}"
                    data-skill_no1_name="{{ alien.skill_no1 }}" data-skill_no2_name="{{ alien.skill_no2 }}"
                    data-skill_no3_name="{{ alien.skill_no3 }}" data-info-a="{{ alien.attribute }}"
                    data-info-b="{{ alien.affiliation }}" data-info-c="{{ alien.attack_area }}"
                    data-info-d="{{ alien.attack_range }}" data-info-f="{{ alien.role }}"
                    data-info-e1="{{ alien.type_1 }}" data-info-e2="{{ alien.type_2 }}"
                    data-info-e3="{{ alien.type_3 }}" data-info-e4="{{ alien.type_4 }}" title="{{ alien.name }}">
                    <img src="/static/images/{{ alien.id }}.webp" alt="{{ alien.name }}">
                    <div class="sort-value-display"></div>
                    <div class="alien-name">{{ alien.name }}</div>
                </div>
                {% endfor %}
            </div>
        </div>

        <!-- ドロワー開閉ボタン -->
        <button class="drawer-toggle" id="drawer-toggle">▶</button>

        <!-- パーティ一覧表示オーバーレイ -->
        <div id="party-overview-overlay">
            <div id="party-overview-container">
                <!-- JavaScriptで動的に生成 -->
            </div>
        </div>

        <!-- 変更適応メッセージ表示オーバーレイ -->
        <div id="apply-changes-overlay"
            style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: none; align-items: center; justify-content: center; z-index: 3000;">
            <div id="apply-changes-container"
                style="width: auto; max-width: 90vw; background-color: var(--slot-bg); border: 0.237vh solid var(--accent-green); border-radius: 0.947vh; padding: 1.5vh; max-height: 85vh; overflow-y: auto;">
                <div id="apply-changes-content"></div>
            </div>
        </div>

        <!-- パスワード入力モーダル -->
        <div id="password-modal-overlay">
            <div id="password-modal-container">
                <h2>管理モード</h2>
                <input type="password" id="password-input" placeholder="パスワードを入力">
                <div class="error-message" id="password-error">パスワードが正しくありません</div>
                <button id="password-submit-button">ログイン</button>
                <button id="password-cancel-button"
                    style="margin-top: 1vh; background-color: #6a7a8a; border-color: #5a6a7a;">キャンセル</button>
            </div>
        </div>

        <!-- 長押しプレビューオーバーレイ -->
        <div id="preview-overlay">
            <div id="preview-slot-container">
                <!-- プレビュースロットのHTMLをJavaScriptで動的生成 -->
            </div>
        </div>

        <!-- ヘルプモーダル -->
        <div id="help-modal" class="modal-overlay">
            <div class="modal-content">
                <div class="help-content-wrapper">
                    <!-- ページ1: 基本情報・概要 -->
                    <div class="help-page" data-page="1">
                        <h2>エリジェネとは</h2>
                        <p class="modal-overview">
                            このツールは「エイリアンのたまご(エリたま)」の編成支援ジェネレーターです。チームに加えたエイリアンの個性発動条件が満たされているかをリアルタイムでシミュレーションできます。
                        </p>
                        <h3>主な機能</h3>
                        <ul>
                            <li>最大5パーティまで編成を作成可</li>
                            <li>個性の発動条件をリアルタイムで判定・表示</li>
                            <li>エイリアンの絞り込み・並び替え機能</li>
                            <li>効果（バフ・デバフ）による検索機能</li>
                            <li>ドラッグ&ドロップでの編成操作</li>
                        </ul>
                        <div class="modal-links">
                            <p><a href="https://twitter.com/by_kanikama" target="_blank"
                                    rel="noopener noreferrer">制作者X</a></p>
                            <p><a href="https://discord.gg/bq5E38HUec" target="_blank"
                                    rel="noopener noreferrer">エリたまDiscord</a>（誰でも歓迎！）</p>
                            <p><a href="https://github.com/fuyuyu0111/elitama-generator" target="_blank"
                                    rel="noopener noreferrer">GitHubリポジトリ</a>(ソースコード)</p>
                            <button id="install-app-button" class="control-button" type="button"
                                style="display: none;">ホームに追加</button>
                            <button id="open-bug-report-button" class="control-button" type="button">不具合報告フォームへ</button>
                        </div>
                    </div>

                    <!-- ページ2: 編成の方法 -->
                    <div class="help-page" data-page="2" style="display: none;">
                        <h2>編成の方法</h2>
                        <h3>エイリアンを編成に追加する</h3>
                        <ul>
                            <li><strong>エイリアン一覧を開く</strong>：空のスロット（破線枠）または右側の▶ボタンをタップして、エイリアン一覧ドロワーを開きます</li>
                            <li><strong>エイリアンを選択</strong>：一覧から編成したいエイリアンをタップします</li>
                            <li>編成に追加されると、スロットにエイリアンのアイコンが表示されます</li>
                        </ul>

                        <h3>エイリアンを編成から外す</h3>
                        <ul>
                            <li><strong>方法1</strong>：編成画面で、エイリアンアイコン下の「編成解除」ボタンをタップします</li>
                            <li><strong>方法2</strong>：エイリアン一覧画面下部の「編成解除」エリアに、エイリアンをドラッグ&ドロップします</li>
                        </ul>

                        <h3>ドラッグ&ドロップで入れ替え</h3>
                        <ul>
                            <li>編成済みのエイリアンをドラッグして、別のスロットにドロップすると移動できます</li>
                            <li>一覧画面では編成しているエイリアンから入れ替えたいエイリアンへ<strong>直接ドラッグ&ドロップで入れ替えられます</strong></li>
                        </ul>
                    </div>

                    <!-- ページ3: 編成入れ替えの方法 -->
                    <div class="help-page" data-page="3" style="display: none;">
                        <h2>パーティの入れ替え</h2>
                        <ul>
                            <li>◀▶ボタンまたは画面上部のドット（●）をタップしてパーティを切り替えます</li>
                            <li>スマホならフリック、PCならスクロールでパーティを切り替えられます</li>
                            <li>スマホの場合、一覧画面のパーティ番号(P1、P2など)をフリックしても切り替えられます</li>
                        </ul>

                        <h3>パーティ自体の入れ替え</h3>
                        <ul>
                            <li>「使い方」の左の「一覧表示」ボタンをタップして、全パーティの一覧を表示します</li>
                            <li>一覧表示では、パーティ番号（P1、P2など）をドラッグして別のパーティと入れ替えできます</li>
                            <li>スクショを取ってパーティを共有するときなどに便利です</li>
                        </ul>
                    </div>

                    <!-- ページ4: 要求の説明 -->
                    <div class="help-page" data-page="4" style="display: none;">
                        <h2>個性発動条件（要求）について</h2>
                        <p class="modal-overview">
                            個性スロットにアイコンが表示されている場合、効果を発動するための編成要求があることを示します
                        </p>

                        <h3>リアルタイム判定</h3>
                        <ul>
                            <li>編成を変更すると、全ての個性の要求判定が自動的に更新されます</li>
                            <li>条件を満たすと◯、満たさないと✕が表示されます</li>
                        </ul>

                        <h3>要求数の表示</h3>
                        <ul>
                            <li>要求数が2以上の場合、要求アイコン右上に数字で表示されます</li>
                            <li>例：右上に「2」と表示されている場合、味方にその条件を満たすエイリアンが2体以上必要です</li>
                        </ul>

                        <h3>「以外」の表示</h3>
                        <ul>
                            <li>アイコンが逆さまになっている場合、そのアイコン以外の要求を示します</li>
                            <li>例：逆さまの昆虫アイコンの場合、「昆虫属性以外」という意味です</li>
                        </ul>
                    </div>

                    <!-- ページ5: 一覧画面の機能 -->
                    <div class="help-page" data-page="5" style="display: none;">
                        <h2>一覧画面の機能</h2>

                        <h3>バフ・デバフ</h3>
                        <p>エイリアン一覧画面の「バフ・デバフ▼」ボタンから、個性や特技に含まれる効果で絞り込めます。詳しくは次ページを参照してください。</p>

                        <h3>絞り込み</h3>
                        <p>エイリアン一覧画面の「絞り込み▼」ボタンから、ゲーム内と同じ基本情報でエイリアンを絞り込めます。ゲーム内と同じ様に、各項目のアイコンをタップして切り替え可能です。デフォルトではすべて表示になっており、一つでも変更があると絞り込みボタンが赤くなります。複数の項目を組み合わせて絞り込むと、<strong>AND検索</strong>になります。
                        </p>

                        <h3>名前検索</h3>
                        <p>エイリアン一覧画面の「絞り込み▼」ボタンから開く画面の「名前検索欄」で、エイリアン名による検索ができます。ひらがな・カタカナ・英字の全角・半角・大文字・小文字は区別されません。一文字でも入力されていれば絞り込みボタンが赤くなります。「リセット」ボタンで検索をクリアできます。
                        </p>

                        <h3>並び替え</h3>
                        <p>「ID」「属性」「所属」「たいりょく」「こうげき」「やるき」「おおきさ」「いどう」「攻撃はんい」「攻撃きょり」で並び替えられます。「降順」ボタンで昇順/降順を切り替えられます。</p>

                        <h3>アイコン長押しプレビュー</h3>
                        <p>エイリアン一覧画面で、エイリアンのアイコンを長押しすると、そのエイリアンを現在のパーティに追加した場合のプレビューが表示されます。プレビューでは個性の発動条件がリアルタイムで判定され、スキルの詳細も確認できます。
                        </p>
                    </div>

                    <!-- ページ6: バフ・デバフ絞り込み -->
                    <div class="help-page" data-page="6" style="display: none;">
                        <h2>バフ・デバフ絞り込み</h2>

                        <h3>タブの切り替え</h3>
                        <ul>
                            <li><strong>個性タブ</strong>：個性1〜3の効果で絞り込みます</li>
                            <li><strong>特技タブ</strong>：特技の効果で絞り込みます</li>
                        </ul>

                        <h3>AND/OR検索</h3>
                        <ul>
                            <li><strong>OR検索</strong>：選択した効果のいずれかを持つエイリアンを表示します</li>
                            <li><strong>AND検索</strong>：選択した効果をすべて持つエイリアンを表示します</li>
                            <li>個性・特技タブそれぞれとタブ間の関係を切り替えられます</li>
                            <li>例：「毒アタック」または「毒キラー」を持っており、特技は「毒付与」のエイリアンを絞り込みたいときは、個性タブはOR検索で「毒アタック」「毒キラー」を選択し、特技タブでは「毒付与」を選択し、間のボタンはANDにする
                            </li>
                        </ul>
                    </div>

                    <!-- ページ7: カテゴリ名の解説 -->
                    <div class="help-page" data-page="7" style="display: none;">
                        <h2>カテゴリ名の解説</h2>

                        <h3>個性タブのカテゴリ</h3>

                        <h4>バフ</h4>
                        <ul>
                            <li><strong>アップ系</strong>：能力値を上げる効果（つよさアップ、攻撃力アップなど）</li>
                            <li><strong>軽減系</strong>：ダメージや確率を軽減する効果</li>
                            <li><strong>抵抗系</strong>：デバフを防ぐ効果（気絶抵抗、呪縛抵抗など）</li>
                            <li><strong>その他バフ</strong>：上記以外のバフ効果</li>
                        </ul>

                        <h4>デバフ</h4>
                        <ul>
                            <li><strong>ダウン系</strong>：能力値を下げる効果（つよさダウン、いどうダウンなど）</li>
                            <li><strong>その他デバフ</strong>：上記以外のデバフ効果</li>
                        </ul>

                        <h4>状態異常</h4>
                        <ul>
                            <li><strong>毒系</strong>：毒に関する効果（毒付与、毒キラーなど）</li>
                            <li><strong>気絶系</strong>：気絶に関する効果（気絶付与、気絶アタックなど）</li>
                            <li><strong>その他状態異常</strong>：呪縛、足止め、小人化などのその他の状態異常</li>
                        </ul>

                        <h3>特技タブのカテゴリ</h3>
                        <ul>
                            <li><strong>ダメージのみ</strong>：基本ダメージ効果のみで、追加効果がない特技</li>
                            <li><strong>回復系</strong>：HP回復、毒解除、気絶解除などの回復・解除効果</li>
                            <li><strong>バフ系</strong>：能力値アップ、被ダメージ軽減などのバフ効果</li>
                            <li><strong>デバフ(状態異常)系</strong>：能力値ダウン、毒付与、気絶付与などのデバフ・状態異常効果</li>
                        </ul>
                    </div>

                    <!-- ページ8: 不具合報告 -->
                    <div class="help-page" data-page="8" style="display: none;">
                        <h2>不具合報告</h2>
                        <p class="modal-overview">
                            不具合やミスの報告を匿名で制作者に送信できます。内容はDiscordに転送されるため返信はありません。気軽に報告してください。
                        </p>

                        <div id="bug-report-form" style="margin-top: 2vh;">
                            <div style="margin-bottom: 1.5vh;">
                                <label for="bug-report-text"
                                    style="display: block; margin-bottom: 0.5vh; font-weight: bold;">不具合の内容</label>
                                <textarea id="bug-report-text"
                                    style="width: 100%; min-height: 10vh; padding: 0.8vh; font-size: 1.4vh; border: 1px solid #555; background-color: #2a3a4a; color: #fff; border-radius: 0.4vh; resize: vertical;"
                                    placeholder="具体的に不具合やミスを入力してください(例：〇〇の要求が間違っている、△△のバフで絞り込んでも〇〇が出てこない(もしくは〇〇が間違って出てくる)、機能が動作しないなど)"></textarea>
                            </div>
                            <button id="bug-report-submit" class="control-button"
                                style="width: 100%; margin-top: 1vh;">報告を送信</button>
                            <div id="bug-report-status"
                                style="margin-top: 1vh; font-size: 1.2vh; color: #aaa; display: none;"></div>
                        </div>
                    </div>
                </div>

                <!-- ページネーションコントロール -->
                <div class="help-pagination">
                    <button id="help-prev-button" class="control-button" disabled>前へ</button>
                    <div class="help-page-dots" id="help-page-dots">
                        <!-- JavaScriptで動的に生成 -->
                    </div>
                    <button id="help-next-button" class="control-button">次へ</button>
                </div>
                <button id="close-modal-button" class="control-button">閉じる</button>
            </div>
        </div>
    </div>

    <script>
        // ==========================================================================
        //  ローディング画面の制御
        // ==========================================================================

        document.addEventListener('DOMContentLoaded', () => {

            const loadingOverlay = document.getElementById('loading-overlay');
            const loadingMessage = document.getElementById('loading-message');
            const mainContent = document.getElementById('main-content');

            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/static/js/service-worker.js').catch((error) => {
                    console.error('Service worker registration failed:', error);
                });
            }

            // --- プリロード対象の画像URLを収集 ---
            const allCards = document.querySelectorAll('.alien-card');
            const alienImages = Array.from(allCards).map(card => card.querySelector('img').src);

            const iconTypes = ['a', 'b', 'c', 'd', 'f'];
            const iconFiles = new Set();
            iconTypes.forEach(type => {
                document.querySelectorAll(`[data-info-${type}]`).forEach(el => {
                    const val = el.dataset[`info${type}`];
                    if (val && val !== 'None') iconFiles.add(`/static/icon/${type}${val}.webp`);
                });
            });
            for (let i = 1; i <= 4; i++) {
                document.querySelectorAll(`[data-info-e${i}]`).forEach(el => {
                    const val = el.dataset[`infoE${i}`];
                    if (val && val !== 'None') iconFiles.add(`/static/icon/e${val}.webp`);
                });
            }
            const iconImages = Array.from(iconFiles);

            // --- 画像をバッチで読み込む関数 ---
            function loadImageBatch(images, messageTemplate, onComplete) {
                let loadedInBatch = 0;
                const totalInBatch = images.length;
                if (totalInBatch === 0) {
                    onComplete();
                    return;
                }
                images.forEach(src => {
                    const img = new Image();
                    img.onload = img.onerror = () => {
                        loadedInBatch++;
                        const message = messageTemplate.replace('{loaded}', loadedInBatch).replace('{total}', totalInBatch);
                        if (loadingMessage) loadingMessage.innerHTML = message;
                        if (loadedInBatch === totalInBatch) onComplete();
                    };
                    img.src = src;
                });
            }

            // --- ローディング完了処理 ---
            function finishLoading() {
                if (loadingMessage) loadingMessage.textContent = '起動完了！';

                setTimeout(() => {
                    if (loadingOverlay) loadingOverlay.style.display = 'none';
                    if (mainContent) mainContent.style.display = 'flex'; // main-contentをflexにする
                }, 250);
            }

            // --- ローディング処理の実行 ---
            loadImageBatch(alienImages, 'エイリアン画像読込中...<br>({loaded}/{total})', () => {
                loadImageBatch(iconImages, 'アイコン読込中...<br>({loaded}/{total})', finishLoading);
            });
        });

        // ==========================================================================
        //  アプリケーション本体のJavaScript
        // ==========================================================================
        // --- グローバル変数とDOM要素の取得 ---
        let deferredInstallPrompt = null;
        let installButtonElement = null;

        const isStandaloneDisplayMode = () => {
            return window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true;
        };

        const isIOSDevice = () => /iphone|ipad|ipod/i.test(window.navigator.userAgent);

        function updateInstallButtonVisibility() {
            if (!installButtonElement) {
                return;
            }
            if (isStandaloneDisplayMode()) {
                installButtonElement.style.display = 'none';
                return;
            }
            if (isIOSDevice()) {
                installButtonElement.style.display = 'block';
                installButtonElement.textContent = 'ホームに追加（Safari共有から）';
                return;
            }
            installButtonElement.style.display = deferredInstallPrompt ? 'block' : 'none';
        }

        const standaloneMediaQuery = window.matchMedia ? window.matchMedia('(display-mode: standalone)') : null;
        if (standaloneMediaQuery) {
            if (typeof standaloneMediaQuery.addEventListener === 'function') {
                standaloneMediaQuery.addEventListener('change', updateInstallButtonVisibility);
            } else if (typeof standaloneMediaQuery.addListener === 'function') {
                standaloneMediaQuery.addListener(updateInstallButtonVisibility);
            }
        }

        window.addEventListener('beforeinstallprompt', (event) => {
            event.preventDefault();
            deferredInstallPrompt = event;
            updateInstallButtonVisibility();
        });

        window.addEventListener('appinstalled', () => {
            deferredInstallPrompt = null;
            updateInstallButtonVisibility();
        });

        const ALL_ALIENS = {{ all_aliens | tojson | safe }};
        const ALIEN_SKILL_DATA = {{ alien_skill_data | tojson | safe }};
        const ALL_EFFECTS = {{ all_effects | tojson | safe }};
        const S_SKILL_EFFECTS = {{ s_skill_effects | tojson | safe }};
        const ALIEN_EFFECTS = {{ alien_effects | tojson | safe }};

        // ======================================================================
        //  効果型・カテゴリの日本語化関数
        // ======================================================================
        function getEffectTypeDisplayName(effectType) {
            const typeMap = {
                'BUFF': 'バフ',
                'DEBUFF': 'デバフ',
                'STATUS': '状態異常'
            };
            return typeMap[effectType] || effectType;
        }

        function getCategoryDisplayName(category, effectType) {
            if (!category) return '(なし)';

            // 個性用カテゴリ
            if (category === 'BUFF_BOOST') return 'アップ系';
            if (category === 'BUFF_REDUCE') return '軽減系';
            if (category === 'BUFF_RESIST') return '抵抗系';
            if (category === 'BUFF_OTHER') return 'その他バフ';
            if (category === 'DEBUFF_DOWN') return 'ダウン系';
            if (category === 'DEBUFF_REDUCE') return 'ダウン系';
            if (category === 'DEBUFF_OTHER') return 'その他デバフ';
            if (category === 'STATUS_POISON') return '毒系';
            if (category === 'STATUS_STUN') return '気絶系';
            if (category === 'STATUS_OTHER') return 'その他状態異常';

            // 特技用カテゴリ
            if (category === 'S_SKILL_HEAL') return '回復系';
            if (category === 'S_SKILL_BUFF') return 'バフ系';
            if (category === 'S_SKILL_DEBUFF') return 'デバフ(状態異常)系';

            return category;
        }

        // ==========================================================================
        //  管理モード関連のグローバル変数
        // ==========================================================================
        let isAdminMode = false;
        let pendingChanges = []; // 変更履歴: [{type: 'add'|'update'|'delete', skill_text: '...', effect_name: '...', data: {...}}]

        // ==========================================================================
        //  通常のグローバル変数
        // ==========================================================================
        // 現在のタブ状態（'personality' または 'special'）
        let currentEffectTab = 'personality';
        let invalidDataFilterActive = false; // 不整合エイリアン絞り込みフラグ
        let effectUsageStats = {}; // 効果名ごとの使用数 {effect_name: count}

        // JavaScript文字列用のエスケープ関数（onclickで使用）
        function escapeJsString(str) {
            if (!str) return '';
            return str
                .replace(/\\/g, '\\\\')  // バックスラッシュを先にエスケープ
                .replace(/'/g, "\\'")    // シングルクォート
                .replace(/"/g, '\\"')    // ダブルクォート
                .replace(/\n/g, '\\n')   // 改行
                .replace(/\r/g, '\\r')   // キャリッジリターン
                .replace(/\t/g, '\\t');  // タブ
        }

        // タブごとの選択状態を保持（個性タブと特技タブで独立）
        const tabSelectionState = {
            'personality': new Set(),  // 個性タブの選択状態
            'special': new Set()       // 特技タブの選択状態
        };

        // 効果フィルターの検索モード（'and' または 'or'）
        const effectFilterMode = {
            personality: {
                headerRow: 'and'  // 個性タブ - ヘッダー行のANDボタン
            },
            special: {
                headerRow: 'and'  // 特技タブ - ヘッダー行のANDボタン
            },
            betweenTabs: 'and'    // 個性タブと特技タブの間のAND/OR
        };
        const selectedPersonalitySkillSlots = new Set(['1', '2', '3']);

        // 効果名をプロンプトの表記に統一する関数（特技用）
        function normalizeEffectName(effectName) {
            if (!effectName) return effectName;

            // 古い表記から新しい表記（プロンプトの表記）への変換マップ
            const effectNameMap = {
                'HP回復': 'たいりょく回復',
                'HP吸収': 'たいりょく吸収',
                'HP回復量ダウン': 'たいりょく回復量ダウン',
                'やる気アップ': 'やるきアップ',
                'やる気ダウン': 'やるきダウン',
                '移動速度アップ': 'いどうアップ',
                '移動速度ダウン': 'いどうダウン'
            };

            return effectNameMap[effectName] || effectName;
        }

        // target/condition_targetを日本語に変換する関数
        function convertTargetToJP(value) {
            if (!value || value === "") return "";

            // 固定値
            const fixedValues = {
                "自分": "自分",
                "味方全員": "味方全員",
                "敵全員": "敵全員",
                "敵単体": "敵単体",
                "敵全体": "敵全員", // 統一
                "攻撃した敵": "攻撃した敵"
            };
            if (value in fixedValues) return fixedValues[value];

            // category:value形式を変換
            const parts = value.split(',');
            const convertedParts = [];
            for (const part of parts) {
                const trimmed = part.trim();
                if (trimmed.includes(':')) {
                    const [cat, val] = trimmed.split(':');
                    const valJP = convertCategoryValueToJP(cat, val);
                    if (valJP) convertedParts.push(valJP);
                }
            }
            return convertedParts.length > 0 ? convertedParts.join(' / ') : value;
        }

        function convertCategoryValueToJP(category, value) {
            // 属性
            if (category === 'a') {
                const attrs = { '1': '動物', '2': '昆虫', '3': '機械', '4': 'ナゾ' };
                return attrs[value] || value;
            }
            // 所属
            else if (category === 'b') {
                const belongs = { '1': '宇宙連合', '2': '星間帝国', '3': '恒星連邦', '4': 'unknown', '5': '銀河同盟' };
                return belongs[value] || value;
            }
            // 攻撃はんい
            else if (category === 'c') {
                const ranges = { '1': 'たんたい', '2': 'はんい' };
                return ranges[value] || value;
            }
            // 攻撃距離
            else if (category === 'd') {
                const distances = { '1': 'ちかい', '2': 'ふつう', '3': 'とおい' };
                return distances[value] || value;
            }
            // タイプ
            else if (category === 'e') {
                const types = {
                    'A': '海', 'B': '夜', 'C': '氷', 'D': 'ラブ', 'E': '空',
                    'F': '音', 'G': '魔術', 'H': '熱', 'I': '大和', 'J': 'エレメント',
                    'K': '新星', 'L': 'チケット', 'M': '突然変異', 'N': '競技', 'O': '盗賊',
                    'P': '祈祷', 'Q': '闇', 'AA': 'パックマンシリーズまたはカタログIP', 'AW': 'リゼロ(eAW)'
                };
                return types[value] || value;
            }
            // ボスタイプ
            else if (category === 'boss') {
                const bossTypes = { '1': 'レジェンド' };
                return bossTypes[value] || value;
            }

            return `${category}:${value}`;
        }
        const partyDisplay = document.getElementById('party-display');
        const drawer = document.getElementById('alien-drawer');
        const toggleButton = document.getElementById('drawer-toggle');
        const mainContainer = document.getElementById('main-container');
        const alienGrid = document.getElementById('alien-grid');
        const filterButton = document.getElementById('filter-button');
        const filterMenu = document.getElementById('filter-menu');
        const effectFilterButton = document.getElementById('effect-filter-button');
        const effectFilterMenu = document.getElementById('effect-filter-menu');
        const sortButton = document.getElementById('sort-button');
        const sortOrderButton = document.getElementById('sort-order-button');
        const sortMenu = document.getElementById('sort-menu');
        const prevPartyBtn = document.getElementById('prev-party-btn');
        const nextPartyBtn = document.getElementById('next-party-btn');

        let parties = {
            '1': [null, null, null, null, null],
            '2': [null, null, null, null, null],
            '3': [null, null, null, null, null],
            '4': [null, null, null, null, null],
            '5': [null, null, null, null, null]
        };
        let currentPartyId = '1';
        let isAnimating = false;

        // 開いたスキルの状態を管理（パーティID → {slotIndex: skillIndex}）
        let openedSkills = {
            '1': {}, '2': {}, '3': {}, '4': {}, '5': {}
        };

        // --- シンプルなDnD状態管理（PC/スマホ共通） ---
        let dragState = {
            active: false,
            sourceIdx: null,
            currentHoverIdx: null,
            ghostElement: null,
        };

        // --- 長押しプレビュー状態管理 ---
        let longPressState = {
            timer: null,
            active: false,
            alienData: null
        };

        // プレビュー描画中の選択ハイライト更新制御
        let suppressSelectedHighlight = false;

        // --- エイリアンカードのDOMからJSで扱いやすいデータ構造を作成 ---
        const allAliensData = [];
        // DOMが読み込まれた後に実行するため、即座に実行
        (function initAlienData() {
            const cards = document.querySelectorAll('.alien-card');
            if (cards.length === 0) {
                // カードがまだ読み込まれていない場合は、DOMContentLoaded後に再試行
                document.addEventListener('DOMContentLoaded', initAlienData);
                return;
            }
            cards.forEach(card => {
                const dataset = card.dataset;
                const alienFullData = ALL_ALIENS[dataset.id] || {};
                allAliensData.push({
                    id: parseInt(dataset.id, 10) || 0,
                    name: dataset.name,
                    attribute: alienFullData.attribute,
                    affiliation: alienFullData.affiliation,
                    attack_area: alienFullData.attack_area,
                    attack_range: alienFullData.attack_range,
                    role: alienFullData.role,
                    types: [alienFullData.type_1, alienFullData.type_2, alienFullData.type_3, alienFullData.type_4].filter(t => t),
                    hp: alienFullData.hp || 0,
                    power: alienFullData.power || 0,
                    motivation: alienFullData.motivation || 0,
                    size: alienFullData.size || 0,
                    speed: alienFullData.speed || 0,
                    skill_text1: alienFullData.skill_text1 || '',
                    skill_text2: alienFullData.skill_text2 || '',
                    skill_text3: alienFullData.skill_text3 || '',
                    s_skill_text: alienFullData.s_skill_text || '',
                    element: card,
                    dataset: dataset
                });
            });
        })();

        let currentSort = { key: 'id', order: 'desc' };
        let activeFilters = {};
        let nameSearchQuery = '';

        /**
         * 文字列を正規化（ひらがな→カタカナ、全角→半角、大文字→小文字）
         */
        function normalizeString(str) {
            if (!str) return '';
            return str
                // 全角英数字を半角に変換
                .replace(/[Ａ-Ｚａ-ｚ０-９]/g, (s) => String.fromCharCode(s.charCodeAt(0) - 0xFEE0))
                // 全角スペースを半角に変換
                .replace(/　/g, ' ')
                // ひらがなをカタカナに変換
                .replace(/[ぁ-ゖ]/g, (s) => String.fromCharCode(s.charCodeAt(0) + 0x60))
                // 英字を小文字に変換
                .toLowerCase();
        }

        // --- データ管理・状態操作 ---

        /**
         * パーティにエイリアンを追加する
         * @param {object} alienCardDataSet - 追加するエイリアンのdataset
         */
        function addToParty(alienCardDataSet) {
            const party = parties[currentPartyId];
            const emptySlotIndex = party.indexOf(null);
            if (emptySlotIndex === -1) {
                return; // 満員の場合は何もせず終了
            }

            const isAlreadyInCurrentParty = party.some(member => member && member.id === alienCardDataSet.id);
            if (isAlreadyInCurrentParty) {
                // 既にパーティにいる場合は何もせずに関数を終了する
                return;
            }
            party[emptySlotIndex] = alienCardDataSet;
            renderPartySlots();
            renderDrawerPartyPreview(); // ドロワープレビューも更新
            updateAlienCardSelectedState(); // 一覧の.selectedクラスを更新
        }

        /**
         * パーティからエイリアンを削除する
         * @param {number} slotIndex - 削除するスロットのインデックス
         */
        function removeFromParty(slotIndex) {
            // 開いている説明文を閉じる
            delete openedSkills[currentPartyId][slotIndex];
            parties[currentPartyId][slotIndex] = null; // スロットを空にする
            renderPartySlots();
            renderDrawerPartyPreview(); // ドロワープレビューも更新
            updateAlienCardSelectedState(); // 一覧の.selectedクラスを更新
        }

        /**
         * 一覧のカードの.selectedクラスを現在のパーティの状態に基づいて更新
         * （重要：他パーティの編成状態は表示しない）
         */
        function updateAlienCardSelectedState() {
            if (suppressSelectedHighlight) {
                return;
            }

            // まず全カードから.selectedを削除
            document.querySelectorAll('.alien-card').forEach(card => {
                card.classList.remove('selected');
            });

            // 現在のパーティのみを走査して編成中のキャラに.selectedを付与
            const currentParty = parties[currentPartyId];
            currentParty.forEach(alien => {
                if (alien && alien.id) {
                    const card = document.querySelector(`.alien-card[data-id="${alien.id}"]`);
                    if (card) {
                        card.classList.add('selected');
                    }
                }
            });
        }

        /**
         * 表示するパーティを切り替える
         * @param {string} direction - 'next' または 'prev'
         */
        function switchParty(direction) {
            if (isAnimating) return;
            isAnimating = true;
            const currentId = parseInt(currentPartyId, 10);
            let nextId;
            if (direction === 'next') {
                nextId = currentId === 5 ? 1 : currentId + 1;
            } else if (direction === 'prev') {
                nextId = currentId === 1 ? 5 : currentId - 1;
            } else {
                nextId = currentId;
            }
            currentPartyId = String(nextId);
            // スライダーを動かす
            const slider = document.getElementById('party-slider-wrapper');
            slider.style.transform = `translateX(-${(nextId - 1) * 100}%)`;
            renderPartySlots();
            renderDrawerPartyPreview(); // ドロワープレビューも更新
            updatePartySelectorUI();
            setTimeout(() => { isAnimating = false; }, 150);
        }
        /**
         * パーティセレクターのUI（ドットと矢印）を更新する
         */
        function updatePartySelectorUI() {
            const partyId = parseInt(currentPartyId, 10);
            document.querySelectorAll('.dot').forEach(dot => {
                dot.classList.toggle('active', dot.dataset.partyId == partyId);
            });
            // ループするのでボタンは常に有効
            prevPartyBtn.disabled = false;
            nextPartyBtn.disabled = false;
        }

        // ==========================================================================
        //  長押しプレビュー機能
        // ==========================================================================

        /**
         * 長押しプレビューを表示（そのキャラのみのスロットを表示）
         * @param {object} alienDataSet - プレビューするエイリアンのdataset
         */
        function enablePreviewSkillToggle(slotElement) {
            if (!slotElement) return;
            const skillsArea = slotElement.querySelector('.slot-skills-area');
            if (!skillsArea) return;

            skillsArea.classList.remove('skills-area-detail-view');
            skillsArea.querySelectorAll('.skill-block').forEach(block => block.classList.remove('is-active'));

            skillsArea.querySelectorAll('.skill-block').forEach(block => {
                block.addEventListener('click', event => {
                    event.stopPropagation();
                    const wasActive = block.classList.contains('is-active');

                    skillsArea.querySelectorAll('.skill-block').forEach(el => el.classList.remove('is-active'));
                    skillsArea.classList.remove('skills-area-detail-view');

                    if (!wasActive) {
                        skillsArea.classList.add('skills-area-detail-view');
                        block.classList.add('is-active');
                    }
                });
            });
        }
        function showLongPressPreview(alienDataSet) {
            if (!alienDataSet || !alienDataSet.id) {
                console.error('showLongPressPreview: Invalid alienDataSet', alienDataSet);
                return;
            }

            const previewOverlay = document.getElementById('preview-overlay');
            const previewContainer = document.getElementById('preview-slot-container');
            if (!previewOverlay || !previewContainer) {
                console.error('showLongPressPreview: Missing DOM elements');
                return;
            }

            previewContainer.innerHTML = '<div id="party-container-preview" class="party-container"></div>';

            const tempPartyId = 'preview';
            const originalCurrentPartyId = currentPartyId;
            const originalPreviewParty = parties[tempPartyId];
            const originalPreviewOpened = openedSkills[tempPartyId];

            // 現在のパーティに追加した仮定でプレビューパーティを構築
            const currentParty = parties[currentPartyId];

            // 既に編成済みかチェック（数値として比較）
            const targetAlienId = parseInt(alienDataSet.id, 10);
            const alreadyInParty = currentParty.some(member => member && parseInt(member.id, 10) === targetAlienId);

            let previewParty;
            if (alreadyInParty) {
                // 既に編成済み → そのまま5体
                previewParty = [...currentParty];
            } else {
                const emptySlotIndex = currentParty.indexOf(null);
                if (emptySlotIndex !== -1) {
                    // 空きがある → 5体のまま該当スロットに配置
                    previewParty = [...currentParty];
                    previewParty[emptySlotIndex] = alienDataSet;
                } else {
                    // 満員 → プレビュー専用で6体目を追加
                    previewParty = [...currentParty, alienDataSet];
                }
            }

            parties[tempPartyId] = previewParty;
            openedSkills[tempPartyId] = {};
            currentPartyId = tempPartyId;
            suppressSelectedHighlight = true;
            try {
                renderPartySlots(tempPartyId);
            } finally {
                suppressSelectedHighlight = false;
            }
            // 条件判定は描画済みのpreviewパーティ（最大6体）に対して通常通り実行
            checkPartyRealtime(tempPartyId);
            currentPartyId = originalCurrentPartyId;

            const partyContainer = previewContainer.querySelector('#party-container-preview');
            if (partyContainer) {
                const slots = Array.from(partyContainer.querySelectorAll('.party-slot'));
                let foundTargetSlot = false;

                slots.forEach((slot, idx) => {
                    // プレビュー対象のキャラのスロットのみ残す（数値として比較）
                    const slotAlien = previewParty[idx];
                    const slotAlienId = slotAlien ? parseInt(slotAlien.id, 10) : null;

                    if (slotAlienId !== targetAlienId) {
                        slot.remove();
                    } else {
                        foundTargetSlot = true;
                        slot.querySelectorAll('.remove-button').forEach(btn => btn.remove());
                        // 中列の「たいりょく」「つよさ」を削除
                        const hpPowerBlock = slot.querySelector('.stats-hp-power-block');
                        if (hpPowerBlock) {
                            hpPowerBlock.remove();
                        }
                        const cleaned = slot.cloneNode(true);
                        partyContainer.replaceChild(cleaned, slot);
                        enablePreviewSkillToggle(cleaned);
                    }
                });

                if (!foundTargetSlot) {
                    console.error('showLongPressPreview: Target slot not found for alien ID', targetAlienId);
                }

                partyContainer.style.gap = '0';
            }

            if (originalPreviewParty) {
                parties[tempPartyId] = originalPreviewParty;
            } else {
                delete parties[tempPartyId];
            }
            if (originalPreviewOpened) {
                openedSkills[tempPartyId] = originalPreviewOpened;
            } else {
                delete openedSkills[tempPartyId];
            }

            previewOverlay.classList.add('active');
            longPressState.active = true;
            longPressState.alienData = alienDataSet;
            drawer.style.pointerEvents = 'none';
        }

        /**
         * 長押しプレビューを閉じる
         */
        function closeLongPressPreview() {
            const previewOverlay = document.getElementById('preview-overlay');
            previewOverlay.classList.remove('active');
            longPressState.active = false;
            longPressState.alienData = null;

            // UI操作を再有効化
            drawer.style.pointerEvents = '';
        }

        /**
         * 長押しタイマーをキャンセル
         */
        function cancelLongPressTimer() {
            if (longPressState.timer) {
                clearTimeout(longPressState.timer);
                longPressState.timer = null;
            }
        }

        /**
         * ドロワーを開く
         */
        function openDrawer(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();
            }
            // ドラッグ中は開かない
            if (dragState.active) {
                return;
            }
            if (!drawer.classList.contains('open')) {
                // 少し遅延させてクリックイベントの伝播を完全に防ぐ
                setTimeout(() => {
                    drawer.classList.add('open');
                    toggleButton.textContent = '◀';
                    // History APIで履歴追加
                    if (!drawer.dataset.historyAdded) {
                        history.pushState({ drawer: true }, '');
                        drawer.dataset.historyAdded = 'true';
                    }
                }, 50);
            }
        }

        // --- DOM操作・表示更新 ---

        /**
         * エイリアンの画像要素を作成（既存の画像を再利用して再読み込みを防ぐ）
         * @param {number|string} alienId - エイリアンID
         * @param {string} className - 画像要素のクラス名
         * @param {string} alt - alt属性の値
         * @returns {HTMLImageElement} 画像要素
         */
        function createAlienImageElement(alienId, className = '', alt = '') {
            // 既存の画像要素を検索してクローン（再読み込みを防ぐ）
            const existingCard = document.querySelector(`.alien-card[data-id="${alienId}"]`);
            let img;
            if (existingCard) {
                const existingImg = existingCard.querySelector('img');
                if (existingImg && existingImg.complete) {
                    // 既に読み込まれている画像をクローン
                    img = existingImg.cloneNode(false);
                } else {
                    img = document.createElement('img');
                    img.src = `/static/images/${alienId}.webp`;
                }
            } else {
                img = document.createElement('img');
                img.src = `/static/images/${alienId}.webp`;
            }
            if (className) img.className = className;
            if (alt) img.alt = alt;
            return img;
        }
        /**
         * アイコン画像要素を作成（既存の画像を再利用して再読み込みを防ぐ）
         * @param {string} iconName - アイコン名（例: 'a1', 'b2', 'eA'）
         * @param {string} style - スタイル文字列
         * @returns {HTMLImageElement} 画像要素
         */
        function createIconImageElement(iconName, style = '') {
            // 既存のDOMから該当するアイコン画像を検索
            const existingIcon = document.querySelector(`img[src="/static/icon/${iconName}.webp"]`);
            let img;
            if (existingIcon && existingIcon.complete) {
                // 既に読み込まれている画像をクローン
                img = existingIcon.cloneNode(false);
            } else {
                img = document.createElement('img');
                img.src = `/static/icon/${iconName}.webp`;
            }
            if (style) {
                img.setAttribute('style', style);
            }
            return img;
        }
        /**
         * HTML文字列内の画像要素を既存のDOMからクローンした要素に置き換える
         * @param {HTMLElement} container - 画像要素を含むコンテナ要素
         */
        function replaceIconImagesWithClones(container) {
            const imgElements = container.querySelectorAll('img[src^="/static/icon/"]');
            imgElements.forEach(img => {
                const src = img.getAttribute('src');
                if (src) {
                    const iconName = src.replace('/static/icon/', '').replace('.webp', '');
                    const existingIcon = document.querySelector(`img[src="${src}"]`);
                    if (existingIcon && existingIcon !== img && existingIcon.complete) {
                        // 既存の画像をクローンして置き換え
                        const clonedImg = existingIcon.cloneNode(false);
                        // スタイルを引き継ぐ
                        if (img.style.cssText) {
                            clonedImg.setAttribute('style', img.style.cssText);
                        }
                        img.parentNode.replaceChild(clonedImg, img);
                    }
                }
            });
        }
        /**
         * パーティスロット用のアクションボタンを作成（管理モード時は管理ボタン、通常時は編成解除ボタン）
         * @param {boolean} isAdminMode - 管理モードかどうか
         * @param {Object} alienData - エイリアンデータ
         * @param {number} slotIndex - スロットインデックス
         * @returns {HTMLButtonElement} アクションボタン要素
         */
        function createActionButton(isAdminMode, alienData, slotIndex) {
            const actionBtn = document.createElement('button');
            actionBtn.className = 'remove-button';

            if (isAdminMode) {
                actionBtn.textContent = '管理';
                actionBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    openSkillManagementModal(alienData, slotIndex);
                });
                actionBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    openSkillManagementModal(alienData, slotIndex);
                }, { passive: false });
            } else {
                actionBtn.textContent = '編成解除';
                actionBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    removeFromParty(slotIndex);
                });
                actionBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    removeFromParty(slotIndex);
                }, { passive: false });
            }

            return actionBtn;
        }
        /**
         * 指定されたパーティIDの編成を画面に描画する
         * @param {string} partyId - 描画するパーティのID（'1'～'5'）
         */
        function renderPartySlots(partyId = currentPartyId) {
            const party = parties[partyId];
            const partyContainer = document.getElementById(`party-container-${partyId}`);
            partyContainer.innerHTML = '';

            // プレビュー専用の拡張: previewパーティは最大6体まで描画（満員時の長押し用）
            const maxSlots = (partyId === 'preview') ? Math.min(party.length, 6) : 5;
            for (let i = 0; i < maxSlots; i++) {
                const alienDataSet = party[i];
                const isOccupied = alienDataSet !== null;
                // ！！！ (注) alienData は ALL_ALIENS (辞書) から取得 ！！！
                const alienData = isOccupied ? ALL_ALIENS[alienDataSet.id] : null;

                // スロット要素を作成
                const slot = document.createElement('div');
                slot.className = 'party-slot';
                slot.dataset.slotIndex = i;
                const memberKey = isOccupied ? `id-${alienData.id}` : `empty-${i}`;
                slot.dataset.memberKey = memberKey;

                // === 左列: キャラクターエリア（名前 + アイコン） ===
                const characterArea = document.createElement('div');
                characterArea.className = 'slot-character-area';
                if (isOccupied && alienData.attribute) {
                    characterArea.dataset.attribute = alienData.attribute;
                }

                // 名前
                const nameDiv = document.createElement('div');
                nameDiv.className = 'slot-character-name';
                nameDiv.textContent = isOccupied ? alienData.name : '';

                // アイコン
                if (isOccupied) {
                    const iconImg = createAlienImageElement(alienData.id, 'slot-character-icon');
                    iconImg.draggable = false;

                    // PC/スマホ共通: ポインターイベント
                    iconImg.addEventListener('mousedown', (e) => handleDragStart(e, i));
                    iconImg.addEventListener('touchstart', (e) => handleDragStart(e, i), { passive: false });

                    // 管理モード時は管理ボタン、通常時は編成解除ボタン
                    const actionBtn = createActionButton(isAdminMode, alienData, i);

                    characterArea.appendChild(nameDiv);
                    characterArea.appendChild(iconImg);
                    characterArea.appendChild(actionBtn);
                } else {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'slot-character-icon-placeholder';
                    placeholder.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        openDrawer(e);
                    });
                    placeholder.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        if (!dragState.active) {
                            openDrawer(e);
                        }
                    }, { passive: false });

                    characterArea.appendChild(nameDiv);
                    characterArea.appendChild(placeholder);
                }

                // === 中列: ステータスエリア（HP/パワー、こうげき/所属、タイプ） ===
                const statsArea = document.createElement('div');
                statsArea.className = 'slot-stats-area';

                // たいりょく/つよさの表示（未編成時も同じ構造で表示）
                const hp = isOccupied ? (alienData.hp || '---') : '---';
                const power = isOccupied ? (alienData.power || '---') : '---';
                const hpPowerHtml = `<div class="stats-block stats-hp-power-block"><div class="stats-value-row"><span class="stats-value-label">たいりょく</span><span class="stats-value-number">${hp}</span></div><div class="stats-value-row"><span class="stats-value-label">つよさ</span><span class="stats-value-number">${power}</span></div></div>`;

                // こうげき/所属（未編成時も同じ構造で表示）
                let attackHtml = '';
                if (isOccupied) {
                    if (alienData.attack_range) attackHtml += `<img class="info-icon" src="/static/icon/d${alienData.attack_range}.webp">`;
                    if (alienData.attack_area) attackHtml += `<img class="info-icon" src="/static/icon/c${alienData.attack_area}.webp">`;
                    if (alienData.affiliation) attackHtml += `<img class="info-icon" src="/static/icon/b${alienData.affiliation}.webp">`;
                }

                // タイプ（未編成時も同じ構造で表示）
                let typeHtml = '';
                if (isOccupied) {
                    if (alienData.role) {
                        typeHtml += `<img class="info-icon" src="/static/icon/f${alienData.role}.webp">`;
                    } else {
                        typeHtml += `<div class="icon-placeholder-small"></div>`;
                    }
                    for (let j = 1; j <= 4; j++) {
                        const typeValue = alienData[`type_${j}`];
                        if (typeValue) {
                            typeHtml += `<img class="info-icon" src="/static/icon/e${typeValue}.webp">`;
                        }
                    }
                }

                statsArea.innerHTML = `${hpPowerHtml}<div class="stats-block"><div class="stats-block-label">こうげき/所属</div><div class="stats-block-divider"></div><div class="icon-container">${attackHtml}</div></div><div class="stats-block"><div class="stats-block-label">タイプ</div><div class="stats-block-divider"></div><div class="icon-container">${typeHtml}</div></div>`;

                // === 右列: スキルエリア（特技 + 個性1-3） ===
                let skillsAreaContent = '';

                // 特技ブロック（要求アイコンなし）
                // ！！！ (修正) S_Skill -> s_skill, S_Skill_text -> s_skill_text ！！！
                const specialSkillName = isOccupied ? (alienData.s_skill || '(特技なし)') : '';
                const specialSkillText = isOccupied ? (alienData.s_skill_text || '説明文がありません。') : '';

                skillsAreaContent += `<div class="skill-block special-skill" data-slot-index="${i}" data-skill-index="0">
                <div class="skill-name-display">
                    <div class="skill-label">特技</div>
                    <div class="skill-name">${specialSkillName}</div>
                </div>
                <div class="skill-label">特技</div>
                <div class="skill-item">
                    <div class="skill-name">${specialSkillName}</div>
                </div>
                <div class="skill-description">${specialSkillText}</div>
            </div>`;

                // 個性1-3のブロック
                // const alienReqs = isOccupied ? (ALL_REQUIREMENTS[alienData.id] || []) : []; // ← ★古い参照を削除
                for (let j = 1; j <= 3; j++) {
                    const skillName = isOccupied ? (alienData[`skill_no${j}`] || '(個性なし)') : '';
                    const skillText = isOccupied ? (alienData[`skill_text${j}`] || '説明文がありません。') : '';
                    let reqIconsHtml = '';

                    if (isOccupied) {
                        // ！！！ (新) ALIEN_SKILL_DATA から要求を取得 ！！！
                        const requirements = ALIEN_SKILL_DATA[alienData.id]?.[j] || [];

                        requirements.forEach(req => {
                            // ！！！ (新) createRequirementIcon でHTMLを生成 ！！！
                            // (isMet はここでは判定せず、checkPartyRealtime に任せるため 'false' 固定でまず描画)
                            reqIconsHtml += createRequirementIcon(req.type, req.value, req.count, false, req.is_not);
                        });
                    }

                    skillsAreaContent += `<div class="skill-block" data-slot-index="${i}" data-skill-index="${j}">
                    <div class="skill-name-display">
                        <div class="skill-label">個性${j}</div>
                        <div class="skill-name">${skillName}</div>
                        <div class="skill-req-icons">${reqIconsHtml}</div>
                    </div>
                    <div class="skill-label">個性${j}</div>
                    <div class="skill-item">
                        <div class="skill-name">${skillName}</div>
                        <div class="skill-req-icons">${reqIconsHtml}</div>
                    </div>
                    <div class="skill-description">${skillText}</div>
                </div>`;
                }

                const skillsArea = document.createElement('div');
                skillsArea.className = 'slot-skills-area';
                skillsArea.innerHTML = skillsAreaContent;

                // スロットに追加（新構造: character, stats, skills）
                slot.appendChild(characterArea);
                slot.appendChild(statsArea);
                slot.appendChild(skillsArea);
                partyContainer.appendChild(slot);
            }

            // 保存されたスキル開閉状態を復元
            const savedState = openedSkills[partyId];
            if (savedState) {
                Object.keys(savedState).forEach(slotIndex => {
                    const skillIndex = savedState[slotIndex];
                    if (skillIndex !== null && skillIndex !== undefined) {
                        const skillBlock = partyContainer.querySelector(`.skill-block[data-slot-index="${slotIndex}"][data-skill-index="${skillIndex}"]`);
                        if (skillBlock) {
                            const parentArea = skillBlock.parentElement;
                            parentArea.classList.add('skills-area-detail-view');
                            skillBlock.classList.add('is-active');
                        }
                    }
                });
            }

            updateSelectedStatusInList();
            // ！！！ (重要) 描画が完了した直後に判定処理を呼ぶ ！！！
            checkPartyRealtime(partyId);

        }
        //
        // △△△ ここまでを置き換え △△△
        //
        /**
         * ドロワー内のパーティプレビューを更新
         */
        function renderDrawerPartyPreview() {
            const partyLabel = document.getElementById('preview-party-label');
            const previewSlots = document.getElementById('preview-slots');

            if (!partyLabel || !previewSlots) return;

            // パーティ番号を更新
            partyLabel.textContent = `P${currentPartyId}`;

            // プレビュースロットを生成
            const party = parties[currentPartyId];
            previewSlots.innerHTML = '';

            for (let i = 0; i < 5; i++) {
                const alienDataSet = party[i];
                const isOccupied = alienDataSet !== null;
                const alienData = isOccupied ? ALL_ALIENS[alienDataSet.id] : null;

                const slot = document.createElement('div');
                slot.className = 'preview-slot';
                slot.dataset.slotIndex = i;

                if (isOccupied) {
                    // 属性による枠線色
                    if (alienData.attribute) {
                        slot.dataset.attribute = alienData.attribute;
                    }

                    // アイコン画像
                    const img = createAlienImageElement(alienData.id, '', alienData.name);
                    slot.appendChild(img);

                    // スロット全体でドラッグを検出
                    slot.addEventListener('mousedown', (e) => {
                        handlePreviewDragStart(e, i);
                    });

                    slot.addEventListener('touchstart', (e) => {
                        handlePreviewDragStart(e, i);
                    }, { passive: false });
                } else {
                    // 空スロット
                    slot.classList.add('empty');
                }

                previewSlots.appendChild(slot);
            }
        }

        // --- ミニアイコンのDnD実装 ---
        let previewDragState = {
            active: false,
            sourceIdx: null,
            currentHoverIdx: null,
            hoverAlienCard: null,
            ghostElement: null,
        };

        function handlePreviewDragStart(e, idx) {
            if (previewDragState.active) return;

            e.preventDefault();
            previewDragState.active = true;
            previewDragState.sourceIdx = idx;
            previewDragState.currentHoverIdx = null;

            const party = parties[currentPartyId];
            const member = party[idx];
            if (!member) return;

            // ドロップゾーンを表示
            const dropZone = document.getElementById('drop-zone');
            if (dropZone) {
                dropZone.classList.add('active');
            }

            // ゴースト作成（ミニアイコンサイズ）
            const ghost = document.createElement('img');
            ghost.src = `/static/images/${member.id}.webp`;
            ghost.className = 'preview-drag-ghost';
            ghost.style.position = 'fixed';
            ghost.style.zIndex = 9999;
            ghost.style.pointerEvents = 'none';
            ghost.style.width = '6.72vh';
            ghost.style.height = '6.72vh';
            ghost.style.transform = 'scale(1.2)';
            ghost.style.opacity = '0.8';
            document.body.appendChild(ghost);
            previewDragState.ghostElement = ghost;

            updatePreviewGhostPosition(e);

            // ポインター移動・終了イベント登録
            document.addEventListener('mousemove', handlePreviewDragMove);
            document.addEventListener('mouseup', handlePreviewDragEnd);
            document.addEventListener('touchmove', handlePreviewDragMove, { passive: false });
            document.addEventListener('touchend', handlePreviewDragEnd);
        }

        function handlePreviewDragMove(e) {
            if (!previewDragState.active) return;

            e.preventDefault();
            updatePreviewGhostPosition(e);

            // カーソル位置取得
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            const el = document.elementFromPoint(clientX, clientY);
            if (!el) return;

            // ドロップゾーン上にいるか判定
            const dropZone = document.getElementById('drop-zone');
            const isOverDropZone = el.closest('#drop-zone') !== null;

            // 一覧のエイリアンカード上にいるか判定
            let alienCard = el.closest('.alien-card');

            // 編成中のキャラは入れ替え対象から除外
            if (alienCard && alienCard.classList.contains('selected')) {
                alienCard = null;
            }

            // 前回のホバー状態をクリア
            document.querySelectorAll('.alien-card').forEach(c => c.classList.remove('drag-swap-target'));

            if (isOverDropZone) {
                // ドロップゾーン上 → ホバー状態
                if (dropZone) dropZone.classList.add('hover');
                document.querySelectorAll('.preview-slot').forEach(s => s.classList.remove('drag-over'));
                previewDragState.currentHoverIdx = null;
                previewDragState.hoverAlienCard = null;
            } else if (alienCard) {
                // 一覧のキャラ上（編成中でない）→ ハイライト
                if (dropZone) dropZone.classList.remove('hover');
                document.querySelectorAll('.preview-slot').forEach(s => s.classList.remove('drag-over'));
                alienCard.classList.add('drag-swap-target');
                previewDragState.currentHoverIdx = null;
                previewDragState.hoverAlienCard = alienCard;
            } else {
                // スロット上 → 通常の入れ替えハイライト
                if (dropZone) dropZone.classList.remove('hover');

                const slotEl = el.closest('.preview-slot');
                let hoverIdx = null;
                if (slotEl && slotEl.dataset && slotEl.dataset.slotIndex != null) {
                    hoverIdx = parseInt(slotEl.dataset.slotIndex, 10);
                }

                // ホバー状態更新
                if (hoverIdx !== previewDragState.currentHoverIdx) {
                    document.querySelectorAll('.preview-slot').forEach(s => s.classList.remove('drag-over'));
                    if (hoverIdx != null && hoverIdx !== previewDragState.sourceIdx) {
                        const targetSlot = document.querySelector(`.preview-slot[data-slot-index="${hoverIdx}"]`);
                        if (targetSlot) targetSlot.classList.add('drag-over');
                    }
                    previewDragState.currentHoverIdx = hoverIdx;
                    previewDragState.hoverAlienCard = null;
                }
            }
        }
        function handlePreviewDragEnd(e) {
            if (!previewDragState.active) return;

            e.preventDefault();

            // カーソル位置取得（ドロップ位置判定）※ドロップゾーン非表示前に取得
            let clientX, clientY;
            if (e.changedTouches && e.changedTouches.length > 0) {
                clientX = e.changedTouches[0].clientX;
                clientY = e.changedTouches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            const el = document.elementFromPoint(clientX, clientY);
            const isDroppedOnDropZone = el && el.closest('#drop-zone') !== null;
            const droppedAlienCard = el ? el.closest('.alien-card') : null;

            // イベントリスナー解除
            document.removeEventListener('mousemove', handlePreviewDragMove);
            document.removeEventListener('mouseup', handlePreviewDragEnd);
            document.removeEventListener('touchmove', handlePreviewDragMove);
            document.removeEventListener('touchend', handlePreviewDragEnd);

            // ハイライト解除
            document.querySelectorAll('.preview-slot').forEach(s => s.classList.remove('drag-over'));
            document.querySelectorAll('.alien-card').forEach(c => c.classList.remove('drag-swap-target'));

            // ドロップゾーンを非表示
            const dropZone = document.getElementById('drop-zone');
            if (dropZone) {
                dropZone.classList.remove('active', 'hover');
            }

            if (isDroppedOnDropZone) {
                // ドロップゾーンにドロップ → 編成解除
                removeFromParty(previewDragState.sourceIdx);
            } else if (droppedAlienCard) {
                // 一覧のキャラカードにドロップ → キャラ入れ替え

                // 編成中のキャラには入れ替えできない
                if (droppedAlienCard.classList.contains('selected')) {
                    // 何もしない（編成中）
                } else {
                    const alienId = droppedAlienCard.dataset.id;
                    if (alienId && ALL_ALIENS[alienId]) {
                        const sourceIdx = previewDragState.sourceIdx;
                        const swapTarget = allAliensData.find(entry => entry.id === parseInt(alienId, 10));

                        // 念のため再度編成済みかチェック（全パーティを確認）
                        let alreadyInParty = false;
                        for (let partyId in parties) {
                            const found = parties[partyId].some((alien, idx) =>
                                alien && alien.id === parseInt(alienId, 10)
                            );
                            if (found) {
                                alreadyInParty = true;
                                break;
                            }
                        }

                        if (!alreadyInParty && swapTarget && swapTarget.dataset) {
                            // 1. まず元のキャラを編成解除
                            // 開いている説明文を閉じる
                            delete openedSkills[currentPartyId][sourceIdx];
                            parties[currentPartyId][sourceIdx] = null;

                            // 2. 新しいキャラを同じスロットに配置
                            parties[currentPartyId][sourceIdx] = swapTarget.dataset;

                            // 3. UI更新
                            renderPartySlots();
                            renderDrawerPartyPreview();
                            checkPartyRealtime();

                            // 4. 一覧の.selectedクラスを更新
                            updateAlienCardSelectedState();
                        }
                    }
                }
            } else if (previewDragState.currentHoverIdx != null && previewDragState.sourceIdx !== previewDragState.currentHoverIdx) {
                // スロット上にドロップ → 入れ替え実行
                const party = parties[currentPartyId];
                const srcIdx = previewDragState.sourceIdx;
                const targetIdx = previewDragState.currentHoverIdx;

                // 開いている説明文を閉じる
                const minIdx = Math.min(srcIdx, targetIdx);
                const maxIdx = Math.max(srcIdx, targetIdx);
                for (let i = minIdx; i <= maxIdx; i++) {
                    delete openedSkills[currentPartyId][i];
                }

                // 配列入れ替え
                const item = party[srcIdx];
                party.splice(srcIdx, 1);
                party.splice(targetIdx, 0, item);

                renderPartySlots();
                renderDrawerPartyPreview();
            }

            // ゴースト削除
            if (previewDragState.ghostElement && previewDragState.ghostElement.parentNode) {
                previewDragState.ghostElement.parentNode.removeChild(previewDragState.ghostElement);
            }

            // 状態リセット
            previewDragState.active = false;
            previewDragState.sourceIdx = null;
            previewDragState.currentHoverIdx = null;
            previewDragState.ghostElement = null;
        }

        function updatePreviewGhostPosition(e) {
            if (!previewDragState.ghostElement) return;

            let x, y;
            if (e.touches && e.touches.length > 0) {
                x = e.touches[0].clientX;
                y = e.touches[0].clientY;
            } else {
                x = e.clientX;
                y = e.clientY;
            }

            previewDragState.ghostElement.style.left = (x - previewDragState.ghostElement.offsetWidth / 2) + 'px';
            previewDragState.ghostElement.style.top = (y - previewDragState.ghostElement.offsetHeight / 2) + 'px';
        }

        // --- シンプルなDnD実装（PC/スマホ共通、アニメーション無し） ---
        function handleDragStart(e, idx) {
            // 既にドラッグ中なら無視
            if (dragState.active) return;

            e.preventDefault();
            dragState.active = true;
            dragState.sourceIdx = idx;
            dragState.currentHoverIdx = null;

            // ゴースト作成
            const party = parties[currentPartyId];
            const member = party[idx];
            if (!member) return;

            const ghost = document.createElement('img');
            ghost.src = `/static/images/${member.id}.webp`;
            ghost.className = 'drag-ghost-img';
            ghost.style.position = 'fixed';
            ghost.style.zIndex = 9999;
            ghost.style.pointerEvents = 'none';
            ghost.style.width = '9.5vh';
            ghost.style.height = '9.5vh';
            ghost.style.transform = 'scale(1.18)';
            document.body.appendChild(ghost);
            dragState.ghostElement = ghost;

            // 初期位置設定
            updateGhostPosition(e);

            // パーティ切り替え無効化
            disablePartySwitch(true);

            // ポインター移動・終了イベント登録
            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', handleDragEnd);
            document.addEventListener('touchmove', handleDragMove, { passive: false });
            document.addEventListener('touchend', handleDragEnd);
        }
        function handleDragMove(e) {
            if (!dragState.active) return;

            e.preventDefault();
            updateGhostPosition(e);

            // ホバー中のスロット検出
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            const el = document.elementFromPoint(clientX, clientY);
            if (!el) return;

            const slotEl = el.closest('.party-slot');
            let hoverIdx = null;
            if (slotEl && slotEl.dataset && slotEl.dataset.slotIndex != null) {
                hoverIdx = parseInt(slotEl.dataset.slotIndex, 10);
            }

            // ホバー状態更新
            if (hoverIdx !== dragState.currentHoverIdx) {
                document.querySelectorAll('.party-slot').forEach(s => s.classList.remove('drag-over'));
                if (hoverIdx != null && hoverIdx !== dragState.sourceIdx) {
                    const container = document.getElementById(`party-container-${currentPartyId}`);
                    const targetSlot = container.querySelector(`.party-slot[data-slot-index="${hoverIdx}"]`);
                    if (targetSlot) targetSlot.classList.add('drag-over');
                }
                dragState.currentHoverIdx = hoverIdx;
            }
        }
        function handleDragEnd(e) {
            if (!dragState.active) return;

            e.preventDefault();

            // イベントリスナー解除
            document.removeEventListener('mousemove', handleDragMove);
            document.removeEventListener('mouseup', handleDragEnd);
            document.removeEventListener('touchmove', handleDragMove);
            document.removeEventListener('touchend', handleDragEnd);

            // ハイライト解除
            document.querySelectorAll('.party-slot').forEach(s => s.classList.remove('drag-over'));

            // 入れ替え実行
            if (dragState.currentHoverIdx != null && dragState.sourceIdx !== dragState.currentHoverIdx) {
                const party = parties[currentPartyId];
                const srcIdx = dragState.sourceIdx;
                const targetIdx = dragState.currentHoverIdx;

                // 開いている説明文を閉じる（移動に関わる全てのスロット）
                const minIdx = Math.min(srcIdx, targetIdx);
                const maxIdx = Math.max(srcIdx, targetIdx);
                for (let i = minIdx; i <= maxIdx; i++) {
                    delete openedSkills[currentPartyId][i];
                }

                // シンプルな配列入れ替え（挿入型）
                const item = party[srcIdx];
                party.splice(srcIdx, 1);
                party.splice(targetIdx, 0, item);

                renderPartySlots();
            }

            // ゴースト削除
            if (dragState.ghostElement && dragState.ghostElement.parentNode) {
                dragState.ghostElement.parentNode.removeChild(dragState.ghostElement);
            }

            // パーティ切り替え有効化
            disablePartySwitch(false);

            // 状態リセット
            dragState.active = false;
            dragState.sourceIdx = null;
            dragState.currentHoverIdx = null;
            dragState.ghostElement = null;
        }

        function updateGhostPosition(e) {
            if (!dragState.ghostElement) return;

            let x, y;
            if (e.touches && e.touches.length > 0) {
                x = e.touches[0].clientX;
                y = e.touches[0].clientY;
            } else {
                x = e.clientX;
                y = e.clientY;
            }

            dragState.ghostElement.style.left = (x - dragState.ghostElement.offsetWidth / 2) + 'px';
            dragState.ghostElement.style.top = (y - dragState.ghostElement.offsetHeight / 2) + 'px';
        }

        function disablePartySwitch(disabled) {
            const prevBtn = document.getElementById('prev-party');
            const nextBtn = document.getElementById('next-party');
            const partyBtns = document.querySelectorAll('.party-btn');

            if (disabled) {
                if (prevBtn) prevBtn.style.pointerEvents = 'none';
                if (nextBtn) nextBtn.style.pointerEvents = 'none';
                partyBtns.forEach(btn => btn.style.pointerEvents = 'none');
            } else {
                if (prevBtn) prevBtn.style.pointerEvents = '';
                if (nextBtn) nextBtn.style.pointerEvents = '';
                partyBtns.forEach(btn => btn.style.pointerEvents = '');
            }
        }

        /**
         * エイリアン一覧で、現在パーティにいるエイリアンを選択中として表示する
         */
        function updateSelectedStatusInList() {
            if (suppressSelectedHighlight) {
                return;
            }
            const currentPartyMemberIds = new Set(parties[currentPartyId].filter(m => m).map(m => m.id));
            document.querySelectorAll('.alien-card').forEach(card => {
                card.classList.toggle('selected', currentPartyMemberIds.has(card.dataset.id));
            });
        }
        //
        // ======================================================================
        //  効果型・カテゴリの日本語化関数
        // ======================================================================

        /**
         * (修正) member.id の参照方法を修正
         */
        function checkPartyRealtime(partyId = currentPartyId, overrideParty = null, domIndexMap = null) {
            const containerId = (partyId === 'preview') ? 'party-container-preview' : `party-container-${partyId}`;
            const partyContainer = document.getElementById(containerId);
            if (!partyContainer) return;

            const party = overrideParty || parties[partyId];

            party.forEach((member, slotIdx) => {
                // ！！！ (★修正★) member が null でないこと、かつ member.id が存在することを確認 ！！！
                if (!member || !member.id) return;

                // ！！！ (★修正★) member は dataset オブジェクトなので、IDは member.id で取得 ！！！
                const alienIdStr = member.id; // ここが正しいID文字列

                // 1. 自分以外の味方構成を集計 (★ 既存のロジックを維持 ★)
                const counts = { a: {}, b: {}, c: {}, d: {}, e: {}, f: {} };
                let alliesTotalCount = 0;

                party.forEach((other, idx) => {
                    // ！！！ (★修正★) other も dataset なので other.id でIDを取得 ！！！
                    if (!other || !other.id || idx === slotIdx) return;

                    // ！！！ (注) ALL_ALIENS のキーは文字列IDなので other.id を使う ！！！
                    const alien = ALL_ALIENS[other.id];
                    if (!alien) return;

                    alliesTotalCount++;
                    if (alien.attribute) counts.a[alien.attribute] = (counts.a[alien.attribute] || 0) + 1;
                    if (alien.affiliation) counts.b[alien.affiliation] = (counts.b[alien.affiliation] || 0) + 1;
                    if (alien.attack_area) counts.c[alien.attack_area] = (counts.c[alien.attack_area] || 0) + 1;
                    if (alien.attack_range) counts.d[alien.attack_range] = (counts.d[alien.attack_range] || 0) + 1;
                    for (let j = 1; j <= 4; j++) {
                        const typeVal = alien[`type_${j}`];
                        if (typeVal) counts.e[typeVal] = (counts.e[typeVal] || 0) + 1;
                    }
                    if (alien.role) counts.f[alien.role] = (counts.f[alien.role] || 0) + 1;
                });

                // スロット内のDOMインデックスを取得
                // ！！！ (★修正★) domIndexMapがnullの場合はslotIdxを使用 ！！！
                const domIdx = Array.isArray(domIndexMap) ? domIndexMap[slotIdx] : slotIdx;
                if (domIdx === undefined || domIdx === null || domIdx < 0) return;

                const slotElem = partyContainer.querySelector(`.party-slot[data-slot-index="${domIdx}"]`);
                if (!slotElem) return;

                // 2. スキルごとに判定
                [1, 2, 3].forEach(skillNum => {
                    const skillBlock = slotElem.querySelector(`.skill-block[data-skill-index="${skillNum}"]`);
                    if (!skillBlock) return;

                    // ！！！ (注) 正しい alienIdStr を使って ALIEN_SKILL_DATA を参照 ！！！
                    const requirements = ALIEN_SKILL_DATA[alienIdStr]?.[skillNum] || [];

                    if (requirements.length > 0) {
                        // ！！！ (★修正★) 両方のアイコンコンテナ（開いた時用・閉じた時用）を取得 ！！！
                        const iconContainers = skillBlock.querySelectorAll('.skill-req-icons');
                        if (!iconContainers || iconContainers.length === 0) return;

                        // 両方のコンテナに対して更新処理を実行
                        iconContainers.forEach(iconContainer => {
                            const iconElements = iconContainer.querySelectorAll('.req-icon');

                            requirements.forEach((req, reqIndex) => {
                                const isMet = checkCondition(req.type, req.value, req.count, req.is_not, counts, alliesTotalCount);

                                const iconEl = iconElements[reqIndex];
                                if (iconEl) {
                                    // ！！！ (★修正★) toggleではなく、remove/addで確実にクラスを更新 ！！！
                                    if (isMet) {
                                        iconEl.classList.remove('unmet');
                                        iconEl.classList.add('met');
                                    } else {
                                        iconEl.classList.remove('met');
                                        iconEl.classList.add('unmet');
                                    }
                                }
                            });
                        });
                    }
                });
            });
        }
        //
        // △△△ ここまでを置き換え △△△
        //
        /**
         * (新) 個別条件の判定ロジック (★「自分を除く」味方で判定する版★)
         * @param {object} counts - 「自分を除く」味方の集計
         * @param {number} alliesTotalCount - 「自分を除く」味方の総数
         */
        function checkCondition(type, value, count, is_not = false, counts, alliesTotalCount) {
            let currentCount = 0;

            // counts (自分を除く集計) から該当の数を取得
            switch (type) {
                case 'a': currentCount = counts.a[value] || 0; break;
                case 'b': currentCount = counts.b[value] || 0; break;
                case 'c': currentCount = counts.c[value] || 0; break;
                case 'd': currentCount = counts.d[value] || 0; break;
                case 'f': currentCount = counts.f[value] || 0; break;
                case 'e': currentCount = counts.e[value] || 0; break;
                default: currentCount = 0;
            }

            let conditionMet = false;

            if (is_not) {
                // ！！！ (新) 「以外」の判定 ！！！
                // 「自分を除く味方の総数」から「該当(自分を除く)」の数を引いたものが「以外(自分を除く)」の数
                currentCount = alliesTotalCount - currentCount;
                conditionMet = currentCount >= count;
            } else {
                // ！！！ (新) 「通常」の判定 ！！！
                conditionMet = currentCount >= count;
            }

            return conditionMet;
        }

        /**
         * (新) 要求アイコンのHTML生成 (★要求数1は非表示★)
         */
        function createRequirementIcon(type, value, count, isMet, is_not = false) {
            const iconName = `${type}${value}`; // value に '!' は含まれていない
            const iconUrl = `/static/icon/${iconName}.webp`;
            const metClass = isMet ? 'met' : 'unmet';

            // ！！！ (新) 「以外」の場合、style属性で上下反転 ！！！
            const notStyle = is_not ? 'style="transform: scaleY(-1);"' : '';

            // ！！！ (新) 要求数が1より大きい場合のみ、数字を表示 ！！！
            const countHtml = count > 1 ? `<span class="req-count">${count}</span>` : '';

            return `
            <div class="req-icon ${metClass}" ${notStyle} title="${type}:${value}${is_not ? '!' : ''} x${count}">
                <img src="${iconUrl}" alt="${iconName}">
                ${countHtml}
            </div>
        `;
        }
        // --- 絞り込み・並び替え関連ロジック ---

        /**
         * 絞り込みと並び替えを適用してエイリアン一覧を更新する
         */
        /**
         * 効果マッチングチェック関数（個性・特技共通）
         */
        function checkEffectMatch(effectSelections, selectedSkills, alienEffects, allowedSkills, tabType, searchMode) {
            if (effectSelections.size === 0) return true;

            // 選択された効果の詳細情報を取得
            const selectedEffectsInfo = Array.from(effectSelections).map(effectStr => {
                const parts = effectStr.split('|');
                const targetStr = parts[1] || '';
                const conditionStr = parts[2] || '';
                const normalizedEffectName = tabType === 'special' ? normalizeEffectName(parts[0]) : parts[0];
                return {
                    effect_name: normalizedEffectName,
                    targets: targetStr ? new Set(targetStr.split(',').map(t => t.trim()).filter(t => t)) : new Set(),
                    conditions: conditionStr ? new Set(conditionStr.split(',').map(c => c.trim()).filter(c => c)) : new Set()
                };
            });

            const filteredSelectedSkills = Array.from(selectedSkills).filter(skill => allowedSkills.includes(skill));
            if (filteredSelectedSkills.length === 0) return false;

            if (searchMode === 'and') {
                // AND検索: 全ての選択された効果条件に一致する必要がある
                return selectedEffectsInfo.every(selectedEffect => {
                    return Array.from(filteredSelectedSkills).some(skillNum => {
                        const skillEffects = alienEffects[skillNum] || [];
                        return skillEffects.some(effect => {
                            const normalizedEffectName = tabType === 'special' ? normalizeEffectName(effect.effect_name) : effect.effect_name;
                            if (normalizedEffectName !== selectedEffect.effect_name) return false;

                            if (selectedEffect.targets.size > 0) {
                                const showTarget = effect.show_target !== false;
                                const effectTargets = (showTarget && effect.target) ?
                                    new Set(effect.target.split(',').map(t => t.trim()).filter(t => t)) :
                                    new Set();
                                const hasMatch = Array.from(effectTargets).some(t => selectedEffect.targets.has(t));
                                if (!hasMatch) return false;
                            }

                            if (selectedEffect.conditions.size > 0) {
                                const showConditionTarget = effect.show_condition_target !== false;
                                const effectConditions = (showConditionTarget && effect.condition_target) ?
                                    new Set(effect.condition_target.split(',').map(c => c.trim()).filter(c => c)) :
                                    new Set();
                                const hasMatch = Array.from(effectConditions).some(c => selectedEffect.conditions.has(c));
                                if (!hasMatch) return false;
                            }

                            return true;
                        });
                    });
                });
            } else {
                // OR検索: いずれかの選択された効果条件に一致すればよい
                return Array.from(filteredSelectedSkills).some(skillNum => {
                    const skillEffects = alienEffects[skillNum] || [];
                    return selectedEffectsInfo.some(selectedEffect => {
                        return skillEffects.some(effect => {
                            const normalizedEffectName = tabType === 'special' ? normalizeEffectName(effect.effect_name) : effect.effect_name;
                            if (normalizedEffectName !== selectedEffect.effect_name) return false;

                            if (selectedEffect.targets.size > 0) {
                                const showTarget = effect.show_target !== false;
                                const effectTargets = (showTarget && effect.target) ?
                                    new Set(effect.target.split(',').map(t => t.trim()).filter(t => t)) :
                                    new Set();
                                const hasMatch = Array.from(effectTargets).some(t => selectedEffect.targets.has(t));
                                if (!hasMatch) return false;
                            }

                            if (selectedEffect.conditions.size > 0) {
                                const showConditionTarget = effect.show_condition_target !== false;
                                const effectConditions = (showConditionTarget && effect.condition_target) ?
                                    new Set(effect.condition_target.split(',').map(c => c.trim()).filter(c => c)) :
                                    new Set();
                                const hasMatch = Array.from(effectConditions).some(c => selectedEffect.conditions.has(c));
                                if (!hasMatch) return false;
                            }

                            return true;
                        });
                    });
                });
            }
        }

        function updateAlienGrid() {
            // ソートキーに対応する表示用の日本語名を定義
            const sortValueMappings = {
                affiliation: { '1': '宇宙連合', '2': '星間帝国', '3': '恒星連邦', '4': 'unknown', '5': '銀河同盟' },
                attack_range: { '1': 'ちかい', '2': 'ふつう', '3': 'とおい' },
                attack_area: { '1': 'たんたい', '2': 'はんい' },
                // 数値項目は直接数値を表示するためのマッピング（実際の値は後で設定）
                hp: null,
                power: null,
                motivation: null,
                size: null,
                speed: null
            };

            // いずれかのフィルターセクションで何も選択されていない場合、グリッドを空にする
            // （効果フィルターと検索セクションは除外：効果フィルターは選択されていない場合も表示する、検索は別途チェック）
            const sections = document.querySelectorAll('.filter-section:not(#filter-section-effects):not(#filter-section-search)');
            for (const section of sections) {
                if (section.querySelector('.filter-options').hasChildNodes() && section.querySelectorAll('.filter-button.selected:not(.all-button)').length === 0) {
                    alienGrid.innerHTML = '';
                    updateFilterUIState();
                    return;
                }
            }

            // フィルターを適用
            const filteredAliens = allAliensData.filter(alien => {
                const alienEffects = ALIEN_EFFECTS[String(alien.id)] || { '1': [], '2': [], '3': [], 'S': [] };

                // 個性タブと特技タブの両方の選択状態を確認（effectsチェックの前に確認）
                const personalityHasEffects = tabSelectionState.personality && tabSelectionState.personality.size > 0;
                const specialHasEffects = tabSelectionState.special && tabSelectionState.special.size > 0;

                // 名前検索フィルターをチェック（管理モード中は全文検索）
                let nameSearchMatch = true;
                if (nameSearchQuery && nameSearchQuery.trim()) {
                    const normalizedQuery = normalizeString(nameSearchQuery.trim());
                    const nameMatch = normalizeString(alien.name || '').includes(normalizedQuery);

                    // 管理モード中は全文検索（名前 + 個性・特技テキスト）
                    if (isAdminMode === true) {
                        const skillText1 = normalizeString(String(alien.skill_text1 || ''));
                        const skillText2 = normalizeString(String(alien.skill_text2 || ''));
                        const skillText3 = normalizeString(String(alien.skill_text3 || ''));
                        const sSkillText = normalizeString(String(alien.s_skill_text || ''));
                        nameSearchMatch = nameMatch ||
                            skillText1.includes(normalizedQuery) ||
                            skillText2.includes(normalizedQuery) ||
                            skillText3.includes(normalizedQuery) ||
                            sSkillText.includes(normalizedQuery);
                    } else {
                        // 非管理モードでは名前のみ検索
                        nameSearchMatch = nameMatch;
                    }
                }

                // 通常のフィルター（効果フィルター以外）をチェック
                const normalFiltersMatch = Object.entries(activeFilters).every(([key, valueSet]) => {
                    if (!valueSet || valueSet.size === 0) return true;
                    if (key === 'types') {
                        return alien.types.some(type => valueSet.has(type));
                    }
                    // effectsは別途チェック
                    if (key === 'effects') {
                        return true;
                    }
                    return valueSet.has(String(alien[key]));
                });

                // 名前検索も含めてチェック
                if (!nameSearchMatch) return false;

                // 効果フィルターをチェック（activeFilters['effects']が存在しない場合でも、タブの選択状態があればチェック）
                let effectFiltersMatch = true;
                if (personalityHasEffects || specialHasEffects) {
                    // 個性タブの選択状態をチェック
                    let personalityMatch = true;
                    if (personalityHasEffects) {
                        // 個性タブで効果が選択されている場合、個性1/2/3すべてをチェック
                        const personalitySelectedSkills = new Set(selectedPersonalitySkillSlots);
                        personalityMatch = checkEffectMatch(
                            tabSelectionState.personality,
                            personalitySelectedSkills,
                            alienEffects,
                            ['1', '2', '3'],
                            'personality',
                            effectFilterMode.personality.headerRow
                        );
                    }

                    // 特技タブの選択状態をチェック
                    let specialMatch = true;
                    if (specialHasEffects) {
                        const specialSelectedSkills = new Set(['S']); // 特技は常に'S'

                        // 「ダメージのみ」が選択されているかチェック
                        const damageOnlySelected = tabSelectionState.special.has('damage-only');
                        const damageOnlyMatch = damageOnlySelected ? (alienEffects['S'] || []).length === 0 : true;

                        // 特技タブの効果をチェック（damage-onlyは除外）
                        const specialEffects = new Set();
                        tabSelectionState.special.forEach(effectValue => {
                            if (effectValue !== 'damage-only') {
                                specialEffects.add(effectValue);
                            }
                        });

                        let otherEffectsMatch = true;
                        if (specialEffects.size > 0) {
                            otherEffectsMatch = checkEffectMatch(
                                specialEffects,
                                specialSelectedSkills,
                                alienEffects,
                                ['S'],
                                'special',
                                effectFilterMode.special.headerRow
                            );
                        }

                        // 「ダメージのみ」と他の効果をOR検索できるようにする
                        if (damageOnlySelected && specialEffects.size > 0) {
                            // 両方選択されている場合、OR検索の場合はどちらかが一致すればOK
                            if (effectFilterMode.special.headerRow === 'or') {
                                specialMatch = damageOnlyMatch || otherEffectsMatch;
                            } else {
                                // AND検索の場合は両方一致する必要がある（通常は起こりえないが）
                                specialMatch = damageOnlyMatch && otherEffectsMatch;
                            }
                        } else if (damageOnlySelected) {
                            // 「ダメージのみ」のみ選択されている場合
                            specialMatch = damageOnlyMatch;
                        } else {
                            // 他の効果のみ選択されている場合
                            specialMatch = otherEffectsMatch;
                        }
                    }

                    // 個性と特技の両方が絞り込み状態の時だけ、AND/ORを適用
                    if (personalityHasEffects && specialHasEffects) {
                        if (effectFilterMode.betweenTabs === 'and') {
                            // AND検索: 個性と特技の両方を満たす必要がある
                            effectFiltersMatch = personalityMatch && specialMatch;
                        } else {
                            // OR検索: 個性または特技のいずれかを満たせばよい
                            effectFiltersMatch = personalityMatch || specialMatch;
                        }
                    } else if (personalityHasEffects) {
                        // 個性タブのみ絞り込み状態
                        effectFiltersMatch = personalityMatch;
                    } else if (specialHasEffects) {
                        // 特技タブのみ絞り込み状態
                        effectFiltersMatch = specialMatch;
                    }
                }

                // 不整合フィルター（管理モード時のみ）
                if (isAdminMode && invalidDataFilterActive) {
                    const hasInvalidData = checkInvalidData(alien.id);
                    if (!hasInvalidData) {
                        return false; // 不整合がないエイリアンは除外
                    }
                }

                // すべてのフィルター条件を満たす必要がある（名前検索も含む）
                return normalFiltersMatch && effectFiltersMatch && nameSearchMatch;
            });

            // ソートを適用
            filteredAliens.sort((a, b) => {
                const key = currentSort.key;
                const order = currentSort.order === 'asc' ? 1 : -1;
                const valA = a[key] ?? -1;
                const valB = b[key] ?? -1;

                if (valA < valB) return -1 * order;
                if (valA > valB) return 1 * order;
                // ソートキーが同じ場合はIDで降順ソート
                if (a.id < b.id) return 1;
                if (a.id > b.id) return -1;
                return 0;
            });

            // グリッドを再描画
            alienGrid.innerHTML = '';
            filteredAliens.forEach(alien => {
                const sortKey = currentSort.key;
                const displayElement = alien.element.querySelector('.sort-value-display');

                // ソート中の値をカードに表示
                if (displayElement) {
                    // 数値項目（hp, power, motivation, size, speed）の場合は数値をそのまま表示
                    if (['hp', 'power', 'motivation', 'size', 'speed'].includes(sortKey)) {
                        const value = alien[sortKey];
                        displayElement.textContent = value || '';
                    }
                    // その他の項目はマッピングを使用
                    else if (sortValueMappings[sortKey]) {
                        const value = alien[sortKey];
                        displayElement.textContent = sortValueMappings[sortKey][value] || '';
                    } else {
                        displayElement.textContent = '';
                    }
                }

                // 管理モード時: 不整合データを持つエイリアンの名前を赤く表示
                if (isAdminMode) {
                    const nameElement = alien.element.querySelector('.alien-name');
                    if (nameElement) {
                        const hasInvalidData = checkInvalidData(alien.id);
                        if (hasInvalidData) {
                            nameElement.classList.add('invalid-data');
                        } else {
                            nameElement.classList.remove('invalid-data');
                        }
                    }
                } else {
                    // 通常モード時はクラスを削除
                    const nameElement = alien.element.querySelector('.alien-name');
                    if (nameElement) {
                        nameElement.classList.remove('invalid-data');
                    }
                }

                alienGrid.appendChild(alien.element);
            });

            updateFilterUIState();
        }
        /**
         * 絞り込み用のボタンを動的に生成する
         */
        function createFilterButtons() {
            const filters = {
                attribute: { containerId: 'filter-section-attribute', label: '属性', prefix: 'a', count: 4 },
                affiliation: { containerId: 'filter-section-affiliation', label: '所属', prefix: 'b', count: 5 },
                attack_area: { containerId: 'filter-section-attack_area', label: '攻撃はんい', prefix: 'c', count: 2 },
                attack_range: { containerId: 'filter-section-attack_range', label: '攻撃きょり', prefix: 'd', count: 3 },
                role: { containerId: 'filter-section-role', label: 'ロール', prefix: 'f', count: 4 },
                types: { containerId: 'filter-section-types', label: 'タイプ', prefix: 'e', values: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'AA', 'AB', 'AC', 'AD', 'AH', 'AI', 'AJ', 'AK', 'AL', 'AM', 'AN', 'AO', 'AP', 'AQ', 'AR', 'AS', 'AT', 'AU', 'AV', 'AW'] }
            };

            for (const [key, config] of Object.entries(filters)) {
                const section = document.getElementById(config.containerId);

                // ラベルと「すべて」ボタン
                const labelDiv = document.createElement('div');
                labelDiv.className = 'filter-label';
                labelDiv.innerHTML = `<span>${config.label}</span>`;
                const allBtn = document.createElement('button');
                allBtn.className = 'filter-button all-button selected';
                allBtn.textContent = 'すべて';
                labelDiv.appendChild(allBtn);
                section.appendChild(labelDiv);

                // フィルターオプションボタン
                const optionsDiv = document.createElement('div');
                optionsDiv.className = 'filter-options';
                section.appendChild(optionsDiv);

                const optionButtons = [];
                const values = config.values || Array.from({ length: config.count }, (_, i) => i + 1);
                values.forEach(val => {
                    const btn = document.createElement('button');
                    btn.className = 'filter-button selected';
                    btn.dataset.key = key;
                    btn.dataset.value = val;
                    btn.innerHTML = `<img src="/static/icon/${config.prefix}${val}.webp">`;
                    optionsDiv.appendChild(btn);
                    optionButtons.push(btn);
                });

                // イベントリスナーを設定
                optionButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        btn.classList.toggle('selected');
                        applyFilters();
                    });
                });
                allBtn.addEventListener('click', () => {
                    const isAllSelected = optionButtons.every(b => b.classList.contains('selected'));
                    optionButtons.forEach(b => b.classList.toggle('selected', !isAllSelected));
                    applyFilters();
                });
            }

            // 効果名フィルターボタンを生成（階層構造）
            const effectsSection = document.getElementById('filter-section-effects');
            if (effectsSection) {
                // タブ行: 個性/特技の切り替え + and/or切り替え + 全体リセットボタン
                const tabRow = document.createElement('div');
                tabRow.className = 'effect-tab-row';
                tabRow.style.display = 'flex';
                tabRow.style.alignItems = 'center';
                tabRow.style.justifyContent = 'space-between';
                tabRow.style.gap = '0.6rem';
                tabRow.style.marginBottom = '0';
                tabRow.style.marginTop = '0';
                tabRow.style.padding = '0.6rem';
                tabRow.style.backgroundColor = '#2a3a4a'; // タブ行全体の背景色
                tabRow.style.borderRadius = '0.474vh';

                const tabButtonsContainer = document.createElement('div');
                tabButtonsContainer.style.display = 'flex';
                tabButtonsContainer.style.alignItems = 'center';
                tabButtonsContainer.style.gap = '0.6rem';

                const personalityTab = document.createElement('button');
                personalityTab.className = 'filter-button effect-tab-button selected';
                personalityTab.textContent = '個性';
                personalityTab.dataset.tab = 'personality';
                personalityTab.style.fontSize = '1.4vh';
                personalityTab.style.fontWeight = 'bold';
                personalityTab.style.padding = '0.5vh 1.2vh';

                const specialTab = document.createElement('button');
                specialTab.className = 'filter-button effect-tab-button';
                specialTab.textContent = '特技';
                specialTab.dataset.tab = 'special';
                specialTab.style.fontSize = '1.4vh';
                specialTab.style.fontWeight = 'bold';
                specialTab.style.padding = '0.5vh 1.2vh';

                // 未登録効果タブ（管理モード時のみ表示）
                const unregisteredTab = document.createElement('button');
                unregisteredTab.className = 'filter-button effect-tab-button';
                unregisteredTab.textContent = '未登録';
                unregisteredTab.id = 'unregistered-effects-tab';
                unregisteredTab.dataset.tab = 'unregistered';
                unregisteredTab.style.fontSize = '1.4vh';
                unregisteredTab.style.fontWeight = 'bold';
                unregisteredTab.style.padding = '0.5vh 1.2vh';
                unregisteredTab.style.display = isAdminMode ? '' : 'none';

                // 個性タブと特技タブの間のAND/ORボタン（両方のタブが絞り込み状態の時だけ有効）
                const betweenTabsModeToggleBtn = document.createElement('button');
                betweenTabsModeToggleBtn.className = 'filter-button all-button';
                betweenTabsModeToggleBtn.textContent = effectFilterMode.betweenTabs.toUpperCase();
                betweenTabsModeToggleBtn.style.fontSize = '1.2vh';
                betweenTabsModeToggleBtn.style.padding = '0.4vh 1vh';
                betweenTabsModeToggleBtn.style.minWidth = '4.5vh'; // 固定幅（ANDに合わせる）
                betweenTabsModeToggleBtn.style.textAlign = 'center';
                betweenTabsModeToggleBtn.dataset.buttonType = 'betweenTabs';
                betweenTabsModeToggleBtn.style.opacity = '0.5'; // 初期状態は無効
                betweenTabsModeToggleBtn.style.cursor = 'default';
                betweenTabsModeToggleBtn.addEventListener('click', () => {
                    // 個性と特技の両方が絞り込み状態の時だけ切り替え可能
                    const personalityHasSelection = tabSelectionState.personality && tabSelectionState.personality.size > 0;
                    const specialHasSelection = tabSelectionState.special && tabSelectionState.special.size > 0;
                    if (personalityHasSelection && specialHasSelection) {
                        effectFilterMode.betweenTabs = effectFilterMode.betweenTabs === 'and' ? 'or' : 'and';
                        betweenTabsModeToggleBtn.textContent = effectFilterMode.betweenTabs.toUpperCase();
                        applyFilters();
                    }
                });

                tabButtonsContainer.appendChild(personalityTab);
                tabButtonsContainer.appendChild(betweenTabsModeToggleBtn);
                tabButtonsContainer.appendChild(specialTab);
                tabButtonsContainer.appendChild(unregisteredTab);
                tabRow.appendChild(tabButtonsContainer);

                effectsSection.appendChild(tabRow);

                // ヘッダー行: 対象 + 個性1/2/3/特技 + and/or切り替え + リセット（文字を少し大きく）
                const headerRow = document.createElement('div');
                headerRow.className = 'effect-skill-header';
                headerRow.style.display = 'flex';
                headerRow.style.alignItems = 'center';
                headerRow.style.gap = '0.6rem';
                headerRow.style.marginBottom = '0';

                const skillButtons = [];

                // 個性タブ時のみ対象ラベルと個性1/2/3ボタンを表示
                const targetLabel = document.createElement('div');
                targetLabel.textContent = '対象';
                targetLabel.style.fontSize = '1.2vh';
                targetLabel.style.fontWeight = 'bold';
                targetLabel.style.display = currentEffectTab === 'personality' ? '' : 'none';
                headerRow.appendChild(targetLabel);

                // 個性タブ時のみ個性1/2/3ボタンを表示
                for (let i = 1; i <= 3; i++) {
                    const skillBtn = document.createElement('button');
                    skillBtn.className = 'filter-button effect-skill-button selected';
                    skillBtn.textContent = `個性${i}`;
                    skillBtn.dataset.key = 'effect-skill';
                    skillBtn.dataset.value = String(i);
                    skillBtn.style.fontSize = '1.2vh';
                    skillBtn.style.display = currentEffectTab === 'personality' ? '' : 'none';
                    headerRow.appendChild(skillBtn);
                    skillButtons.push(skillBtn);
                }

                // 特技タブ時のみ特技ボタンを表示（削除予定だが、skillButtonsに含めるために一時的に保持）
                const specialSkillBtn = document.createElement('button');
                specialSkillBtn.className = 'filter-button effect-skill-button selected';
                specialSkillBtn.textContent = '特技';
                specialSkillBtn.dataset.key = 'effect-skill';
                specialSkillBtn.dataset.value = 'S';
                specialSkillBtn.style.fontSize = '1.35vh';
                specialSkillBtn.style.display = 'none'; // 特技タブでも非表示
                headerRow.appendChild(specialSkillBtn);
                skillButtons.push(specialSkillBtn);

                // 特技タブ時に「ダメージのみ」ボタンを表示
                const damageOnlyBtn = document.createElement('button');
                damageOnlyBtn.className = 'filter-button effect-skill-button';
                damageOnlyBtn.textContent = 'ダメージのみ';
                damageOnlyBtn.dataset.key = 'damage-only';
                damageOnlyBtn.style.fontSize = '1.2vh';
                damageOnlyBtn.style.display = currentEffectTab === 'special' ? '' : 'none';
                damageOnlyBtn.addEventListener('click', () => {
                    damageOnlyBtn.classList.toggle('selected');
                    // 選択状態を保存
                    if (currentEffectTab === 'special') {
                        saveCurrentTabSelection();
                    }
                    updateEffectTabButtons();
                    applyFilters();
                });
                headerRow.appendChild(damageOnlyBtn);

                // and/or切り替えボタン（リセットの左側、右端に配置）- ヘッダー行専用、独立動作
                const headerModeToggleBtn = document.createElement('button');
                headerModeToggleBtn.className = 'filter-button all-button';
                headerModeToggleBtn.textContent = effectFilterMode[currentEffectTab].headerRow.toUpperCase();
                headerModeToggleBtn.style.fontSize = '1.2vh';
                headerModeToggleBtn.style.padding = '0.4vh 1vh';
                headerModeToggleBtn.dataset.modeFor = currentEffectTab;
                headerModeToggleBtn.dataset.buttonType = 'headerRow';
                headerModeToggleBtn.addEventListener('click', () => {
                    effectFilterMode[currentEffectTab].headerRow = effectFilterMode[currentEffectTab].headerRow === 'and' ? 'or' : 'and';
                    headerModeToggleBtn.textContent = effectFilterMode[currentEffectTab].headerRow.toUpperCase();
                    // タブ行のANDボタンとは連動しない（完全独立動作）
                    applyFilters();
                });

                // 全体リセットボタン（tabRow用）
                const globalResetBtn = document.createElement('button');
                globalResetBtn.className = 'filter-button all-button';
                globalResetBtn.textContent = '全体リセット';
                globalResetBtn.style.fontSize = '1.2vh';
                globalResetBtn.style.padding = '0.4vh 1vh';
                globalResetBtn.addEventListener('click', () => {
                    // 全ての効果ボタンの選択を解除
                    document.querySelectorAll('.effect-button.selected').forEach(b => b.classList.remove('selected'));
                    // 全ての個性/特技ボタンを選択状態に戻す
                    skillButtons.forEach(b => {
                        if (currentEffectTab === 'personality' && ['1', '2', '3'].includes(b.dataset.value)) {
                            b.classList.add('selected');
                        } else if (currentEffectTab === 'special' && b.dataset.value === 'S') {
                            b.classList.add('selected');
                        }
                    });
                    selectedPersonalitySkillSlots.clear();
                    ['1', '2', '3'].forEach(v => selectedPersonalitySkillSlots.add(v));
                    // ダメージのみボタンもリセット
                    damageOnlyBtn.classList.remove('selected');
                    // 選択状態をクリア
                    tabSelectionState.personality.clear();
                    tabSelectionState.special.clear();
                    // タブボタンのfiltered状態を更新
                    updateEffectTabButtons();
                    applyFilters();
                });

                const resetBtn = document.createElement('button');
                resetBtn.className = 'filter-button all-button';
                resetBtn.textContent = 'リセット';
                resetBtn.dataset.key = 'effect-reset';
                resetBtn.style.fontSize = '1.2vh';
                resetBtn.style.padding = '0.4v 1vh';

                // 右端に配置するためのコンテナ
                const rightButtonsContainer = document.createElement('div');
                rightButtonsContainer.style.display = 'flex';
                rightButtonsContainer.style.alignItems = 'center';
                rightButtonsContainer.style.gap = '0.6rem';
                rightButtonsContainer.style.marginLeft = 'auto'; // 右端に配置

                rightButtonsContainer.appendChild(headerModeToggleBtn);
                rightButtonsContainer.appendChild(resetBtn);

                // 右端コンテナをヘッダー行に追加
                headerRow.appendChild(rightButtonsContainer);

                effectsSection.appendChild(headerRow);

                // 全体リセットボタンをtabRowの右端に追加（既存のtabRow構造を利用）
                tabRow.appendChild(globalResetBtn);

                // タブ切り替え時の選択状態保存・復元関数
                function saveCurrentTabSelection() {
                    const selectedValues = new Set();
                    document.querySelectorAll('.effect-button.selected').forEach(btn => {
                        selectedValues.add(btn.dataset.value);
                    });
                    // 「ダメージのみ」ボタンの状態も保存
                    if (currentEffectTab === 'special') {
                        const damageOnlyBtn = document.querySelector('[data-key="damage-only"]');
                        if (damageOnlyBtn && damageOnlyBtn.classList.contains('selected')) {
                            selectedValues.add('damage-only');
                        }
                    }
                    tabSelectionState[currentEffectTab] = selectedValues;
                }

                function restoreTabSelection(tabType) {
                    const savedSelection = tabSelectionState[tabType] || new Set();
                    document.querySelectorAll('.effect-button').forEach(btn => {
                        if (savedSelection.has(btn.dataset.value)) {
                            btn.classList.add('selected');
                        } else {
                            btn.classList.remove('selected');
                        }
                    });
                    // 「ダメージのみ」ボタンの状態も復元
                    if (tabType === 'special') {
                        const damageOnlyBtn = document.querySelector('[data-key="damage-only"]');
                        if (damageOnlyBtn) {
                            if (savedSelection.has('damage-only')) {
                                damageOnlyBtn.classList.add('selected');
                            } else {
                                damageOnlyBtn.classList.remove('selected');
                            }
                        }
                    }
                }

                // タブボタンのfiltered状態を更新する関数（グローバルスコープに移動）

                // タブ切り替えイベント
                personalityTab.addEventListener('click', () => {
                    if (currentEffectTab === 'personality') return;
                    // 現在のタブの選択状態を保存
                    saveCurrentTabSelection();
                    currentEffectTab = 'personality';
                    personalityTab.classList.add('selected');
                    specialTab.classList.remove('selected');
                    unregisteredTab.classList.remove('selected');
                    // 個性1/2/3ボタンを表示、特技ボタンを非表示
                    targetLabel.style.display = '';
                    for (let i = 0; i < 3; i++) {
                        skillButtons[i].style.display = '';
                    }
                    specialSkillBtn.style.display = 'none';
                    // ダメージのみボタンを非表示
                    damageOnlyBtn.style.display = 'none';
                    // ヘッダー行のANDボタンの表示を更新
                    headerModeToggleBtn.textContent = effectFilterMode[currentEffectTab].headerRow.toUpperCase();
                    headerModeToggleBtn.dataset.modeFor = currentEffectTab;
                    // 効果リストを再生成
                    if (ALL_EFFECTS && ALL_EFFECTS.length > 0) {
                        allEffectButtons = renderEffectButtons(optionsDiv, ALL_EFFECTS, 'personality');
                        setupEffectButtonListeners(allEffectButtons);
                        // 保存された選択状態を復元
                        restoreTabSelection('personality');
                        // サブカテゴリの折りたたみ機能を設定
                        setTimeout(setupSubCategoryCollapse, 0);
                    }
                    updateEffectTabButtons();
                    applyFilters();
                });

                specialTab.addEventListener('click', () => {
                    if (currentEffectTab === 'special') return;
                    // 現在のタブの選択状態を保存
                    saveCurrentTabSelection();
                    currentEffectTab = 'special';
                    specialTab.classList.add('selected');
                    personalityTab.classList.remove('selected');
                    unregisteredTab.classList.remove('selected');
                    // 個性1/2/3ボタンを非表示、特技ボタンは表示しない
                    targetLabel.style.display = 'none';
                    for (let i = 0; i < 3; i++) {
                        skillButtons[i].style.display = 'none';
                    }
                    specialSkillBtn.style.display = 'none';
                    // ダメージのみボタンを表示
                    damageOnlyBtn.style.display = '';
                    // ヘッダー行のANDボタンの表示を更新
                    headerModeToggleBtn.textContent = effectFilterMode[currentEffectTab].headerRow.toUpperCase();
                    headerModeToggleBtn.dataset.modeFor = currentEffectTab;
                    // 効果リストを再生成
                    if (S_SKILL_EFFECTS && S_SKILL_EFFECTS.length > 0) {
                        allEffectButtons = renderEffectButtons(optionsDiv, S_SKILL_EFFECTS, 'special');
                        setupEffectButtonListeners(allEffectButtons);
                        // 保存された選択状態を復元
                        restoreTabSelection('special');
                        // サブカテゴリの折りたたみ機能を設定（特技にはサブカテゴリがないが念のため）
                        setTimeout(setupSubCategoryCollapse, 0);
                    }
                    updateEffectTabButtons();
                    applyFilters();
                });

                // 未登録効果タブ（管理モード時のみ）→ 不整合エイリアン絞り込みボタンに変更
                unregisteredTab.textContent = '不整合'; // 初期テキストを「不整合」に変更
                unregisteredTab.addEventListener('click', () => {
                    if (!isAdminMode) return;

                    // タブの選択状態を切り替え
                    invalidDataFilterActive = !invalidDataFilterActive;

                    if (invalidDataFilterActive) {
                        unregisteredTab.classList.add('selected');
                        unregisteredTab.textContent = '不整合';
                        // 他のタブは解除しない（複合フィルターとして機能）
                    } else {
                        unregisteredTab.classList.remove('selected');
                        unregisteredTab.textContent = '不整合';
                    }

                    // フィルターを適用
                    applyFilters();
                });
                // フィルターオプション（階層構造）
                const optionsDiv = document.createElement('div');
                optionsDiv.className = 'filter-options effect-options';
                effectsSection.appendChild(optionsDiv);
                // 効果ボタン生成関数（個性/特技で共通）
                function renderEffectButtons(container, effects, tabType) {
                    // 既存のボタンをクリア
                    container.innerHTML = '';

                    if (!effects || effects.length === 0) return [];

                    // 効果を effect_type と category の組み合わせで分類
                    const effectsByTypeAndCategory = {};

                    effects.forEach(effect => {
                        const effectType = effect.effect_type || '';
                        const category = effect.category || '';
                        const key = `${effectType}_${category}`;

                        if (!effectsByTypeAndCategory[key]) {
                            effectsByTypeAndCategory[key] = [];
                        }
                        effectsByTypeAndCategory[key].push(effect);
                    });

                    // カテゴリ構造を定義（タブタイプによって異なる）
                    let categoryStructure;
                    if (tabType === 'special') {
                        // 特技用の分類構造（攻撃系を廃止、3カテゴリに統一）
                        categoryStructure = {
                            '回復系': [],
                            'バフ系': [],
                            'デバフ(状態異常)系': []
                        };

                        // 特技専用カテゴリ（S_SKILL_*）で分類
                        Object.keys(effectsByTypeAndCategory).forEach(key => {
                            const [effectType, ...categoryParts] = key.split('_');
                            const category = categoryParts.join('_');

                            // 効果名を取得（プロンプトの分類に合わせるため）
                            const effectNames = (effectsByTypeAndCategory[key] || []).map(e =>
                                e.correct_effect_names || e.effect_name || ''
                            );

                            // プロンプトの分類に基づいて分類（効果名ごとに一意の分類を決定）
                            // JSON辞書の定義に基づく分類マップ（effect_name -> category）
                            const effectCategoryMap = {
                                // 回復系
                                'たいりょく回復': '回復系',
                                'たいりょく吸収': '回復系',
                                '呪縛解除': '回復系',
                                '毒解除': '回復系',
                                '気絶解除': '回復系',
                                '足止め解除': '回復系',
                                // バフ系
                                'つよさアップ': 'バフ系',
                                'ひきよせ': 'バフ系',
                                'やるきアップ': 'バフ系',
                                'クリティカルダメージアップ': 'バフ系',
                                'クリティカル率アップ': 'バフ系',
                                'ダメージ反射': 'バフ系',
                                '与ダメージアップ': 'バフ系',
                                '凶暴化': 'バフ系',
                                '回避率アップ': 'バフ系',
                                '奮迅': 'バフ系',
                                '攻撃力アップ': 'バフ系',
                                '攻撃回数アップ': 'バフ系',
                                '無双': 'バフ系',
                                '特技与ダメージアップ': 'バフ系',
                                'いどうアップ': 'バフ系',
                                '被ダメージ軽減': 'バフ系',
                                // デバフ(状態異常)系
                                'たいりょく回復量ダウン': 'デバフ(状態異常)系',
                                'つよさダウン': 'デバフ(状態異常)系',
                                'やるきダウン': 'デバフ(状態異常)系',
                                '攻撃力ダウン': 'デバフ(状態異常)系',
                                'いどうダウン': 'デバフ(状態異常)系',
                                '急速ダメージ': 'デバフ(状態異常)系',
                                '与ダメージダウン': 'デバフ(状態異常)系',
                                '被ダメージアップ': 'デバフ(状態異常)系',
                                '被ダメージ軽減無効': 'デバフ(状態異常)系',
                                'のけぞり付与': 'デバフ(状態異常)系',
                                '吹き飛ばし': 'デバフ(状態異常)系',
                                '呪縛': 'デバフ(状態異常)系',
                                '小人化': 'デバフ(状態異常)系',
                                '攻撃不可': 'デバフ(状態異常)系',
                                '毒付与': 'デバフ(状態異常)系',
                                '気絶付与': 'デバフ(状態異常)系',
                                '足止め': 'デバフ(状態異常)系'
                            };

                            // 効果名ベースで分類を判定（プロンプトとJSON辞書の定義に基づく）
                            let classified = false;
                            for (const effectName of effectNames) {
                                const category = effectCategoryMap[effectName];
                                if (category) {
                                    categoryStructure[category].push(key);
                                    classified = true;
                                    break; // 最初にマッチした効果名で分類を決定
                                }
                            }

                            // フォールバック：カテゴリベースで分類
                            if (!classified) {
                                if (category === 'S_SKILL_HEAL') {
                                    categoryStructure['回復系'].push(key);
                                } else if (category === 'S_SKILL_BUFF') {
                                    categoryStructure['バフ系'].push(key);
                                } else if (category === 'S_SKILL_DEBUFF') {
                                    categoryStructure['デバフ(状態異常)系'].push(key);
                                } else {
                                    // カテゴリが未設定または個性用カテゴリの場合（フォールバック）
                                    // effect_typeで判定（後方互換性のため）
                                    if (effectType === 'STATUS') {
                                        categoryStructure['デバフ(状態異常)系'].push(key);
                                    } else if (effectType === 'BUFF') {
                                        if (category === 'BUFF_OTHER' && effectsByTypeAndCategory[key].some(e => {
                                            const name = e.correct_effect_names || e.effect_name || '';
                                            return name.includes('回復') || name.includes('HP回復') || name.includes('HP吸収') || name.includes('解除');
                                        })) {
                                            categoryStructure['回復系'].push(key);
                                        } else {
                                            categoryStructure['バフ系'].push(key);
                                        }
                                    } else if (effectType === 'DEBUFF') {
                                        categoryStructure['デバフ(状態異常)系'].push(key);
                                    }
                                    // ATTACK系は削除したので、それ以外は分類しない
                                }
                            }
                        });
                    } else {
                        // 個性用の分類構造（既存）
                        categoryStructure = {
                            'バフ': {
                                'アップ系': [],
                                '軽減系': [],
                                '抵抗系': [],
                                'その他バフ': []
                            },
                            'デバフ': {
                                'ダウン系': [],
                                'その他デバフ': []
                            },
                            '状態異常': {
                                '毒系': [],
                                '気絶系': [],
                                'その他状態異常': []
                            }
                        };

                        // effect_type と category の組み合わせで分類（個性用）
                        Object.keys(effectsByTypeAndCategory).forEach(key => {
                            const [effectType, ...categoryParts] = key.split('_');
                            const category = categoryParts.join('_');
                            if (effectType === 'BUFF') {
                                if (category === 'BUFF_BOOST') {
                                    categoryStructure['バフ']['アップ系'].push(key);
                                } else if (category === 'BUFF_REDUCE') {
                                    categoryStructure['バフ']['軽減系'].push(key);
                                } else if (category === 'BUFF_RESIST') {
                                    categoryStructure['バフ']['抵抗系'].push(key);
                                } else {
                                    categoryStructure['バフ']['その他バフ'].push(key);
                                }
                            } else if (effectType === 'DEBUFF') {
                                if (category === 'DEBUFF_DOWN' || category === 'DEBUFF_REDUCE') {
                                    categoryStructure['デバフ']['ダウン系'].push(key);
                                } else {
                                    categoryStructure['デバフ']['その他デバフ'].push(key);
                                }
                            } else if (effectType === 'STATUS') {
                                if (category === 'STATUS_POISON') {
                                    categoryStructure['状態異常']['毒系'].push(key);
                                } else if (category === 'STATUS_STUN') {
                                    categoryStructure['状態異常']['気絶系'].push(key);
                                } else {
                                    categoryStructure['状態異常']['その他状態異常'].push(key);
                                }
                            }
                        });
                    }

                    const allEffectButtons = [];

                    // 階層構造に従って表示
                    if (tabType === 'special') {
                        // 特技用：1階層構造で表示
                        Object.keys(categoryStructure).forEach(mainCategory => {
                            const categoryKeys = categoryStructure[mainCategory];
                            if (categoryKeys.length === 0) return; // 効果が存在しないカテゴリはスキップ

                            const mainCategoryDiv = document.createElement('div');
                            mainCategoryDiv.className = 'effect-main-category';
                            mainCategoryDiv.style.marginBottom = '1rem';
                            mainCategoryDiv.style.width = '100%';

                            const mainCategoryTitle = document.createElement('div');
                            mainCategoryTitle.className = 'effect-main-category-title';
                            mainCategoryTitle.textContent = mainCategory;
                            mainCategoryDiv.appendChild(mainCategoryTitle);

                            const mainContentWrapper = document.createElement('div');
                            mainContentWrapper.className = 'effect-main-category-content';
                            mainCategoryDiv.appendChild(mainContentWrapper);

                            const effectButtonsContainer = document.createElement('div');
                            effectButtonsContainer.className = 'effect-buttons-container';
                            effectButtonsContainer.style.display = 'flex';
                            effectButtonsContainer.style.flexWrap = 'wrap';
                            effectButtonsContainer.style.gap = '0.25rem';

                            categoryKeys.forEach(categoryKey => {
                                const effects = effectsByTypeAndCategory[categoryKey] || [];
                                effects.forEach(effect => {
                                    let effectName = '';
                                    if (effect && typeof effect === 'object' && effect !== null) {
                                        effectName = effect.correct_effect_names || effect.effect_name || '';
                                    } else if (typeof effect === 'string') {
                                        effectName = effect;
                                    }

                                    if (!effectName) {
                                        console.warn('効果名が取得できませんでした:', effect);
                                        return;
                                    }

                                    // プロンプトの表記に統一（特技タブの場合）
                                    const normalizedEffectName = tabType === 'special' ? normalizeEffectName(effectName) : effectName;

                                    const btn = document.createElement('button');
                                    btn.className = 'filter-button effect-button';
                                    btn.dataset.key = 'effects';
                                    btn.dataset.value = normalizedEffectName;  // 検索時は正規化された効果名を使用
                                    // 管理モード時は使用数を表示
                                    let displayText = normalizedEffectName;
                                    if (isAdminMode && effectUsageStats[effectName]) {
                                        displayText = `${normalizedEffectName} (${effectUsageStats[effectName]})`;
                                    }
                                    btn.textContent = displayText;

                                    const effectType = effect && typeof effect === 'object' ? (effect.effect_type || '') : '';
                                    btn.title = effectType ? `${normalizedEffectName} (${effectType})` : normalizedEffectName;

                                    if (effect && typeof effect === 'object') {
                                        btn.dataset.effectType = effect.effect_type || '';
                                        btn.dataset.category = effect.category || '';
                                    }

                                    effectButtonsContainer.appendChild(btn);
                                    allEffectButtons.push(btn);
                                });
                            });

                            mainContentWrapper.appendChild(effectButtonsContainer);

                            mainCategoryTitle.classList.remove('collapsed');
                            mainCategoryTitle.addEventListener('click', () => {
                                const isCollapsed = mainContentWrapper.classList.contains('collapsed');
                                if (isCollapsed) {
                                    mainContentWrapper.classList.remove('collapsed');
                                    mainCategoryTitle.classList.remove('collapsed');
                                } else {
                                    mainContentWrapper.classList.add('collapsed');
                                    mainCategoryTitle.classList.add('collapsed');
                                }
                            });

                            container.appendChild(mainCategoryDiv);
                        });
                    } else {
                        // 個性用：2階層構造で表示（既存ロジック）
                        Object.keys(categoryStructure).forEach(mainCategory => {
                            const mainCategoryDiv = document.createElement('div');
                            mainCategoryDiv.className = 'effect-main-category';
                            mainCategoryDiv.style.marginBottom = '1rem';
                            mainCategoryDiv.style.width = '100%';

                            const mainCategoryTitle = document.createElement('div');
                            mainCategoryTitle.className = 'effect-main-category-title';
                            mainCategoryTitle.textContent = mainCategory;
                            mainCategoryDiv.appendChild(mainCategoryTitle);

                            const mainContentWrapper = document.createElement('div');
                            mainContentWrapper.className = 'effect-main-category-content';
                            mainCategoryDiv.appendChild(mainContentWrapper);

                            Object.keys(categoryStructure[mainCategory]).forEach(subCategory => {
                                const categoryKeys = categoryStructure[mainCategory][subCategory];
                                if (categoryKeys.length === 0) return;

                                const subCategoryDiv = document.createElement('div');
                                subCategoryDiv.className = 'effect-sub-category';
                                // effect-main-category-titleと同じ幅（padding + margin）に合わせる
                                subCategoryDiv.style.marginLeft = '0';
                                subCategoryDiv.style.marginBottom = '0.5rem';

                                const subCategoryTitle = document.createElement('div');
                                subCategoryTitle.className = 'effect-sub-category-title';
                                subCategoryTitle.textContent = subCategory;
                                subCategoryDiv.appendChild(subCategoryTitle);

                                const subCategoryContainer = document.createElement('div');
                                subCategoryContainer.className = 'effect-sub-category-container';

                                const effectButtonsContainer = document.createElement('div');
                                effectButtonsContainer.className = 'effect-buttons-container';
                                effectButtonsContainer.style.display = 'flex';
                                effectButtonsContainer.style.flexWrap = 'wrap';
                                effectButtonsContainer.style.gap = '0.25rem';

                                categoryKeys.forEach(categoryKey => {
                                    const effects = effectsByTypeAndCategory[categoryKey] || [];
                                    effects.forEach(effect => {
                                        let effectName = '';
                                        if (effect && typeof effect === 'object' && effect !== null) {
                                            let rawEffectName = effect.correct_effect_names || effect.effect_name || '';
                                            if (typeof rawEffectName === 'string' && rawEffectName.startsWith('(')) {
                                                const match = rawEffectName.match(/^\(([^,]+),/);
                                                if (match && match[1]) {
                                                    effectName = match[1];
                                                } else {
                                                    effectName = rawEffectName;
                                                }
                                            } else {
                                                effectName = rawEffectName;
                                            }
                                        } else if (typeof effect === 'string') {
                                            effectName = effect;
                                        }

                                        if (!effectName) {
                                            console.warn('効果名が取得できませんでした:', effect);
                                            return;
                                        }

                                        // プロンプトの表記に統一（個性タブの場合も必要に応じて）
                                        const normalizedEffectName = normalizeEffectName(effectName);

                                        const btn = document.createElement('button');
                                        btn.className = 'filter-button effect-button';
                                        btn.dataset.key = 'effects';
                                        btn.dataset.value = normalizedEffectName;  // 検索時は正規化された効果名を使用
                                        // 管理モード時は使用数を表示
                                        let displayText = normalizedEffectName;
                                        if (isAdminMode && effectUsageStats[effectName]) {
                                            displayText = `${normalizedEffectName} (${effectUsageStats[effectName]})`;
                                        }
                                        btn.textContent = displayText;

                                        const effectType = effect && typeof effect === 'object' ? (effect.effect_type || '') : '';
                                        btn.title = effectType ? `${effectName} (${effectType})` : effectName;

                                        if (effect && typeof effect === 'object') {
                                            btn.dataset.effectType = effect.effect_type || '';
                                            btn.dataset.category = effect.category || '';
                                        }

                                        effectButtonsContainer.appendChild(btn);
                                        allEffectButtons.push(btn);
                                    });
                                });

                                subCategoryContainer.appendChild(effectButtonsContainer);
                                subCategoryDiv.appendChild(subCategoryContainer);
                                mainContentWrapper.appendChild(subCategoryDiv);
                            });

                            mainCategoryTitle.classList.remove('collapsed');
                            mainCategoryTitle.addEventListener('click', () => {
                                const isCollapsed = mainContentWrapper.classList.contains('collapsed');
                                if (isCollapsed) {
                                    mainContentWrapper.classList.remove('collapsed');
                                    mainCategoryTitle.classList.remove('collapsed');
                                } else {
                                    mainContentWrapper.classList.add('collapsed');
                                    mainCategoryTitle.classList.add('collapsed');
                                }
                            });

                            container.appendChild(mainCategoryDiv);
                        });
                    }

                    return allEffectButtons;
                }

                // 初期状態で個性用の効果ボタンを生成
                let allEffectButtons = [];
                if (ALL_EFFECTS && ALL_EFFECTS.length > 0) {
                    allEffectButtons = renderEffectButtons(optionsDiv, ALL_EFFECTS, 'personality');
                    // サブカテゴリの折りたたみ機能を設定
                    setTimeout(setupSubCategoryCollapse, 0);
                }
                // イベントリスナーを設定
                let currentExpandedButton = null; // 現在展開中のボタン
                // 効果ボタンのイベントリスナー設定用関数
                function setupEffectButtonListeners(buttons) {
                    buttons.forEach(btn => {
                        let detailExpander = null;

                        btn.addEventListener('click', (e) => {
                            if (detailExpander && detailExpander.contains(e.target)) {
                                return;
                            }

                            if (currentExpandedButton && currentExpandedButton !== btn) {
                                closeDetailExpander(currentExpandedButton);
                                currentExpandedButton = null;
                            }

                            btn.classList.toggle('selected');

                            if (btn.classList.contains('selected')) {
                                openDetailExpander(btn);
                                currentExpandedButton = btn;
                            } else {
                                closeDetailExpander(btn);
                                if (currentExpandedButton === btn) {
                                    currentExpandedButton = null;
                                }
                            }

                            // 選択状態を保存
                            saveCurrentTabSelection();
                            updateEffectTabButtons();
                            applyFilters();
                        });

                        function openDetailExpander(button) {
                            if (detailExpander) {
                                detailExpander.remove();
                                detailExpander = null;
                            }

                            let effectName = button.dataset.value;
                            let currentTargets = new Set();
                            let currentConditions = new Set();
                            if (effectName.includes('|')) {
                                const parts = effectName.split('|');
                                effectName = parts[0];
                                const targetStr = parts[1] || '';
                                const conditionStr = parts[2] || '';
                                if (targetStr) {
                                    targetStr.split(',').forEach(t => {
                                        if (t.trim()) currentTargets.add(t.trim());
                                    });
                                }
                                if (conditionStr) {
                                    conditionStr.split(',').forEach(c => {
                                        if (c.trim()) currentConditions.add(c.trim());
                                    });
                                }
                            }

                            const availableTargets = new Set();
                            const availableConditionTargets = new Set();

                            // 現在のタブに応じて、チェックするスキル種別を制限
                            const allowedSkills = currentEffectTab === 'personality' ? ['1', '2', '3'] : ['S'];

                            Object.values(ALIEN_EFFECTS).forEach(alienEffect => {
                                allowedSkills.forEach(skill => {
                                    const effects = alienEffect[skill] || [];
                                    effects.forEach(effect => {
                                        // 効果名を正規化して比較（特技タブの場合）
                                        const normalizedEffectName = currentEffectTab === 'special' ? normalizeEffectName(effectName) : effectName;
                                        const normalizedDbEffectName = currentEffectTab === 'special' ? normalizeEffectName(effect.effect_name) : effect.effect_name;
                                        if (normalizedDbEffectName === normalizedEffectName) {
                                            if (effect.show_target && effect.target) {
                                                effect.target.split(',').forEach(t => {
                                                    if (t.trim()) availableTargets.add(t.trim());
                                                });
                                            }
                                            if (effect.show_condition_target && effect.condition_target) {
                                                effect.condition_target.split(',').forEach(c => {
                                                    if (c.trim()) availableConditionTargets.add(c.trim());
                                                });
                                            }
                                        }
                                    });
                                });
                            });

                            // 特技タブではtarget/condition_targetを表示しない（detailExpander自体も作成しない）
                            if (currentEffectTab === 'special') {
                                // 特技タブ時はdetailExpanderを作成せずに終了
                                return;
                            }

                            // show_targetとshow_condition_targetが両方falseの場合はdetailExpanderを作成しない
                            if (availableTargets.size === 0 && availableConditionTargets.size === 0) {
                                return;
                            }

                            // 個性タブでのみdetailExpanderを作成
                            detailExpander = document.createElement('div');
                            detailExpander.className = 'effect-detail-expander';
                            detailExpander.style.width = '100%';
                            detailExpander.style.marginTop = '4px';
                            detailExpander.style.padding = '6px';
                            detailExpander.style.backgroundColor = 'rgba(200, 200, 200, 0.15)';
                            detailExpander.style.borderRadius = '4px';
                            detailExpander.style.border = '1px solid rgba(150, 150, 150, 0.3)';

                            if (availableTargets.size > 0) {
                                const targetSection = document.createElement('div');
                                targetSection.style.marginBottom = '8px';

                                const targetLabel = document.createElement('div');
                                const effectType = button.dataset.effectType || '';
                                if (effectType === 'DEBUFF') {
                                    targetLabel.textContent = 'デバフ対象：';
                                } else {
                                    targetLabel.textContent = 'バフ対象：';
                                }
                                targetLabel.style.fontSize = '1.2vh';
                                targetLabel.style.marginBottom = '4px';
                                targetLabel.style.color = 'rgba(255, 255, 255, 0.8)';
                                targetSection.appendChild(targetLabel);

                                const targetButtonsContainer = document.createElement('div');
                                targetButtonsContainer.style.display = 'flex';
                                targetButtonsContainer.style.flexWrap = 'wrap';
                                targetButtonsContainer.style.gap = '4px';

                                const sortedTargets = Array.from(availableTargets).sort();
                                sortedTargets.forEach(target => {
                                    const targetBtn = createFilterOptionButton(
                                        target,
                                        'target',
                                        currentTargets.has(target),
                                        () => {
                                            if (currentTargets.has(target)) {
                                                currentTargets.delete(target);
                                            } else {
                                                currentTargets.add(target);
                                            }
                                            updateTargetConditionMulti(button, currentTargets, currentConditions);
                                            updateTargetButtonsMulti(button, currentTargets, currentConditions, availableTargets, availableConditionTargets);
                                        }
                                    );
                                    targetButtonsContainer.appendChild(targetBtn);
                                });

                                targetSection.appendChild(targetButtonsContainer);
                                detailExpander.appendChild(targetSection);
                            }

                            if (availableConditionTargets.size > 0) {
                                const conditionSection = document.createElement('div');

                                const conditionLabel = document.createElement('div');
                                conditionLabel.textContent = '効果対象：';
                                conditionLabel.style.fontSize = '1.2vh';
                                conditionLabel.style.marginBottom = '4px';
                                conditionLabel.style.color = 'rgba(255, 255, 255, 0.8)';
                                conditionSection.appendChild(conditionLabel);

                                const conditionButtonsContainer = document.createElement('div');
                                conditionButtonsContainer.style.display = 'flex';
                                conditionButtonsContainer.style.flexWrap = 'wrap';
                                conditionButtonsContainer.style.gap = '4px';

                                const sortedConditions = Array.from(availableConditionTargets).sort();
                                sortedConditions.forEach(condition => {
                                    const conditionBtn = createFilterOptionButton(
                                        condition,
                                        'condition',
                                        currentConditions.has(condition),
                                        () => {
                                            if (currentConditions.has(condition)) {
                                                currentConditions.delete(condition);
                                            } else {
                                                currentConditions.add(condition);
                                            }
                                            updateTargetConditionMulti(button, currentTargets, currentConditions);
                                            updateTargetButtonsMulti(button, currentTargets, currentConditions, availableTargets, availableConditionTargets);
                                        }
                                    );
                                    conditionButtonsContainer.appendChild(conditionBtn);
                                });

                                conditionSection.appendChild(conditionButtonsContainer);
                                detailExpander.appendChild(conditionSection);
                            }

                            button.parentNode.insertBefore(detailExpander, button.nextSibling);
                        }

                        function updateTargetConditionMulti(button, selectedTargets, selectedConditions) {
                            const effectName = button.dataset.value.split('|')[0];
                            const targetStr = Array.from(selectedTargets).sort().join(',');
                            const conditionStr = Array.from(selectedConditions).sort().join(',');

                            if (targetStr || conditionStr) {
                                button.dataset.value = `${effectName}|${targetStr}|${conditionStr}`;
                                let detailText = effectName;
                                if (targetStr) {
                                    const targetTexts = Array.from(selectedTargets).map(t => convertTargetToJP(t));
                                    detailText += ` [${targetTexts.join('/')}]`;
                                }
                                if (conditionStr) {
                                    const conditionTexts = Array.from(selectedConditions).map(c => convertTargetToJP(c));
                                    detailText += ` (${conditionTexts.join('/')})`;
                                }
                                button.textContent = detailText;
                                button.classList.add('effect-with-detail');
                            } else {
                                button.dataset.value = effectName;
                                button.textContent = effectName;
                                button.classList.remove('effect-with-detail');
                            }
                            // 選択状態を保存
                            tabSelectionState[currentEffectTab] = new Set();
                            document.querySelectorAll('.effect-button.selected').forEach(btn => {
                                tabSelectionState[currentEffectTab].add(btn.dataset.value);
                            });
                            updateEffectTabButtons();
                            applyFilters();
                        }

                        function updateTargetButtonsMulti(button, selectedTargets, selectedConditions, availableTargets, availableConditionTargets) {
                            if (!detailExpander) return;

                            detailExpander.querySelectorAll('[data-target]').forEach(btn => {
                                const targetValue = btn.dataset.target;
                                const img = btn.querySelector('img');
                                const isSelected = selectedTargets.has(targetValue);

                                if (img) {
                                    img.style.opacity = isSelected ? 1 : 0.4;
                                    if (isSelected) {
                                        img.style.filter = 'drop-shadow(0 0 0.3vh var(--accent-green)) drop-shadow(0 0 0.3vh var(--accent-green))';
                                    } else {
                                        img.style.filter = '';
                                    }
                                } else {
                                    btn.style.backgroundColor = isSelected ? 'rgba(76, 175, 80, 0.3)' : 'rgba(255, 255, 255, 0.1)';
                                    btn.style.color = isSelected ? '#fff' : 'rgba(255, 255, 255, 0.7)';
                                }
                            });

                            detailExpander.querySelectorAll('[data-condition]').forEach(btn => {
                                const conditionValue = btn.dataset.condition;
                                const img = btn.querySelector('img');
                                const isSelected = selectedConditions.has(conditionValue);

                                if (img) {
                                    img.style.opacity = isSelected ? 1 : 0.4;
                                    if (isSelected) {
                                        img.style.filter = 'drop-shadow(0 0 0.3vh var(--accent-green)) drop-shadow(0 0 0.3vh var(--accent-green))';
                                    } else {
                                        img.style.filter = '';
                                    }
                                } else {
                                    btn.style.backgroundColor = isSelected ? 'rgba(76, 175, 80, 0.3)' : 'rgba(255, 255, 255, 0.1)';
                                    btn.style.color = isSelected ? '#fff' : 'rgba(255, 255, 255, 0.7)';
                                }
                            });
                        }

                        function closeDetailExpander(button) {
                            if (detailExpander) {
                                detailExpander.remove();
                                detailExpander = null;
                            }
                        }

                        btn.closeDetailExpander = () => closeDetailExpander(btn);
                    });
                }

                // 初期の効果ボタンにイベントリスナーを設定
                setupEffectButtonListeners(allEffectButtons);

                // 絞り込み画面風のアイコンボタンを作成（複数選択対応）
                function createFilterOptionButton(value, type, isSelected, onClick) {
                    const btn = document.createElement('button');
                    btn.className = 'filter-button effect-detail-option-btn';
                    btn.style.backgroundColor = 'transparent';
                    btn.style.border = 'none';
                    btn.style.padding = '0';
                    btn.style.cursor = 'pointer';
                    btn.style.borderRadius = '0.474vh';

                    // アイコンのパスを取得（属性、はんい、距離など）
                    const iconPath = getIconPathForValue(value);
                    const displayText = convertTargetToJP(value);

                    if (iconPath) {
                        // アイコンがある場合
                        const img = document.createElement('img');
                        img.src = iconPath;
                        img.style.width = '3.791vh';
                        img.style.height = '3.791vh';
                        img.style.display = 'block';
                        img.style.opacity = isSelected ? 1 : 0.4;
                        img.style.transition = 'opacity 0.2s, filter 0.2s';
                        if (isSelected) {
                            img.style.filter = 'drop-shadow(0 0 0.3vh var(--accent-green)) drop-shadow(0 0 0.3vh var(--accent-green))';
                        }
                        btn.appendChild(img);
                        btn.dataset[type] = value;
                    } else {
                        // アイコンがない場合（文字で表示）
                        btn.style.padding = '4px 8px';
                        btn.style.fontSize = '1.2vh';
                        btn.style.border = '1px solid rgba(150, 150, 150, 0.5)';
                        btn.style.borderRadius = '4px';
                        btn.style.backgroundColor = isSelected ? 'rgba(76, 175, 80, 0.3)' : 'rgba(255, 255, 255, 0.1)';
                        btn.style.color = isSelected ? '#fff' : 'rgba(255, 255, 255, 0.7)';
                        btn.textContent = displayText;
                        btn.dataset[type] = value;
                    }

                    btn.addEventListener('click', onClick);
                    return btn;
                }

                // 値に対応するアイコンパスを取得
                function getIconPathForValue(value) {
                    if (!value || !value.includes(':')) return null;

                    const [category, val] = value.split(':');
                    // 属性
                    if (category === 'a' && ['1', '2', '3', '4'].includes(val)) {
                        return `/static/icon/a${val}.webp`;
                    }
                    // 所属
                    if (category === 'b' && ['1', '2', '3', '4', '5'].includes(val)) {
                        return `/static/icon/b${val}.webp`;
                    }
                    // 攻撃はんい
                    if (category === 'c' && ['1', '2'].includes(val)) {
                        return `/static/icon/c${val}.webp`;
                    }
                    // 攻撃距離
                    if (category === 'd' && ['1', '2', '3'].includes(val)) {
                        return `/static/icon/d${val}.webp`;
                    }
                    // ロール
                    if (category === 'f' && ['1', '2', '3', '4'].includes(val)) {
                        return `/static/icon/f${val}.webp`;
                    }
                    return null;
                }

                // 個性ボタンのイベントリスナー
                skillButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        btn.classList.toggle('selected');
                        const value = btn.dataset.value;
                        if (['1', '2', '3'].includes(value)) {
                            if (btn.classList.contains('selected')) {
                                selectedPersonalitySkillSlots.add(value);
                            } else {
                                selectedPersonalitySkillSlots.delete(value);
                            }
                        }
                        applyFilters();
                    });
                });

                // サブカテゴリ見出しクリックで折りたたみ（動的に設定する関数）
                function setupSubCategoryCollapse() {
                    optionsDiv.querySelectorAll('.effect-sub-category-title').forEach(title => {
                        const container = title.nextElementSibling;
                        if (!container || !container.classList.contains('effect-sub-category-container')) return;

                        // 初期状態は開いている
                        title.classList.remove('collapsed');

                        // 既にイベントリスナーが設定されている場合はスキップ
                        if (title.dataset.listenerSet === 'true') return;
                        title.dataset.listenerSet = 'true';

                        title.addEventListener('click', () => {
                            const isCollapsed = container.classList.contains('collapsed');
                            if (isCollapsed) {
                                container.classList.remove('collapsed');
                                title.classList.remove('collapsed');
                            } else {
                                container.classList.add('collapsed');
                                title.classList.add('collapsed');
                            }
                        });
                    });
                }

                // リセットボタンのイベントリスナー
                resetBtn.addEventListener('click', () => {
                    allEffectButtons.forEach(b => b.classList.remove('selected'));
                    skillButtons.forEach(b => {
                        if (currentEffectTab === 'personality' && ['1', '2', '3'].includes(b.dataset.value)) {
                            b.classList.add('selected');
                        } else if (currentEffectTab === 'special' && b.dataset.value === 'S') {
                            b.classList.add('selected');
                        }
                    });
                    selectedPersonalitySkillSlots.clear();
                    ['1', '2', '3'].forEach(v => selectedPersonalitySkillSlots.add(v));
                    // ダメージのみボタンもリセット
                    damageOnlyBtn.classList.remove('selected');
                    // 現在のタブの選択状態をクリア
                    tabSelectionState[currentEffectTab].clear();
                    updateEffectTabButtons();
                    applyFilters();
                });

                // バフ・デバフメニューは絞り込みメニューと同じく、flex-boxレイアウトで自動調整される
            }
        }
        let touchStartX = 0;
        let touchEndX = 0;
        let touchMoved = false;

        // スワイプ距離を絶対距離50pxに固定
        function getSwipeThreshold() {
            return 50;
        }

        // パーティ表示エリアとセレクターの両方でスワイプ操作を有効化
        const partySelector = document.querySelector('.party-selector');
        const swipeAreas = [partyDisplay, partySelector];

        swipeAreas.forEach(area => {
            area.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
                touchMoved = false;
            }, { passive: true });

            area.addEventListener('touchmove', (e) => {
                // 5px以上動いたらスワイプ判定ON
                if (Math.abs(e.changedTouches[0].screenX - touchStartX) > 5) {
                    touchMoved = true;
                }
            }, { passive: true });

            area.addEventListener('touchend', (e) => {
                touchEndX = e.changedTouches[0].screenX;
                handleSwipe();
            }, { passive: true });

            // スクロールでパーティ移動（PC/スマホ共通）
            area.addEventListener('wheel', (e) => {
                if (dragState.active || isAnimating) return; // ドラッグ中・アニメ中は無効

                // 説明文エリア上でホバー中の場合はパーティ移動を無効化
                const target = e.target.closest('.skill-description');
                if (target) {
                    // 説明文内のスクロールを優先（パーティ移動は無効）
                    return;
                }

                // 横スクロールまたは縦スクロール
                const delta = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.deltaY;

                if (Math.abs(delta) > 30) {
                    e.preventDefault();

                    if (delta > 0) {
                        switchParty('next');
                    } else {
                        switchParty('prev');
                    }
                }
            }, { passive: false });
        });

        function handleSwipe() {
            if (isAnimating || dragState.active || !touchMoved) return; // ドラッグ中または移動なしは無効化
            const threshold = getSwipeThreshold();
            if (touchEndX < touchStartX - threshold) {
                switchParty('next');
            }
            if (touchEndX > touchStartX + threshold) {
                switchParty('prev');
            }
        }
        /**
         * タブボタンのfiltered状態を更新する関数（グローバルスコープ）
         */
        function updateEffectTabButtons() {
            const personalityTab = document.querySelector('.effect-tab-button[data-tab="personality"]');
            const specialTab = document.querySelector('.effect-tab-button[data-tab="special"]');
            const effectFilterButton = document.getElementById('effect-filter-button');
            const betweenTabsModeToggleBtn = document.querySelector('[data-button-type="betweenTabs"]');

            if (!personalityTab || !specialTab) return; // タブボタンが存在しない場合は何もしない

            let hasAnyEffectSelected = false;

            // 個性タブがアクティブで、個性タブに選択がある場合
            if (currentEffectTab === 'personality') {
                const currentSelectionCount = document.querySelectorAll('.effect-button.selected').length;
                const personalityHasSelection = currentSelectionCount > 0 || tabSelectionState.personality.size > 0;
                personalityTab.classList.toggle('filtered', personalityHasSelection);
                const specialHasSelection = tabSelectionState.special.size > 0 || document.querySelector('[data-key="damage-only"].selected') !== null;
                specialTab.classList.toggle('filtered', specialHasSelection);
                hasAnyEffectSelected = personalityHasSelection || specialHasSelection;
            } else {
                const damageOnlyBtn = document.querySelector('[data-key="damage-only"]');
                const damageOnlySelected = damageOnlyBtn && damageOnlyBtn.classList.contains('selected');
                const currentSelectionCount = document.querySelectorAll('.effect-button.selected').length;
                const specialHasSelection = currentSelectionCount > 0 || damageOnlySelected || tabSelectionState.special.size > 0;
                specialTab.classList.toggle('filtered', specialHasSelection);
                const personalityHasSelection = tabSelectionState.personality.size > 0;
                personalityTab.classList.toggle('filtered', personalityHasSelection);
                hasAnyEffectSelected = personalityHasSelection || specialHasSelection;
            }

            // 個性と特技の間のAND/ORボタンの有効/無効を更新
            if (betweenTabsModeToggleBtn) {
                const personalityHasSelection = tabSelectionState.personality && tabSelectionState.personality.size > 0;
                const specialHasSelection = tabSelectionState.special && tabSelectionState.special.size > 0;
                const bothHaveSelection = personalityHasSelection && specialHasSelection;

                if (bothHaveSelection) {
                    betweenTabsModeToggleBtn.style.opacity = '1';
                    betweenTabsModeToggleBtn.style.cursor = 'pointer';
                } else {
                    betweenTabsModeToggleBtn.style.opacity = '0.5';
                    betweenTabsModeToggleBtn.style.cursor = 'default';
                }
            }

            // バフデバフボタンも赤くする
            if (effectFilterButton) {
                effectFilterButton.classList.toggle('filtered', hasAnyEffectSelected);
            }
        }

        /**
         * 現在のフィルター選択状態を`activeFilters`オブジェクトに適用し、グリッドを更新する
         */
        function applyFilters() {
            activeFilters = {};
            // 通常のフィルターボタン（属性、所属など）
            document.querySelectorAll('.filter-button.selected:not(.all-button):not(.effect-skill-button):not(.effect-button)').forEach(btn => {
                const key = btn.dataset.key;
                const value = btn.dataset.value;
                if (key && value && key !== 'effect-reset' && key !== 'damage-only') {
                    if (!activeFilters[key]) activeFilters[key] = new Set();
                    activeFilters[key].add(value);
                }
            });

            // 効果フィルター：個性タブと特技タブの両方の選択状態を反映
            const allEffectSelections = new Set();
            // 個性タブの選択状態を追加
            if (tabSelectionState.personality && tabSelectionState.personality.size > 0) {
                tabSelectionState.personality.forEach(effectValue => {
                    allEffectSelections.add(effectValue);
                });
            }
            // 特技タブの選択状態を追加
            if (tabSelectionState.special && tabSelectionState.special.size > 0) {
                tabSelectionState.special.forEach(effectValue => {
                    if (effectValue !== 'damage-only') { // damage-onlyは別途処理
                        allEffectSelections.add(effectValue);
                    }
                });
            }

            if (allEffectSelections.size > 0) {
                activeFilters['effects'] = allEffectSelections;
            }

            // タブボタンの状態を更新
            updateEffectTabButtons();
            updateAlienGrid();
        }

        /**
         * フィルターUIの状態（「すべて」ボタンの選択状態や「絞り込み」ボタンの色）を更新する
         */
        function updateFilterUIState() {
            let hasRegularFilterActive = false;

            // 名前検索欄が入力されているかチェック
            const nameSearchInput = document.getElementById('name-search-input');
            const hasNameSearch = nameSearchInput && nameSearchInput.value.trim().length > 0;

            // 通常のフィルターセクションをチェック（効果フィルターセクションと検索セクションは除外）
            document.querySelectorAll('.filter-section:not(#filter-section-effects):not(#filter-section-search)').forEach(section => {
                const allBtn = section.querySelector('.all-button');
                if (!allBtn) return;

                const optionButtons = Array.from(section.querySelectorAll('.filter-button:not(.all-button):not(.effect-button):not(.effect-skill-button)'));
                const selectedCount = section.querySelectorAll('.filter-button.selected:not(.all-button):not(.effect-button):not(.effect-skill-button)').length;
                const isAllSelected = selectedCount === optionButtons.length;

                allBtn.classList.toggle('selected', isAllSelected);
                if (!isAllSelected && optionButtons.length > 0) {
                    hasRegularFilterActive = true;
                }
            });

            // 名前検索欄が入力されていれば絞り込み状態にする
            if (hasNameSearch) {
                hasRegularFilterActive = true;
            }

            filterButton.classList.toggle('filtered', hasRegularFilterActive);
        }

        // （注意）下記のドラッグ＆ドロップ用関数はこのファイル上部で実装済みです。
        // 以前ここにあったダミー定義が実装を上書きしてしまい、DnDが無効化されていました。
        // そのためダミー定義は削除しました。

        // ==========================================================================
        //  イベントリスナー設定
        // ==========================================================================

        // --- 個性詳細表示の切り替え ---
        partyDisplay.addEventListener('click', function (event) {
            const skillBlock = event.target.closest('.skill-block');

            if (skillBlock) { // 個性ブロックがクリックされた場合
                const parentArea = skillBlock.parentElement;
                const isActive = skillBlock.classList.contains('is-active');
                const slotIndex = skillBlock.getAttribute('data-slot-index');
                const skillIndex = skillBlock.getAttribute('data-skill-index');

                // いったん全てのアクティブ状態を解除
                parentArea.querySelectorAll('.skill-block').forEach(el => el.classList.remove('is-active'));
                parentArea.classList.remove('skills-area-detail-view');

                if (!isActive) { // 非アクティブなものをクリックした場合、アクティブにする
                    parentArea.classList.add('skills-area-detail-view');
                    skillBlock.classList.add('is-active');
                    // 状態を保存
                    if (slotIndex !== null && skillIndex !== null) {
                        openedSkills[currentPartyId][slotIndex] = parseInt(skillIndex);
                    }
                } else {
                    // 閉じた場合は状態をクリア
                    if (slotIndex !== null) {
                        delete openedSkills[currentPartyId][slotIndex];
                    }
                }
            }
        });
        // --- ドロワーの開閉 ---
        function openDrawerWithHistory() {
            drawer.classList.add('open');
            toggleButton.textContent = '◀';
            // History APIで履歴追加
            if (!drawer.dataset.historyAdded) {
                history.pushState({ drawer: true }, '');
                drawer.dataset.historyAdded = 'true';
            }
        }
        function closeDrawerWithoutHistory() {
            drawer.classList.remove('open');
            toggleButton.textContent = '▶';
            drawer.dataset.historyAdded = '';
        }

        toggleButton.addEventListener('click', () => {
            // プレビュー中は操作を無効化
            if (longPressState.active) return;

            if (drawer.classList.contains('open')) {
                closeDrawerWithoutHistory();
                history.back(); // 履歴を戻す
            } else {
                openDrawerWithHistory();
            }
        });
        mainContainer.addEventListener('click', () => {
            // プレビュー中は操作を無効化
            if (longPressState.active) return;

            if (drawer.classList.contains('open')) {
                closeDrawerWithoutHistory();
                history.back(); // 履歴を戻す
            }
        });

        // --- エイリアン一覧でのクリック（パーティへの追加/削除） ---
        alienGrid.addEventListener('click', (event) => {
            const card = event.target.closest('.alien-card');
            if (!card) return;
            event.stopPropagation();

            // 長押しプレビュー中の場合はプレビューを閉じる
            if (longPressState.active) {
                closeLongPressPreview();
                return;
            }

            const clickedAlienId = parseInt(card.dataset.id, 10);
            const alienDataForGrid = allAliensData.find(a => a.id == clickedAlienId);
            if (!alienDataForGrid) return;

            // 現在のパーティのみをチェックして、このキャラが編成されているか確認
            const currentParty = parties[currentPartyId];
            const foundAtIndex = currentParty.findIndex(member => member && parseInt(member.id, 10) === clickedAlienId);

            if (foundAtIndex !== -1) {
                // 現在のパーティに編成されている場合は解除
                removeFromParty(foundAtIndex);
            } else {
                // 編成されていない場合は現在のパーティに追加
                addToParty(alienDataForGrid.dataset);
            }
        });

        // --- エイリアン一覧での長押しプレビュー ---
        alienGrid.addEventListener('mousedown', (event) => {
            if (longPressState.active) return;
            if (event.button !== 0) return; // 左クリックのみ
            const card = event.target.closest('.alien-card');
            if (!card) return;
            const clickedAlienId = parseInt(card.dataset.id, 10);
            const alienDataForGrid = allAliensData.find(a => a.id == clickedAlienId);
            if (!alienDataForGrid) return;
            longPressState.timer = setTimeout(() => {
                showLongPressPreview(alienDataForGrid.dataset);
            }, 500);
        });
        alienGrid.addEventListener('mouseup', cancelLongPressTimer);
        alienGrid.addEventListener('mousemove', cancelLongPressTimer);
        alienGrid.addEventListener('mouseleave', cancelLongPressTimer);

        alienGrid.addEventListener('touchstart', (event) => {
            if (longPressState.active) return;
            const card = event.target.closest('.alien-card');
            if (!card) return;
            const clickedAlienId = parseInt(card.dataset.id, 10);
            const alienDataForGrid = allAliensData.find(a => a.id == clickedAlienId);
            if (!alienDataForGrid) return;
            longPressState.timer = setTimeout(() => {
                showLongPressPreview(alienDataForGrid.dataset);
            }, 500);
        }, { passive: false });
        alienGrid.addEventListener('touchend', cancelLongPressTimer, { passive: false });
        alienGrid.addEventListener('touchmove', cancelLongPressTimer, { passive: false });
        alienGrid.addEventListener('touchcancel', cancelLongPressTimer, { passive: false });
        alienGrid.addEventListener('mouseleave', cancelLongPressTimer);

        // --- プレビューオーバーレイをタップで閉じる ---
        const previewOverlayElement = document.getElementById('preview-overlay');
        const previewSlotContainer = document.getElementById('preview-slot-container');
        if (previewSlotContainer) {
            const stopOverlayClose = (event) => {
                event.stopPropagation();
            };
            previewSlotContainer.addEventListener('pointerdown', stopOverlayClose);
            previewSlotContainer.addEventListener('click', stopOverlayClose);
        }

        previewOverlayElement.addEventListener('click', () => {
            if (longPressState.active) {
                closeLongPressPreview();
            }
        });

        // ==========================================================================
        //  パーティ一覧表示機能
        // ==========================================================================

        const overviewButton = document.getElementById('overview-button');
        const overviewOverlay = document.getElementById('party-overview-overlay');
        const overviewContainer = document.getElementById('party-overview-container');

        let overviewDragState = {
            active: false,
            sourcePartyId: null,
            ghostElement: null
        };
        /**
         * パーティ一覧を描画
         */
        function renderPartyOverview() {
            overviewContainer.innerHTML = '';

            const partyOrder = ['1', '2', '3', '4', '5'];

            partyOrder.forEach(partyId => {
                const party = parties[partyId];

                const row = document.createElement('div');
                row.className = 'overview-party-row';
                row.dataset.partyId = partyId;

                // Pラベル（ドラッグ可能）
                const label = document.createElement('div');
                label.className = 'overview-party-label';
                label.textContent = `P${partyId}`;
                label.dataset.partyId = partyId;

                // ドラッグイベント
                label.addEventListener('mousedown', (e) => handleOverviewDragStart(e, partyId));
                label.addEventListener('touchstart', (e) => handleOverviewDragStart(e, partyId), { passive: false });

                row.appendChild(label);

                // スロット表示
                const slotsDiv = document.createElement('div');
                slotsDiv.className = 'overview-party-slots';

                for (let i = 0; i < 5; i++) {
                    const alienDataSet = party[i];
                    const slot = document.createElement('div');
                    slot.className = 'overview-mini-slot';

                    if (alienDataSet) {
                        const alienData = ALL_ALIENS[alienDataSet.id];
                        if (alienData && alienData.attribute) {
                            slot.dataset.attribute = alienData.attribute;
                        }
                        const img = createAlienImageElement(alienDataSet.id, '', alienData ? alienData.name : '');
                        slot.appendChild(img);
                    } else {
                        slot.classList.add('empty');
                    }

                    slotsDiv.appendChild(slot);
                }

                row.appendChild(slotsDiv);
                overviewContainer.appendChild(row);
            });
        }

        /**
         * 一覧のドラッグ開始
         */
        function handleOverviewDragStart(e, partyId) {
            if (overviewDragState.active) return;
            e.preventDefault();

            overviewDragState.active = true;
            overviewDragState.sourcePartyId = partyId;

            // ゴースト作成
            const ghost = document.createElement('div');
            ghost.textContent = `P${partyId}`;
            ghost.style.position = 'fixed';
            ghost.style.zIndex = 9999;
            ghost.style.pointerEvents = 'none';
            ghost.style.fontSize = '2vh';
            ghost.style.fontWeight = 'bold';
            ghost.style.color = 'var(--accent-green)';
            ghost.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            ghost.style.padding = '1vh 2vh';
            ghost.style.borderRadius = '0.5vh';
            ghost.style.border = '0.2vh solid var(--accent-green)';
            document.body.appendChild(ghost);

            overviewDragState.ghostElement = ghost;
            updateOverviewGhostPosition(e);

            document.addEventListener('mousemove', handleOverviewDragMove);
            document.addEventListener('mouseup', handleOverviewDragEnd);
            document.addEventListener('touchmove', handleOverviewDragMove, { passive: false });
            document.addEventListener('touchend', handleOverviewDragEnd);
        }

        function handleOverviewDragMove(e) {
            if (!overviewDragState.active) return;
            e.preventDefault();

            updateOverviewGhostPosition(e);

            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            const el = document.elementFromPoint(clientX, clientY);
            const targetRow = el ? el.closest('.overview-party-row') : null;

            // ハイライト解除
            document.querySelectorAll('.overview-party-row').forEach(r => r.classList.remove('drag-over'));

            if (targetRow && targetRow.dataset.partyId !== overviewDragState.sourcePartyId) {
                targetRow.classList.add('drag-over');
            }
        }

        function handleOverviewDragEnd(e) {
            if (!overviewDragState.active) return;
            e.preventDefault();

            let clientX, clientY;
            if (e.changedTouches && e.changedTouches.length > 0) {
                clientX = e.changedTouches[0].clientX;
                clientY = e.changedTouches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            const el = document.elementFromPoint(clientX, clientY);
            const targetRow = el ? el.closest('.overview-party-row') : null;

            if (targetRow && targetRow.dataset.partyId !== overviewDragState.sourcePartyId) {
                const targetPartyId = targetRow.dataset.partyId;
                const sourcePartyId = overviewDragState.sourcePartyId;

                // パーティデータを入れ替え
                const temp = parties[sourcePartyId];
                parties[sourcePartyId] = parties[targetPartyId];
                parties[targetPartyId] = temp;

                // 開いたスキルの状態も入れ替え
                const tempOpened = openedSkills[sourcePartyId];
                openedSkills[sourcePartyId] = openedSkills[targetPartyId];
                openedSkills[targetPartyId] = tempOpened;

                // すべてのパーティコンテナを再描画（表示されていないパーティも即座に反映）
                for (let partyId = 1; partyId <= 5; partyId++) {
                    renderPartySlots(String(partyId));
                }

                // その他の表示も更新
                renderPartyOverview();
                renderDrawerPartyPreview();
                updateAlienCardSelectedState();
            }

            // ハイライト解除
            document.querySelectorAll('.overview-party-row').forEach(r => r.classList.remove('drag-over'));

            // ゴースト削除
            if (overviewDragState.ghostElement && overviewDragState.ghostElement.parentNode) {
                overviewDragState.ghostElement.parentNode.removeChild(overviewDragState.ghostElement);
            }

            // イベントリスナー解除
            document.removeEventListener('mousemove', handleOverviewDragMove);
            document.removeEventListener('mouseup', handleOverviewDragEnd);
            document.removeEventListener('touchmove', handleOverviewDragMove);
            document.removeEventListener('touchend', handleOverviewDragEnd);

            overviewDragState.active = false;
            overviewDragState.sourcePartyId = null;
            overviewDragState.ghostElement = null;
        }

        function updateOverviewGhostPosition(e) {
            if (!overviewDragState.ghostElement) return;

            let x, y;
            if (e.touches && e.touches.length > 0) {
                x = e.touches[0].clientX;
                y = e.touches[0].clientY;
            } else {
                x = e.clientX;
                y = e.clientY;
            }

            overviewDragState.ghostElement.style.left = (x - overviewDragState.ghostElement.offsetWidth / 2) + 'px';
            overviewDragState.ghostElement.style.top = (y - overviewDragState.ghostElement.offsetHeight / 2) + 'px';
        }

        /**
         * 一覧表示を開く
         */
        function openPartyOverview() {
            renderPartyOverview();
            overviewOverlay.classList.add('active');
        }
        /**
         * 一覧表示を閉じる
         */
        function closePartyOverview() {
            overviewOverlay.classList.remove('active');
        }

        // 一覧表示ボタンのイベント
        const overviewButtonHandler = () => {
            openPartyOverview();
        };
        overviewButton.addEventListener('click', overviewButtonHandler);
        document.querySelector('.overview-button-label').addEventListener('click', overviewButtonHandler);

        // オーバーレイをタップで閉じる
        overviewOverlay.addEventListener('click', (e) => {
            if (e.target === overviewOverlay) {
                closePartyOverview();
            }
        });

        // ==========================================================================
        //  絞り込み・並び替えメニューの制御
        // ==========================================================================

        filterMenu.addEventListener('click', (e) => { e.stopPropagation(); });
        effectFilterMenu.addEventListener('click', (e) => { e.stopPropagation(); });
        filterButton.addEventListener('click', (e) => {
            e.stopPropagation();
            const isOpening = filterMenu.style.display !== 'block';
            filterMenu.style.display = isOpening ? 'block' : 'none';
            e.currentTarget.textContent = isOpening ? '絞り込み▲' : '絞り込み▼';
            // 効果フィルターメニューを閉じる
            if (isOpening) {
                effectFilterMenu.style.display = 'none';
                effectFilterButton.textContent = 'バフ・デバフ▼';
            }
        });
        // 絞り込みメニューの自然な高さを計測する
        function measureFilterMenuHeight() {
            const wasOpen = filterMenu.style.display === 'block';
            let heightPx = 0;
            if (wasOpen) {
                heightPx = filterMenu.clientHeight;
            } else {
                const prevDisplay = filterMenu.style.display;
                const prevVisibility = filterMenu.style.visibility;
                const prevPosition = filterMenu.style.position;
                const prevZIndex = filterMenu.style.zIndex;
                filterMenu.style.visibility = 'hidden';
                filterMenu.style.position = 'absolute';
                filterMenu.style.zIndex = '-1';
                filterMenu.style.display = 'block';
                heightPx = filterMenu.clientHeight;
                filterMenu.style.display = prevDisplay;
                filterMenu.style.visibility = prevVisibility;
                filterMenu.style.position = prevPosition;
                filterMenu.style.zIndex = prevZIndex;
            }
            return heightPx;
        }

        effectFilterButton.addEventListener('click', (e) => {
            e.stopPropagation();
            const isOpening = effectFilterMenu.style.display !== 'block';

            if (isOpening) {
                // 絞り込みメニューの自然な高さを取得
                let targetHeightPx = measureFilterMenuHeight();
                // フォールバック: 取得できなければ50vh
                if (!targetHeightPx || Number.isNaN(targetHeightPx)) {
                    effectFilterMenu.style.setProperty('height', '50vh', 'important');
                    effectFilterMenu.style.setProperty('flex', '0 0 50vh', 'important');
                } else {
                    effectFilterMenu.style.setProperty('height', targetHeightPx + 'px', 'important');
                    effectFilterMenu.style.setProperty('flex', `0 0 ${targetHeightPx}px`, 'important');
                }
                effectFilterMenu.style.display = 'block';

                // 確認用ログ
                setTimeout(() => {
                    console.log('Filter natural height(px):', targetHeightPx, 'Applied height:', effectFilterMenu.style.getPropertyValue('height'));
                    console.log('Scroll height:', effectFilterMenu.scrollHeight, 'Client height:', effectFilterMenu.clientHeight);
                }, 100);
            } else {
                // リセット
                effectFilterMenu.style.removeProperty('height');
                effectFilterMenu.style.removeProperty('flex');
                effectFilterMenu.style.display = 'none';
            }

            e.currentTarget.textContent = isOpening ? 'バフ・デバフ▲' : 'バフ・デバフ▼';
            // 絞り込みメニューを閉じる
            if (isOpening) {
                filterMenu.style.display = 'none';
                filterButton.textContent = '絞り込み▼';
            }
        });
        sortButton.addEventListener('click', (e) => {
            e.stopPropagation();
            sortMenu.style.display = sortMenu.style.display === 'block' ? 'none' : 'block';
        });
        sortMenu.addEventListener('click', (e) => {
            const button = e.target.closest('.control-button');
            if (button) {
                currentSort.key = button.dataset.sortKey;
                sortButton.textContent = button.textContent;
                updateAlienGrid();
                sortMenu.style.display = 'none';
            }
        });
        sortOrderButton.addEventListener('click', () => {
            currentSort.order = currentSort.order === 'desc' ? 'asc' : 'desc';
            sortOrderButton.textContent = currentSort.order === 'desc' ? '降順' : '昇順';
            updateAlienGrid();
        });
        document.body.addEventListener('click', () => {
            if (sortMenu.style.display === 'block') {
                sortMenu.style.display = 'none';
            }
        });

        // --- 名前検索機能 ---
        const nameSearchInput = document.getElementById('name-search-input');
        const searchResetButton = document.getElementById('search-reset-button');

        if (nameSearchInput) {
            nameSearchInput.addEventListener('input', () => {
                nameSearchQuery = nameSearchInput.value.trim();
                updateAlienGrid();
                updateFilterUIState();
            });
        }

        if (searchResetButton) {
            searchResetButton.addEventListener('click', () => {
                nameSearchInput.value = '';
                nameSearchQuery = '';
                updateAlienGrid();
                updateFilterUIState();
            });
        }

        // --- ヘルプモーダルの制御 ---
        const helpButton = document.getElementById('help-button');
        const helpModal = document.getElementById('help-modal');
        const closeModalButton = document.getElementById('close-modal-button');

        function openModalWithHistory() {
            helpModal.style.display = 'flex';
            // History APIで履歴追加
            if (!helpModal.dataset.historyAdded) {
                history.pushState({ modal: true }, '');
                helpModal.dataset.historyAdded = 'true';
            }
        }

        function closeModalWithoutHistory() {
            helpModal.style.display = 'none';
            helpModal.dataset.historyAdded = '';
        }

        // ==========================================================================
        //  ヘルプモーダル ページネーション機能
        // ==========================================================================
        let currentHelpPage = 1;
        // 実際の.help-page要素の数を動的に取得
        function getTotalHelpPages() {
            return document.querySelectorAll('.help-page[data-page]').length;
        }
        let totalHelpPages = getTotalHelpPages();

        const helpPrevButton = document.getElementById('help-prev-button');
        const helpNextButton = document.getElementById('help-next-button');
        const helpPageDots = document.getElementById('help-page-dots');

        function updateHelpPageDots() {
            // ページ数を再取得（要素が追加された場合に対応）
            totalHelpPages = getTotalHelpPages();
            helpPageDots.innerHTML = '';
            for (let i = 1; i <= totalHelpPages; i++) {
                const dot = document.createElement('span');
                dot.className = 'help-page-dot';
                if (i === currentHelpPage) {
                    dot.classList.add('active');
                }
                dot.dataset.page = i;
                dot.addEventListener('click', () => {
                    showHelpPage(i);
                });
                helpPageDots.appendChild(dot);
            }
        }

        function showHelpPage(pageNum) {
            // ページ数を再取得
            totalHelpPages = getTotalHelpPages();

            // ループ機能: ページ番号を正規化（1未満の場合は最終ページ、totalHelpPagesより大きい場合は最初のページ）
            let normalizedPageNum = pageNum;
            if (pageNum < 1) {
                normalizedPageNum = totalHelpPages;
            } else if (pageNum > totalHelpPages) {
                normalizedPageNum = 1;
            }

            // まずcurrentHelpPageを更新（ドット更新の前に）
            currentHelpPage = normalizedPageNum;

            // 全ページを非表示
            document.querySelectorAll('.help-page').forEach(page => {
                page.style.display = 'none';
            });

            // 指定ページを表示
            const targetPage = document.querySelector(`.help-page[data-page="${normalizedPageNum}"]`);
            if (targetPage) {
                targetPage.style.display = 'block';
            }

            // ドットを更新（currentHelpPageが既に更新されているので正しく表示される）
            updateHelpPageDots();

            // ループするのでボタンは常に有効（無効化しない）
            helpPrevButton.disabled = false;
            helpNextButton.disabled = false;
        }

        helpPrevButton.addEventListener('click', () => {
            // ループ機能: 最初のページから前へ → 最終ページへ
            if (currentHelpPage > 1) {
                showHelpPage(currentHelpPage - 1);
            } else {
                showHelpPage(totalHelpPages);
            }
        });

        helpNextButton.addEventListener('click', () => {
            // ループ機能: 最終ページから次へ → 最初のページへ
            if (currentHelpPage < totalHelpPages) {
                showHelpPage(currentHelpPage + 1);
            } else {
                showHelpPage(1);
            }
        });

        // 不具合報告フォームの送信処理
        const bugReportSubmit = document.getElementById('bug-report-submit');
        const bugReportText = document.getElementById('bug-report-text');
        const bugReportStatus = document.getElementById('bug-report-status');

        if (bugReportSubmit && bugReportText && bugReportStatus) {
            bugReportSubmit.addEventListener('click', async () => {
                const text = bugReportText.value.trim();

                if (!text) {
                    bugReportStatus.textContent = '報告内容を入力してください';
                    bugReportStatus.style.display = 'block';
                    bugReportStatus.style.color = '#ff6666';
                    return;
                }

                // 送信ボタンを無効化
                bugReportSubmit.disabled = true;
                bugReportSubmit.textContent = '送信中...';
                bugReportStatus.style.display = 'none';

                try {
                    const response = await fetch('/api/bug-report', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ text: text })
                    });

                    const data = await response.json();

                    if (data.success) {
                        bugReportStatus.textContent = '報告を送信しました。ありがとうございます！';
                        bugReportStatus.style.display = 'block';
                        bugReportStatus.style.color = '#66ff66';
                        bugReportText.value = '';
                    } else {
                        bugReportStatus.textContent = `エラー: ${data.error || '送信に失敗しました'}`;
                        bugReportStatus.style.display = 'block';
                        bugReportStatus.style.color = '#ff6666';
                    }
                } catch (error) {
                    bugReportStatus.textContent = 'エラー: 通信に失敗しました';
                    bugReportStatus.style.display = 'block';
                    bugReportStatus.style.color = '#ff6666';
                } finally {
                    bugReportSubmit.disabled = false;
                    bugReportSubmit.textContent = '報告を送信';
                }
            });
        }

        installButtonElement = document.getElementById('install-app-button');
        if (installButtonElement) {
            installButtonElement.addEventListener('click', async () => {
                if (!deferredInstallPrompt) {
                    if (isIOSDevice()) {
                        alert('Safari画面下の共有ボタンから「ホーム画面に追加」を選択してください。');
                    } else {
                        alert('ブラウザの共有メニューから「ホーム画面に追加」を選択してください。');
                    }
                    return;
                }
                installButtonElement.disabled = true;
                try {
                    deferredInstallPrompt.prompt();
                    await deferredInstallPrompt.userChoice;
                } catch (error) {
                    console.error('Install prompt error:', error);
                } finally {
                    installButtonElement.disabled = false;
                    deferredInstallPrompt = null;
                    updateInstallButtonVisibility();
                }
            });
        }
        updateInstallButtonVisibility();

        // ヘルプモーダルを開いた時に1ページ目にリセット
        const helpButtonHandler = () => {
            openModalWithHistory();
            showHelpPage(1);
            updateInstallButtonVisibility();
        };
        helpButton.addEventListener('click', helpButtonHandler);
        document.querySelector('.help-button-label').addEventListener('click', helpButtonHandler);
        const bugReportJumpButton = document.getElementById('open-bug-report-button');
        const bugReportPageElement = document.querySelector('.help-page[data-page="8"]');
        const bugReportPageNumber = bugReportPageElement ? Number(bugReportPageElement.dataset.page) : null;
        if (bugReportJumpButton && bugReportPageNumber) {
            bugReportJumpButton.addEventListener('click', () => {
                helpButtonHandler();
                showHelpPage(bugReportPageNumber);
                const bugTextArea = document.getElementById('bug-report-text');
                if (bugTextArea) {
                    bugTextArea.focus();
                }
            });
        }
        // 初期化時にドットを生成
        updateHelpPageDots();
        closeModalButton.addEventListener('click', () => {
            closeModalWithoutHistory();
            history.back(); // 履歴を戻す
        });
        helpModal.addEventListener('click', (e) => {
            if (e.target === helpModal) { // モーダルの背景クリックで閉じる
                closeModalWithoutHistory();
                history.back(); // 履歴を戻す
            }
        });
        // --- パーティ切り替えボタン ---
        prevPartyBtn.addEventListener('click', () => switchParty('prev'));
        nextPartyBtn.addEventListener('click', () => switchParty('next'));

        // --- ドロワー内のパーティプレビュー矢印ボタン ---
        const previewArrowLeft = document.getElementById('preview-arrow-left');
        const previewArrowRight = document.getElementById('preview-arrow-right');
        if (previewArrowLeft) {
            previewArrowLeft.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                switchParty('prev');
            });
        }
        if (previewArrowRight) {
            previewArrowRight.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                switchParty('next');
            });
        }

        // --- ドロワー内プレビューエリアでのフリック（Pラベルと余白） ---
        const partyPreviewArea = document.getElementById('party-preview-area');
        if (partyPreviewArea) {
            let previewSwipeStartX = 0;
            let previewSwipeStartY = 0;
            let previewSwipeMoved = false;

            partyPreviewArea.addEventListener('touchstart', (e) => {
                // スロット（アイコン）と矢印ボタンをタッチした場合は無視
                if (e.target.closest('.preview-slot') || e.target.closest('.preview-arrow')) {
                    return;
                }
                previewSwipeStartX = e.touches[0].clientX;
                previewSwipeStartY = e.touches[0].clientY;
                previewSwipeMoved = false;
            }, { passive: true });

            partyPreviewArea.addEventListener('touchmove', (e) => {
                if (!previewSwipeStartX) return;
                previewSwipeMoved = true;
            }, { passive: true });

            partyPreviewArea.addEventListener('touchend', (e) => {
                if (!previewSwipeStartX || !previewSwipeMoved) {
                    previewSwipeStartX = 0;
                    return;
                }

                const deltaX = e.changedTouches[0].clientX - previewSwipeStartX;
                const deltaY = e.changedTouches[0].clientY - previewSwipeStartY;
                const threshold = window.innerWidth * 0.128;

                // 横方向のスワイプが縦より大きい場合のみ
                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > threshold) {
                    if (deltaX > 0) {
                        switchParty('prev');
                    } else {
                        switchParty('next');
                    }
                }

                previewSwipeStartX = 0;
            }, { passive: true });
        }

        // --- ドットクリックで直接パーティ移動 ---
        document.querySelectorAll('.dot').forEach(dot => {
            dot.addEventListener('click', (e) => {
                e.stopPropagation();
                const targetPartyId = dot.dataset.partyId;
                if (targetPartyId !== currentPartyId) {
                    currentPartyId = targetPartyId;
                    const slider = document.getElementById('party-slider-wrapper');
                    slider.style.transform = `translateX(-${(parseInt(targetPartyId) - 1) * 100}%)`;
                    renderPartySlots();
                    updatePartySelectorUI();
                }
            });
        });
        // ==========================================================================
        //  初期化処理
        // ==========================================================================

        /**
         * 全てのパーティを初期レンダリング
         */
        function renderAllParties() {
            for (let i = 1; i <= 5; i++) {
                renderPartySlots(String(i));
            }
        }

        /**
         * (★新★) 全てのパーティの要求を再チェックする関数
         */
        function checkAllPartiesRealtime() {
            for (let i = 1; i <= 5; i++) {
                checkPartyRealtime(String(i));
            }
        }

        // --- 戻るボタンでドロワー/モーダルを閉じる ---
        // ... (popstate イベントリスナー) ...

        // ==========================================================================
        //  管理モード関連の関数
        // ==========================================================================

        let isScrapeMenuOpen = false;

        function setScrapeMenu(open) {
            const container = document.querySelector('.header-scrape-container');
            const dropdown = document.getElementById('scrape-dropdown');
            const button = document.getElementById('scrape-button');
            isScrapeMenuOpen = !!open;
            if (!container || !dropdown || !button) {
                return;
            }
            if (container.style.display === 'none') {
                isScrapeMenuOpen = false;
            }
            container.classList.toggle('active-menu', isScrapeMenuOpen);
            dropdown.classList.toggle('open', isScrapeMenuOpen);
            button.setAttribute('aria-expanded', isScrapeMenuOpen ? 'true' : 'false');
        }

        function parseIdInput(rawValue) {
            if (!rawValue) {
                return [];
            }
            const sanitized = rawValue.replace(/[、\s]/g, '');
            if (!sanitized) {
                return [];
            }
            const ids = new Set();
            const tokens = sanitized.split(',');
            for (const token of tokens) {
                if (!token) continue;
                if (token.includes('-')) {
                    const parts = token.split('-');
                    if (parts.length !== 2) {
                        throw new Error('IDの形式が正しくありません (例: 1601,1603-1605)');
                    }
                    const start = Number(parts[0]);
                    const end = Number(parts[1]);
                    if (!Number.isInteger(start) || !Number.isInteger(end)) {
                        throw new Error('IDは整数で入力してください');
                    }
                    const step = start <= end ? 1 : -1;
                    for (let current = start; current !== end + step; current += step) {
                        ids.add(current);
                    }
                } else {
                    const value = Number(token);
                    if (!Number.isInteger(value)) {
                        throw new Error('IDは整数で入力してください');
                    }
                    ids.add(value);
                }
            }
            return Array.from(ids).sort((a, b) => a - b);
        }

        function openScrapeInputModal({ title, description, placeholder, submitLabel = '実行', onSubmit }) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.style.display = 'flex';

            const content = document.createElement('div');
            content.className = 'scrape-modal-content';
            content.innerHTML = `
            <h3>${title}</h3>
            <p>${description}</p>
            <input type="text" id="scrape-modal-input" placeholder="${placeholder}" autocomplete="off">
            <div class="scrape-modal-error" id="scrape-modal-error"></div>
            <div class="scrape-modal-actions">
                <button type="button" class="control-button" data-role="cancel">キャンセル</button>
                <button type="button" class="control-button" data-role="submit">${submitLabel}</button>
            </div>
        `;

            overlay.appendChild(content);
            document.body.appendChild(overlay);

            const input = content.querySelector('#scrape-modal-input');
            const errorLabel = content.querySelector('#scrape-modal-error');
            const cancelButton = content.querySelector('button[data-role="cancel"]');
            const submitButton = content.querySelector('button[data-role="submit"]');

            const cleanup = () => {
                document.removeEventListener('keydown', handleKeydown);
                overlay.remove();
            };

            const handleKeydown = (event) => {
                if (event.key === 'Escape') {
                    cleanup();
                }
                if (event.key === 'Enter' && !event.isComposing) {
                    event.preventDefault();
                    handleSubmit();
                }
            };

            const handleSubmit = async () => {
                const rawValue = input.value.trim();
                let ids = [];
                try {
                    ids = parseIdInput(rawValue);
                } catch (error) {
                    errorLabel.textContent = error.message || 'IDの形式が正しくありません';
                    return;
                }
                if (ids.length === 0) {
                    errorLabel.textContent = '1つ以上のIDを入力してください';
                    return;
                }

                errorLabel.textContent = '';
                submitButton.disabled = true;
                cancelButton.disabled = true;
                try {
                    await onSubmit(ids);
                    cleanup();
                } catch (error) {
                    submitButton.disabled = false;
                    cancelButton.disabled = false;
                    errorLabel.textContent = error.message || 'エラーが発生しました';
                }
            };

            cancelButton.addEventListener('click', cleanup);
            submitButton.addEventListener('click', handleSubmit);
            overlay.addEventListener('click', (event) => {
                if (event.target === overlay) {
                    cleanup();
                }
            });
            document.addEventListener('keydown', handleKeydown);
            input.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' && !event.isComposing) {
                    event.preventDefault();
                    handleSubmit();
                }
            });

            setTimeout(() => {
                input.focus();
            }, 0);
        }

        /**
         * 効果名ごとの使用数を取得
         */
        async function loadEffectUsageStats() {
            try {
                const response = await fetch('/api/admin/get-effect-usage');
                const data = await response.json();
                if (data.success) {
                    effectUsageStats = data.usage_stats || {};
                }
            } catch (error) {
                console.error('使用数取得エラー:', error);
                effectUsageStats = {};
            }
        }

        /**
         * 認証状態を確認
         */
        async function checkAdminAuth() {
            try {
                const response = await fetch('/api/admin/check-auth');
                const data = await response.json();
                return data.logged_in || false;
            } catch (error) {
                console.error('認証確認エラー:', error);
                return false;
            }
        }

        /**
         * 管理モードへのログイン
         */
        async function loginAdmin() {
            const modal = document.getElementById('password-modal-overlay');
            const input = document.getElementById('password-input');
            const error = document.getElementById('password-error');
            const submitBtn = document.getElementById('password-submit-button');
            const cancelBtn = document.getElementById('password-cancel-button');

            // モーダルを表示
            modal.classList.add('active');
            input.value = '';
            error.classList.remove('show');
            input.focus();

            // パスワード送信処理
            const handleSubmit = async () => {
                const password = input.value.trim();
                if (!password) {
                    error.textContent = 'パスワードを入力してください';
                    error.classList.add('show');
                    return;
                }

                try {
                    const response = await fetch('/api/admin/login', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ password: password })
                    });
                    const data = await response.json();

                    if (data.success) {
                        isAdminMode = true;
                        sessionStorage.removeItem('adminModeAfterReload'); // 正常にログインしたので削除
                        updateAdminUI();
                        modal.classList.remove('active');
                        input.value = '';
                        error.classList.remove('show');
                        // 使用数データを非同期で取得（UI更新をブロックしない）
                        loadEffectUsageStats().then(() => {
                            updateAdminUI(); // 再描画して使用数を表示
                        });
                    } else {
                        error.textContent = 'パスワードが正しくありません';
                        error.classList.add('show');
                        input.value = '';
                        input.focus();
                    }
                } catch (err) {
                    console.error('ログインエラー:', err);
                    error.textContent = 'ログインに失敗しました';
                    error.classList.add('show');
                }
            };

            // キャンセル処理
            const handleCancel = () => {
                modal.classList.remove('active');
                input.value = '';
                error.classList.remove('show');
            };

            // イベントリスナー（既存のものを削除してから追加）
            const newSubmitBtn = submitBtn.cloneNode(true);
            submitBtn.parentNode.replaceChild(newSubmitBtn, submitBtn);
            newSubmitBtn.addEventListener('click', handleSubmit);

            const newCancelBtn = cancelBtn.cloneNode(true);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
            newCancelBtn.addEventListener('click', handleCancel);

            // Enterキーで送信
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleSubmit();
                }
            });

            // ESCキーでキャンセル
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    handleCancel();
                }
            });

            return false; // モーダル表示のみ（非同期処理のため）
        }

        /**
         * 管理モードからログアウト
         */
        async function logoutAdmin() {
            // 未適用の変更がある場合は確認
            if (pendingChanges.length > 0) {
                const overlay = document.getElementById('apply-changes-overlay');
                const container = document.getElementById('apply-changes-container');
                const content = document.getElementById('apply-changes-content');
                if (overlay && container && content) {
                    content.innerHTML = `
                    <div>
                        <h3 style="margin-top: 0; font-size: 1.6vh; color: #ff8800;">未適用の変更があります</h3>
                        <div style="font-size: 1.2vh; color: #aaa; margin-bottom: 1vh;">
                            未適用の変更が${pendingChanges.length}件あります。管理モードからログアウトすると、これらの変更は失われます。
                        </div>
                        <div style="display: flex; gap: 1vh; justify-content: flex-end;">
                            <button class="control-button" id="logout-confirm" style="background-color: #f87171; color: white;">ログアウト</button>
                            <button class="control-button" id="logout-cancel" style="background-color: #4a5a6a;">キャンセル</button>
                        </div>
                    </div>
                `;
                    overlay.style.display = 'flex';

                    // オーバーレイをクリックで閉じる
                    overlay.addEventListener('click', (e) => {
                        if (e.target === overlay) {
                            overlay.style.display = 'none';
                        }
                    }, { once: true });

                    const confirmed = await new Promise((resolve) => {
                        document.getElementById('logout-confirm').addEventListener('click', () => {
                            overlay.style.display = 'none';
                            resolve(true);
                        }, { once: true });
                        document.getElementById('logout-cancel').addEventListener('click', () => {
                            overlay.style.display = 'none';
                            resolve(false);
                        }, { once: true });
                    });

                    if (!confirmed) return;
                } else {
                    // 変更がない場合もオーバーレイで確認
                    const overlay = document.getElementById('apply-changes-overlay');
                    const container = document.getElementById('apply-changes-container');
                    const content = document.getElementById('apply-changes-content');
                    if (overlay && container && content) {
                        content.innerHTML = `
                        <div>
                            <h3 style="margin-top: 0; font-size: 1.6vh; color: #ff8800;">管理モードからログアウトしますか？</h3>
                            <div style="font-size: 1.2vh; color: #aaa; margin-bottom: 1vh;">未適用の変更は失われます。</div>
                            <div style="display: flex; gap: 1vh; justify-content: flex-end;">
                                <button class="control-button" id="logout-confirm-no-changes" style="background-color: #f87171; color: white;">ログアウト</button>
                                <button class="control-button" id="logout-cancel-no-changes" style="background-color: #4a5a6a;">キャンセル</button>
                            </div>
                        </div>
                    `;
                        overlay.style.display = 'flex';

                        // オーバーレイをクリックで閉じる
                        overlay.addEventListener('click', (e) => {
                            if (e.target === overlay) {
                                overlay.style.display = 'none';
                            }
                        }, { once: true });

                        const confirmed = await new Promise((resolve) => {
                            document.getElementById('logout-confirm-no-changes').addEventListener('click', () => {
                                overlay.style.display = 'none';
                                resolve(true);
                            }, { once: true });
                            document.getElementById('logout-cancel-no-changes').addEventListener('click', () => {
                                overlay.style.display = 'none';
                                resolve(false);
                            }, { once: true });
                        });

                        if (!confirmed) return;
                    } else {
                        if (!confirm('管理モードからログアウトしますか？\n未適用の変更は失われます。')) {
                            return;
                        }
                    }
                }
            }

            try {
                await fetch('/api/admin/logout', { method: 'POST' });
                isAdminMode = false;
                pendingChanges = [];
                updateAdminUI();
            } catch (error) {
                console.error('ログアウトエラー:', error);
                const overlay = document.getElementById('apply-changes-overlay');
                const container = document.getElementById('apply-changes-container');
                const content = document.getElementById('apply-changes-content');
                if (overlay && container && content) {
                    content.innerHTML = `
                    <div>
                        <h3 style="margin-top: 0; font-size: 1.6vh; color: #f87171;">ログアウトに失敗しました</h3>
                        <div style="font-size: 1.2vh; color: #aaa; margin-bottom: 1vh;">${error.message || '不明なエラー'}</div>
                        <div style="display: flex; justify-content: flex-end;">
                            <button class="control-button" id="logout-error-close" style="background-color: #4a5a6a;">閉じる</button>
                        </div>
                    </div>
                `;
                    overlay.style.display = 'flex';

                    // オーバーレイをクリックで閉じる
                    overlay.addEventListener('click', (e) => {
                        if (e.target === overlay) {
                            overlay.style.display = 'none';
                        }
                    }, { once: true });

                    document.getElementById('logout-error-close').addEventListener('click', () => {
                        overlay.style.display = 'none';
                    }, { once: true });
                }
            }
        }

        /**
         * 管理モードUIの更新
         */
        function updateAdminUI() {
            const header = document.getElementById('main-header');
            const title = document.getElementById('header-title');
            const dictionaryBtn = document.querySelector('.header-dictionary-container');
            const scrapeContainer = document.querySelector('.header-scrape-container');
            const unregisteredTab = document.getElementById('unregistered-effects-tab');
            const body = document.body;

            if (isAdminMode) {
                header.classList.add('admin-mode');
                body.classList.add('admin-mode');
                title.textContent = pendingChanges.length > 0 ? `変更適応(${pendingChanges.length})` : 'エリジェネ';
                title.classList.toggle('has-changes', pendingChanges.length > 0);
                title.classList.toggle('disabled', pendingChanges.length === 0);
                if (dictionaryBtn) dictionaryBtn.style.display = 'flex';
                if (scrapeContainer) scrapeContainer.style.display = 'flex';
                if (unregisteredTab) unregisteredTab.style.display = '';
            } else {
                header.classList.remove('admin-mode');
                body.classList.remove('admin-mode');
                title.textContent = 'エリジェネ';
                title.classList.remove('has-changes', 'disabled');
                if (dictionaryBtn) dictionaryBtn.style.display = 'none';
                if (scrapeContainer) {
                    scrapeContainer.style.display = 'none';
                    scrapeContainer.classList.remove('active-menu');
                }
                if (unregisteredTab) unregisteredTab.style.display = 'none';
            }
            setScrapeMenu(false);

            // パーティスロットを再描画して管理ボタンの状態を更新
            renderAllParties();

            // 名前検索欄のプレースホルダーを更新
            const nameSearchInput = document.getElementById('name-search-input');
            if (nameSearchInput) {
                nameSearchInput.placeholder = isAdminMode ? 'エイリアン名・個性・特技で検索' : 'エイリアン名を入力';
            }

            // バフデバフ画面が開いている場合は再描画（使用数を反映）
            // 注意: renderEffectButtonsはローカル関数なので、ここでは直接呼び出せない
            // 必要に応じて、バフデバフ画面を開き直すか、イベントを発火する
        }
        /**
         * ターゲット選択モーダルのHTMLを生成（共通関数）
         */
        function createTargetSelectorHTML(selectedTargets, stringSelectCallback, codeSelectCallback, includeTypes = true, confirmCallback = 'window.confirmTargetSelection', cancelCallback = 'window.cleanupTempTargetFunctions') {
            const typeOptions = includeTypes ? `
            <div>
                <div style="font-size: 1.4vh; margin-bottom: 0.5vh;"><strong>タイプ (e):</strong></div>
                <div style="display: flex; flex-wrap: wrap; gap: 0.6vh;">
                    ${['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q'].map(v => `
                        <button type="button" onclick="${codeSelectCallback}('e', '${v}')" 
                                style="padding: 0.6vh; background-color: ${selectedTargets.includes(`e:${v}`) ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh;">
                            <img src="/static/icon/e${v}.webp" style="width: 3vh; height: 3vh;">
                        </button>
                    `).join('')}
                </div>
            </div>` : '';

            return `
            <div class="modal-content" style="max-height: 85vh; overflow-y: auto; width: 95vw; max-width: 70vh;">
                <h3 style="margin-top: 0; margin-bottom: 1vh; font-size: 1.6vh;">バフ/デバフ対象を選択</h3>
                <div style="margin-bottom: 1vh;">
                    <div style="font-size: 1.3vh; margin-bottom: 0.5vh; font-weight: bold;">文字列形式:</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 0.5vh;">
                        ${['自分', '味方全員', '敵全員', '敵単体'].map(str => `
                            <button type="button" onclick="${stringSelectCallback}('${str}')" 
                                    style="padding: 0.6vh 1.2vh; background-color: ${selectedTargets.includes(str) ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh; color: var(--light-text); font-size: 1.3vh;">
                                ${str}
                            </button>
                        `).join('')}
                    </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1vh; margin-bottom: 1vh;">
                    <div>
                        <div style="font-size: 1.3vh; margin-bottom: 0.5vh; font-weight: bold;">属性 (a):</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 0.5vh;">
                            ${[1, 2, 3, 4].map(v => `
                                <button type="button" onclick="${codeSelectCallback}('a', '${v}')" 
                                        style="padding: 0.5vh; background-color: ${selectedTargets.includes(`a:${v}`) ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh;">
                                    <img src="/static/icon/a${v}.webp" style="width: 2.5vh; height: 2.5vh;">
                                </button>
                            `).join('')}
                        </div>
                    </div>
                    <div>
                        <div style="font-size: 1.3vh; margin-bottom: 0.5vh; font-weight: bold;">所属 (b):</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 0.5vh;">
                            ${[1, 2, 3, 4, 5].map(v => `
                                <button type="button" onclick="${codeSelectCallback}('b', '${v}')" 
                                        style="padding: 0.5vh; background-color: ${selectedTargets.includes(`b:${v}`) ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh;">
                                    <img src="/static/icon/b${v}.webp" style="width: 2.5vh; height: 2.5vh;">
                                </button>
                            `).join('')}
                        </div>
                    </div>
                    <div>
                        <div style="font-size: 1.3vh; margin-bottom: 0.5vh; font-weight: bold;">攻撃はんい (c):</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 0.5vh;">
                            ${[1, 2].map(v => `
                                <button type="button" onclick="${codeSelectCallback}('c', '${v}')" 
                                        style="padding: 0.5vh; background-color: ${selectedTargets.includes(`c:${v}`) ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh;">
                                    <img src="/static/icon/c${v}.webp" style="width: 2.5vh; height: 2.5vh;">
                                </button>
                            `).join('')}
                        </div>
                    </div>
                    <div>
                        <div style="font-size: 1.3vh; margin-bottom: 0.5vh; font-weight: bold;">攻撃距離 (d):</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 0.5vh;">
                            ${[1, 2, 3].map(v => `
                                <button type="button" onclick="${codeSelectCallback}('d', '${v}')" 
                                        style="padding: 0.5vh; background-color: ${selectedTargets.includes(`d:${v}`) ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh;">
                                    <img src="/static/icon/d${v}.webp" style="width: 2.5vh; height: 2.5vh;">
                                </button>
                            `).join('')}
                        </div>
                    </div>
                    ${includeTypes ? `
                    <div style="grid-column: 1 / -1;">
                        <div style="font-size: 1.3vh; margin-bottom: 0.5vh; font-weight: bold;">タイプ (e):</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 0.5vh;">
                            ${['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q'].map(v => `
                                <button type="button" onclick="${codeSelectCallback}('e', '${v}')" 
                                        style="padding: 0.5vh; background-color: ${selectedTargets.includes(`e:${v}`) ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh;">
                                    <img src="/static/icon/e${v}.webp" style="width: 2.5vh; height: 2.5vh;">
                                </button>
                            `).join('')}
                        </div>
                    </div>` : ''}
                </div>
                <div style="display: flex; gap: 1vh; margin-top: 1vh; justify-content: flex-end; align-items: center; padding-top: 1vh; border-top: 1px solid #4a5a6a;">
                    <button class="control-button" onclick="${confirmCallback}(); this.closest('.modal-overlay').remove(); ${cancelCallback}();" style="padding: 0.8vh 2vh; font-size: 1.4vh; background-color: #ff8800; color: white; border: none; border-radius: 0.3vh; cursor: pointer;">決定</button>
                    <button class="control-button" onclick="this.closest('.modal-overlay').remove(); ${cancelCallback}();" style="padding: 0.8vh 2vh; font-size: 1.4vh; background-color: #4a5a6a; color: var(--light-text); border: none; border-radius: 0.3vh; cursor: pointer;">キャンセル</button>
                </div>
            </div>`;
        }
        /**
         * 不整合データをチェック（詳細情報付き）
         * @returns {Object|null} 不整合がある場合、{skillType, effectIndex, invalidFields} を返す。ない場合はnull
         */
        function checkInvalidDataDetailed(alienId, skillType, effectIndex) {
            if (!isAdminMode) return null;

            const alien = ALL_ALIENS[String(alienId)];
            if (!alien) return null;

            const validTargetStrings = new Set(['自分', '味方全員', '敵全員', '敵単体']);
            const validCodePatterns = {
                'a': ['1', '2', '3', '4'],
                'b': ['1', '2', '3', '4', '5'],
                'c': ['1', '2'],
                'd': ['1', '2', '3'],
                'e': ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q'],
                'boss': ['1'],
            };

            const alienEffects = ALIEN_EFFECTS[String(alienId)];
            if (!alienEffects) return null;

            const effects = alienEffects[skillType] || [];
            if (effectIndex !== undefined) {
                // 特定の効果をチェック
                const effect = effects[effectIndex];
                if (!effect) return null;

                const invalidFields = [];

                // effect_nameの検証（辞書に存在するか）
                const effectDict = skillType === 'S' ? S_SKILL_EFFECTS : ALL_EFFECTS;
                const matchingEffect = effectDict && effectDict.find(e => (e.correct_effect_names || e.effect_name) === effect.effect_name);

                if (!matchingEffect) {
                    // 効果名が辞書にない場合は不整合
                    invalidFields.push('effect_name');
                    // 効果名が辞書にない場合のみ、effect_typeとcategoryが空または無効な値なら不整合
                    if (!effect.effect_type || !['BUFF', 'DEBUFF', 'STATUS'].includes(effect.effect_type)) {
                        invalidFields.push('effect_type');
                    }
                    if (!effect.category) {
                        invalidFields.push('category');
                    }
                }
                // 効果名が辞書にある場合、effect_typeとcategoryは一意に決まるため、不整合チェックは不要
                // （効果名が決まれば、effect_typeとcategoryは自動的に決定される）

                // targetの検証
                if (effect.target) {
                    if (!validTargetStrings.has(effect.target)) {
                        const parts = effect.target.split(',');
                        for (const part of parts) {
                            const trimmed = part.trim();
                            if (!trimmed.includes(':')) {
                                invalidFields.push('target');
                                break;
                            }
                            const [cat, val] = trimmed.split(':');
                            if (!validCodePatterns[cat] || !validCodePatterns[cat].includes(val)) {
                                invalidFields.push('target');
                                break;
                            }
                        }
                    }
                }

                // condition_targetの検証
                if (effect.condition_target) {
                    const parts = effect.condition_target.split(',');
                    for (const part of parts) {
                        const trimmed = part.trim();
                        if (!trimmed.includes(':')) {
                            invalidFields.push('condition_target');
                            break;
                        }
                        const [cat, val] = trimmed.split(':');
                        if (!validCodePatterns[cat] || !validCodePatterns[cat].includes(val)) {
                            invalidFields.push('condition_target');
                            break;
                        }
                    }
                }

                if (invalidFields.length > 0) {
                    return { skillType, effectIndex, invalidFields };
                }
            } else {
                // 全ての効果をチェック
                for (let i = 0; i < effects.length; i++) {
                    const result = checkInvalidDataDetailed(alienId, skillType, i);
                    if (result) return result;
                }
            }

            return null;
        }

        function checkInvalidData(alienId) {
            if (!isAdminMode) return false;

            const alien = ALL_ALIENS[String(alienId)];
            if (!alien) return false;

            // 有効なtarget値（文字列形式）
            const validTargetStrings = new Set(['自分', '味方全員', '敵全員', '敵単体']);

            // 有効なコード形式のパターン
            const validCodePatterns = {
                'a': ['1', '2', '3', '4'],
                'b': ['1', '2', '3', '4', '5'],
                'c': ['1', '2'],
                'd': ['1', '2', '3'],
                'e': ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q'],
                'boss': ['1'],
            };

            // エイリアンの個性1-3と特技をチェック
            const skillTexts = [
                alien.skill_text1,
                alien.skill_text2,
                alien.skill_text3,
                alien.s_skill_text
            ].filter(text => text && text !== 'なし');

            // このエイリアンの効果データを取得（ALIEN_EFFECTSから）
            const alienEffects = ALIEN_EFFECTS[String(alienId)];
            if (!alienEffects) return false;

            // 全ての効果をチェック
            for (const skillType of ['1', '2', '3', 'S']) {
                const effects = alienEffects[skillType] || [];
                for (const effect of effects) {
                    // targetの検証
                    if (effect.target) {
                        if (!validTargetStrings.has(effect.target)) {
                            // コード形式のチェック
                            const parts = effect.target.split(',');
                            for (const part of parts) {
                                const trimmed = part.trim();
                                if (!trimmed.includes(':')) return true;
                                const [cat, val] = trimmed.split(':');
                                if (!validCodePatterns[cat] || !validCodePatterns[cat].includes(val)) {
                                    return true;
                                }
                            }
                        }
                        // 有効な文字列形式の場合は問題なし
                    }

                    // condition_targetの検証（コード形式のみ）
                    if (effect.condition_target) {
                        const parts = effect.condition_target.split(',');
                        for (const part of parts) {
                            const trimmed = part.trim();
                            if (!trimmed.includes(':')) return true;
                            const [cat, val] = trimmed.split(':');
                            if (!validCodePatterns[cat] || !validCodePatterns[cat].includes(val)) {
                                return true;
                            }
                        }
                    }
                }
            }

            return false;
        }

        /**
         * 未登録効果を表示
         */
        function renderUnregisteredEffects(container, effects) {
            if (!effects || effects.length === 0) {
                container.innerHTML = '<p>未登録効果はありません。</p>';
                return;
            }

            container.innerHTML = `
            <div style="margin-bottom: 1vh;">
                <strong>未登録効果一覧 (${effects.length}件)</strong>
            </div>
            ${effects.map(effect => `
                <div class="effect-item" style="border: 1px solid #ff8800; padding: 1vh; margin-bottom: 1vh; border-radius: 0.5vh;">
                    <div><strong>${effect.effect_name}</strong></div>
                    <div style="font-size: 1.2vh; color: #aaa;">使用件数: ${effect.usage_count}</div>
                    <div style="font-size: 1.2vh; color: #aaa;">使用skill_text数: ${effect.skill_texts ? effect.skill_texts.length : 0}</div>
                    <button class="control-button" onclick="openDictionaryModal('${effect.effect_name.replace(/'/g, "\\'")}')" style="margin-top: 0.5vh;">辞書管理で管理</button>
                </div>
            `).join('')}
        `;
        }
        /**
         * 辞書管理モーダルを開く
         */
        window.openDictionaryModal = async function (selectedEffectName = '') {
            if (!isAdminMode) return;

            // モーダルのHTMLを生成
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.style.display = 'flex';
            modal.innerHTML = `
            <div class="modal-content" style="max-height: 90vh; overflow-y: auto; width: 90vw; max-width: 70vh;">
                <h2 style="margin-top: 0;">辞書管理</h2>
                <div style="margin-bottom: 1vh;">
                    <div style="display: flex; gap: 1vh;">
                        <button class="control-button dictionary-tab active" data-tab="personality">個性</button>
                        <button class="control-button dictionary-tab" data-tab="special">特技</button>
                        <button class="control-button dictionary-tab" data-tab="unregistered">未登録</button>
                    </div>
                </div>
                <div id="dictionary-content">
                    <p>読み込み中...</p>
                </div>
                <button class="control-button" style="margin-top: 1vh;" onclick="this.closest('.modal-overlay').remove()">閉じる</button>
            </div>
        `;

            document.body.appendChild(modal);

            // タブ切り替え
            let currentTab = 'personality';
            const loadContent = () => {
                if (currentTab === 'unregistered') {
                    loadUnregisteredContent(modal);
                } else {
                    loadDictionaryContent(modal, currentTab, selectedEffectName);
                }
            };

            // タブに応じた追加ボタンの表示を管理
            const updateAddButton = () => {
                let addButton = modal.querySelector('.dictionary-add-button');
                if (!addButton) {
                    addButton = document.createElement('button');
                    addButton.className = 'control-button dictionary-add-button';
                    addButton.style.marginTop = '1vh';
                    addButton.style.marginBottom = '1vh';
                    const contentDiv = modal.querySelector('#dictionary-content');
                    contentDiv.parentNode.insertBefore(addButton, contentDiv);
                }
                if (currentTab === 'unregistered') {
                    addButton.style.display = 'none';
                } else {
                    addButton.style.display = 'block';
                    addButton.textContent = '効果を追加';
                    addButton.onclick = () => {
                        window.addDictionaryEntry(currentTab === 'special' ? 'special' : 'personality');
                    };
                }
            };

            modal.querySelectorAll('.dictionary-tab').forEach(btn => {
                btn.addEventListener('click', () => {
                    modal.querySelectorAll('.dictionary-tab').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentTab = btn.dataset.tab;
                    updateAddButton();
                    loadContent();
                });
            });

            // 初期表示
            updateAddButton();
            await loadContent();

            // モーダル外クリックで閉じる
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        };

        /**
         * 辞書管理モーダルのコンテンツを読み込む
         */
        async function loadDictionaryContent(modal, tabType, selectedEffectName = '') {
            const content = modal.querySelector('#dictionary-content');
            content.innerHTML = '<p>読み込み中...</p>';

            try {
                // 辞書データを取得
                const effects = tabType === 'special' ? S_SKILL_EFFECTS : ALL_EFFECTS;

                if (!effects || effects.length === 0) {
                    content.innerHTML = '<p>辞書データがありません。</p>';
                    return;
                }

                // 効果をeffect_typeとcategoryでグループ化
                const grouped = {};
                effects.forEach(effect => {
                    const key = `${effect.effect_type || 'UNKNOWN'}_${effect.category || 'UNKNOWN'}`;
                    if (!grouped[key]) {
                        grouped[key] = {
                            effect_type: effect.effect_type,
                            category: effect.category,
                            effects: []
                        };
                    }
                    grouped[key].effects.push(effect);
                });

                // 表示用HTMLを生成
                let html = '';
                if (selectedEffectName) {
                    html += `<div style="background-color: #ff8800; padding: 1vh; border-radius: 0.5vh; margin-bottom: 1vh;">
                    <strong>選択中の効果: ${selectedEffectName}</strong>
                </div>`;
                }

                Object.values(grouped).forEach(group => {
                    const effectTypeDisplay = group.effect_type ? getEffectTypeDisplayName(group.effect_type) : '(なし)';
                    const categoryDisplay = group.category ? getCategoryDisplayName(group.category, group.effect_type) : '(なし)';
                    html += `<div style="border: 1px solid #4a5a6a; padding: 1vh; margin-bottom: 1vh; border-radius: 0.5vh;">
                    <div style="font-weight: bold; margin-bottom: 0.5vh;">${effectTypeDisplay} / ${categoryDisplay}</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 0.5vh;">
                        ${group.effects.map(e => {
                        const isSelected = e.correct_effect_names === selectedEffectName;
                        const usageCount = isAdminMode && effectUsageStats[e.correct_effect_names] ? ` (${effectUsageStats[e.correct_effect_names]})` : '';
                        return `<div style="background-color: ${isSelected ? '#ff8800' : '#1a2a3a'}; padding: 0.3vh 0.6vh; border-radius: 0.3vh; font-size: 1.2vh; cursor: pointer;" 
                                     onclick="window.selectDictionaryEffect('${e.correct_effect_names.replace(/'/g, "\\'")}')"
                                     title="${e.correct_effect_names}">${e.correct_effect_names}${usageCount}</div>`;
                    }).join('')}
                    </div>
                </div>`;
                });

                content.innerHTML = html;
            } catch (error) {
                console.error('辞書データ読み込みエラー:', error);
                content.innerHTML = '<p>辞書データの読み込みに失敗しました。</p>';
            }
        };
        /**
         * 辞書で効果を選択
         */
        window.selectDictionaryEffect = async function (effectName) {
            // 効果名の詳細情報を取得して表示/非表示制御モーダルを表示
            try {
                // 効果名の詳細情報を取得（個性用と特技用の両方を確認）
                let effectInfo = null;
                let category = null;

                // 個性用から検索
                const personalityEffect = ALL_EFFECTS.find(e => e.correct_effect_names === effectName);
                if (personalityEffect) {
                    effectInfo = personalityEffect;
                    category = personalityEffect.category;
                } else {
                    // 特技用から検索
                    const specialEffect = S_SKILL_EFFECTS.find(e => e.correct_effect_names === effectName);
                    if (specialEffect) {
                        effectInfo = specialEffect;
                        category = specialEffect.category;
                    }
                }

                if (!effectInfo) {
                    // 効果名が見つからない場合は置換モーダルを開く
                    openEffectReplaceModal(effectName);
                    return;
                }

                const showTargetFlag = effectInfo.show_target !== false;
                const showConditionTargetFlag = effectInfo.show_condition_target !== false;
                const targetDescription = showTargetFlag ? (effectInfo.target || '(なし)') : '（表示しない設定）';
                const conditionDescription = showConditionTargetFlag ? (effectInfo.condition_target || '(なし)') : '（表示しない設定）';

                // 表示/非表示制御モーダルを表示
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.style.display = 'flex';
                modal.innerHTML = `
                <div class="modal-content" style="max-height: 90vh; overflow-y: auto; width: 90vw; max-width: 50vh;">
                    <h2 style="margin-top: 0;">効果名の詳細設定</h2>
                    <div style="margin-bottom: 1vh;">
                        <strong>効果名:</strong> ${effectName}
                    </div>
                    <div style="margin-bottom: 1vh;">
                        <strong>分類:</strong> ${effectInfo.effect_type || '(なし)'}
                    </div>
                    <div style="margin-bottom: 1vh;">
                        <strong>カテゴリ:</strong> ${category || '(なし)'}
                    </div>
                    <div style="margin-bottom: 1vh;">
                        <strong>バフ/デバフ対象:</strong> ${targetDescription}
                    </div>
                    <div style="margin-bottom: 1vh;">
                        <strong>効果対象:</strong> ${conditionDescription}
                    </div>
                    <div style="margin-bottom: 1vh; padding: 1vh; background-color: #1a2a3a; border-radius: 0.3vh;">
                        <label style="display: flex; align-items: center; margin-bottom: 0.5vh;">
                            <input type="checkbox" id="show-target-checkbox" ${showTargetFlag ? 'checked' : ''} style="margin-right: 0.5vh;">
                            <strong>バフ/デバフ対象を表示する</strong>
                        </label>
                        <label style="display: flex; align-items: center;">
                            <input type="checkbox" id="show-condition-target-checkbox" ${showConditionTargetFlag ? 'checked' : ''} style="margin-right: 0.5vh;">
                            <strong>効果対象を表示する</strong>
                        </label>
                    </div>
                    <div style="display: flex; gap: 1vh; margin-top: 1.5vh;">
                        <button type="button" class="control-button" onclick="this.closest('.modal-overlay').remove()" style="flex: 1;">キャンセル</button>
                        <button type="button" class="control-button" id="update-show-flags-btn" style="flex: 1; background-color: var(--accent-green); color: var(--dark-bg);">更新</button>
                    </div>
                </div>
            `;

                document.body.appendChild(modal);

                modal.querySelector('#update-show-flags-btn').addEventListener('click', async () => {
                    const showTarget = modal.querySelector('#show-target-checkbox').checked;
                    const showConditionTarget = modal.querySelector('#show-condition-target-checkbox').checked;

                    try {
                        // categoryがnullの場合はエラー
                        if (category === null || category === undefined) {
                            alert('カテゴリが取得できませんでした。効果名を再度確認してください。');
                            return;
                        }

                        const response = await fetch('/api/admin/dictionary/update-show-flags', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                effect_name: effectName,
                                category: category,
                                show_target: showTarget,
                                show_condition_target: showConditionTarget
                            })
                        });
                        const data = await response.json();

                        if (data.success) {
                            // pendingChangesに追加（変更適応ボタンで適用）
                            addPendingChange({
                                type: 'dictionary_update',
                                effect_name: effectName,
                                category: category,
                                show_target: showTarget,
                                show_condition_target: showConditionTarget
                            });

                            // UIで成功メッセージを表示
                            const overlay = document.getElementById('apply-changes-overlay');
                            const container = document.getElementById('apply-changes-container');
                            const content = document.getElementById('apply-changes-content');
                            if (overlay && container && content) {
                                content.innerHTML = `
                                <div>
                                    <h3 style="margin-top: 0; font-size: 1.6vh; color: #4ade80;">表示設定の変更を保存しました</h3>
                                    <div style="font-size: 1.2vh; color: #aaa; margin-bottom: 1vh;">変更を適用ボタンで適用してください。</div>
                                    <div style="display: flex; justify-content: flex-end;">
                                        <button class="control-button" id="dict-update-close" style="background-color: #4a5a6a;">閉じる</button>
                                    </div>
                                </div>
                            `;
                                overlay.style.display = 'flex';

                                document.getElementById('dict-update-close').addEventListener('click', () => {
                                    overlay.style.display = 'none';
                                    modal.remove();
                                    updateAdminUI(); // pendingChangesの表示を更新
                                }, { once: true });
                            } else {
                                alert('表示設定の変更を保存しました。変更を適用ボタンで適用してください。');
                                modal.remove();
                                updateAdminUI(); // pendingChangesの表示を更新
                            }
                        } else {
                            // エラー時もUIで表示
                            const overlay = document.getElementById('apply-changes-overlay');
                            const container = document.getElementById('apply-changes-container');
                            const content = document.getElementById('apply-changes-content');
                            if (overlay && container && content) {
                                content.innerHTML = `
                                <div>
                                    <h3 style="margin-top: 0; font-size: 1.6vh; color: #f87171;">更新に失敗しました</h3>
                                    <div style="font-size: 1.2vh; color: #aaa; margin-bottom: 1vh;">${data.error || '不明なエラー'}</div>
                                    <div style="display: flex; justify-content: flex-end;">
                                        <button class="control-button" id="dict-update-error-close" style="background-color: #4a5a6a;">閉じる</button>
                                    </div>
                                </div>
                            `;
                                overlay.style.display = 'flex';

                                document.getElementById('dict-update-error-close').addEventListener('click', () => {
                                    overlay.style.display = 'none';
                                }, { once: true });
                            } else {
                                alert(`更新に失敗しました: ${data.error}`);
                            }
                        }
                    } catch (error) {
                        console.error('表示設定更新エラー:', error);
                        // エラー時もUIで表示
                        const overlay = document.getElementById('apply-changes-overlay');
                        const container = document.getElementById('apply-changes-container');
                        const content = document.getElementById('apply-changes-content');
                        if (overlay && container && content) {
                            content.innerHTML = `
                            <div>
                                <h3 style="margin-top: 0; font-size: 1.6vh; color: #f87171;">表示設定の更新に失敗しました</h3>
                                <div style="font-size: 1.2vh; color: #aaa; margin-bottom: 1vh;">${error.message || '不明なエラー'}</div>
                                <div style="display: flex; justify-content: flex-end;">
                                    <button class="control-button" id="dict-update-error-close2" style="background-color: #4a5a6a;">閉じる</button>
                                </div>
                            </div>
                        `;
                            overlay.style.display = 'flex';

                            document.getElementById('dict-update-error-close2').addEventListener('click', () => {
                                overlay.style.display = 'none';
                            }, { once: true });
                        } else {
                            alert('表示設定の更新に失敗しました');
                        }
                    }
                });

                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            } catch (error) {
                console.error('効果名選択エラー:', error);
                // エラー時は置換モーダルを開く
                openEffectReplaceModal(effectName);
            }
        };
        /**
         * 効果置換モーダルを開く
         */
        async function openEffectReplaceModal(newEffectName) {
            try {
                const response = await fetch('/api/admin/get-unregistered');
                const data = await response.json();

                if (!data.success) {
                    alert('未登録効果の取得に失敗しました');
                    return;
                }

                // 未登録効果がない場合は、効果名の詳細情報を表示
                if (!data.effects || data.effects.length === 0) {
                    const detailModal = document.createElement('div');
                    detailModal.className = 'modal-overlay';
                    detailModal.style.display = 'flex';
                    detailModal.innerHTML = `
                    <div class="modal-content" style="max-height: 90vh; overflow-y: auto; width: 90vw; max-width: 50vh;">
                        <h2 style="margin-top: 0;">効果名の詳細情報</h2>
                        <div style="margin-bottom: 1vh;">
                            <strong>効果名:</strong> ${newEffectName}
                        </div>
                        <div style="margin-bottom: 1vh;">
                            <p>この効果名に置換できる未登録効果はありません。</p>
                            <p style="font-size: 1.2vh; color: #aaa; margin-top: 0.5vh;">
                                全ての効果が既に辞書に登録されているか、未登録効果が存在しません。
                            </p>
                        </div>
                        <button class="control-button" onclick="this.closest('.modal-overlay').remove()" style="margin-top: 1vh;">閉じる</button>
                    </div>
                `;
                    document.body.appendChild(detailModal);
                    detailModal.addEventListener('click', (e) => {
                        if (e.target === detailModal) {
                            detailModal.remove();
                        }
                    });
                    return;
                }

                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.style.display = 'flex';
                modal.innerHTML = `
                <div class="modal-content" style="max-height: 90vh; overflow-y: auto; width: 90vw; max-width: 60vh;">
                    <h2 style="margin-top: 0;">効果名の置換</h2>
                    <div style="margin-bottom: 1vh;">
                        <strong>新しい効果名:</strong> ${newEffectName}
                    </div>
                    <div style="margin-bottom: 1vh;">
                        <strong>置換対象の効果名を選択:</strong>
                    </div>
                    <div id="replace-target-list" style="max-height: 50vh; overflow-y: auto;">
                    </div>
                    <div style="display: flex; gap: 1vh; margin-top: 1vh;">
                        <button class="control-button" onclick="this.closest('.modal-overlay').remove()" style="flex: 1;">キャンセル</button>
                        <button class="control-button" id="replace-submit-btn" style="flex: 1; background-color: var(--accent-green); color: var(--dark-bg);" disabled>置換</button>
                    </div>
                </div>
            `;

                document.body.appendChild(modal);

                const targetList = modal.querySelector('#replace-target-list');
                const selectedTargets = new Set();
                const skillTextsMap = new Map();

                targetList.innerHTML = data.effects.map(effect => `
                <label style="display: block; padding: 0.5vh; margin-bottom: 0.5vh; background-color: #1a2a3a; border-radius: 0.3vh; cursor: pointer;">
                    <input type="checkbox" class="replace-target-checkbox" value="${effect.effect_name}" 
                           data-skill-texts='${JSON.stringify(effect.skill_texts || [])}'
                           style="margin-right: 0.5vh;">
                    <strong>${effect.effect_name}</strong>
                    <div style="font-size: 1.2vh; color: #aaa;">使用: ${effect.usage_count}件</div>
                </label>
            `).join('');

                targetList.querySelectorAll('.replace-target-checkbox').forEach(cb => {
                    cb.addEventListener('change', () => {
                        const effectName = cb.value;
                        if (cb.checked) {
                            selectedTargets.add(effectName);
                            const skillTexts = JSON.parse(cb.dataset.skillTexts || '[]');
                            skillTextsMap.set(effectName, skillTexts);
                        } else {
                            selectedTargets.delete(effectName);
                            skillTextsMap.delete(effectName);
                        }
                        modal.querySelector('#replace-submit-btn').disabled = selectedTargets.size === 0;
                    });
                });

                modal.querySelector('#replace-submit-btn').addEventListener('click', async () => {
                    if (selectedTargets.size === 0) return;

                    const confirmMsg = `以下の効果を "${newEffectName}" に置換しますか？\n\n${Array.from(selectedTargets).join('\n')}`;
                    if (!confirm(confirmMsg)) return;

                    let totalUpdated = 0;
                    for (const oldEffectName of selectedTargets) {
                        const skillTexts = skillTextsMap.get(oldEffectName) || [];
                        try {
                            const response = await fetch('/api/admin/dictionary/mass-update', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    old_effect_name: oldEffectName,
                                    new_effect_name: newEffectName,
                                    skill_texts: skillTexts
                                })
                            });
                            const data = await response.json();
                            if (data.success) {
                                totalUpdated += data.updated_count || 0;
                            }
                        } catch (error) {
                            console.error(`置換エラー (${oldEffectName}):`, error);
                        }
                    }

                    alert(`${totalUpdated}件の置換が完了しました。ページをリロードします。`);
                    modal.remove();
                    location.reload();
                });

                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            } catch (error) {
                console.error('置換モーダル開くエラー:', error);
                alert('置換モーダルの表示に失敗しました');
            }
        };
        /**
         * 辞書に新規効果を追加
         */
        window.addDictionaryEntry = function (tabType = 'personality') {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.style.display = 'flex';
            modal.innerHTML = `
            <div class="modal-content" style="max-height: 90vh; overflow-y: auto; width: 90vw; max-width: 50vh;">
                <h2 style="margin-top: 0;">新規効果を辞書に追加</h2>
                <form id="dictionary-add-form">
                    <div style="margin-bottom: 1vh;">
                        <label style="display: block; margin-bottom: 0.5vh;"><strong>効果名 *</strong></label>
                        <input type="text" id="dict-effect-name-input" 
                               style="width: 100%; padding: 0.5vh; background-color: #1a2a3a; border: 1px solid #4a5a6a; border-radius: 0.3vh; color: var(--light-text);" 
                               placeholder="効果名を入力" required>
                    </div>
                    <div style="margin-bottom: 1vh;">
                        <label style="display: block; margin-bottom: 0.5vh;"><strong>分類 / カテゴリ *</strong></label>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1vh;">
                            <select id="dict-effect-type-select" 
                                    style="width: 100%; padding: 0.5vh; background-color: #1a2a3a; border: 1px solid #4a5a6a; border-radius: 0.3vh; color: var(--light-text);" required>
                                <option value="">分類を選択</option>
                            </select>
                            <select id="dict-category-select" 
                                    style="width: 100%; padding: 0.5vh; background-color: #1a2a3a; border: 1px solid #4a5a6a; border-radius: 0.3vh; color: var(--light-text);" required disabled>
                                <option value="">カテゴリを選択</option>
                            </select>
                        </div>
                    </div>
                    <div style="margin-bottom: 1vh;">
                        <label style="display: flex; align-items: center; margin-bottom: 0.5vh;">
                            <input type="checkbox" id="dict-show-target-checkbox" checked style="margin-right: 0.5vh;">
                            <strong>バフ/デバフ対象を表示する</strong>
                        </label>
                    </div>
                    <div style="margin-bottom: 1vh;">
                        <label style="display: flex; align-items: center; margin-bottom: 0.5vh;">
                            <input type="checkbox" id="dict-show-condition-target-checkbox" checked style="margin-right: 0.5vh;">
                            <strong>効果対象を表示する</strong>
                        </label>
                    </div>
                    <div style="display: flex; gap: 1vh; margin-top: 1.5vh;">
                        <button type="button" class="control-button" onclick="this.closest('.modal-overlay').remove()" style="flex: 1;">キャンセル</button>
                        <button type="submit" class="control-button" style="flex: 1; background-color: var(--accent-green); color: var(--dark-bg);">追加</button>
                    </div>
                </form>
            </div>
        `;

            document.body.appendChild(modal);

            // ターゲット選択機能は削除済み（不要なため）

            // effect_typeとcategoryのドロップダウンを設定
            const effectTypeSelect = modal.querySelector('#dict-effect-type-select');
            const categorySelect = modal.querySelector('#dict-category-select');

            // 個性用と特技用で異なる選択肢を設定
            const isSpecial = tabType === 'special';

            if (isSpecial) {
                // 特技用: effect_typeは選択不要（categoryで判定）
                effectTypeSelect.innerHTML = '<option value="">選択してください</option>';
                categorySelect.innerHTML = `
                <option value="">選択してください</option>
                <option value="S_SKILL_HEAL">S_SKILL_HEAL (回復系)</option>
                <option value="S_SKILL_BUFF">S_SKILL_BUFF (バフ系)</option>
                <option value="S_SKILL_DEBUFF">S_SKILL_DEBUFF (デバフ(状態異常)系)</option>
            `;
                effectTypeSelect.disabled = true;
                categorySelect.disabled = false;
                // 特技用の場合、effect_typeはcategoryから自動判定
                categorySelect.addEventListener('change', () => {
                    const category = categorySelect.value;
                    if (category === 'S_SKILL_HEAL') {
                        effectTypeSelect.value = 'BUFF';
                    } else if (category === 'S_SKILL_BUFF') {
                        effectTypeSelect.value = 'BUFF';
                    } else if (category === 'S_SKILL_DEBUFF') {
                        effectTypeSelect.value = 'STATUS';
                    }
                });
            } else {
                // 個性用: effect_typeとcategoryの組み合わせ
                effectTypeSelect.innerHTML = `
                <option value="">選択してください</option>
                <option value="BUFF">BUFF (バフ)</option>
                <option value="DEBUFF">DEBUFF (デバフ)</option>
                <option value="STATUS">STATUS (状態異常)</option>
            `;
                effectTypeSelect.disabled = false;
                categorySelect.disabled = true;

                // effect_typeが変更されたらcategoryの選択肢を更新し、効果対象の表示を制御
                const updateCategoryOptions = () => {
                    const effectType = effectTypeSelect.value;
                    categorySelect.innerHTML = '<option value="">選択してください</option>';
                    categorySelect.disabled = !effectType;

                    if (effectType === 'BUFF') {
                        categorySelect.innerHTML += `
                        <option value="BUFF_BOOST">BUFF_BOOST (アップ系)</option>
                        <option value="BUFF_REDUCE">BUFF_REDUCE (軽減系)</option>
                        <option value="BUFF_RESIST">BUFF_RESIST (抵抗系)</option>
                        <option value="BUFF_OTHER">BUFF_OTHER (その他バフ)</option>
                    `;
                    } else if (effectType === 'DEBUFF') {
                        categorySelect.innerHTML += `
                        <option value="DEBUFF_DOWN">DEBUFF_DOWN (ダウン系)</option>
                        <option value="DEBUFF_REDUCE">DEBUFF_REDUCE (ダウン系)</option>
                        <option value="DEBUFF_OTHER">DEBUFF_OTHER (その他デバフ)</option>
                    `;
                    } else if (effectType === 'STATUS') {
                        categorySelect.innerHTML += `
                        <option value="STATUS_POISON">STATUS_POISON (毒系)</option>
                        <option value="STATUS_STUN">STATUS_STUN (気絶系)</option>
                        <option value="STATUS_OTHER">STATUS_OTHER (その他状態異常)</option>
                    `;
                    }

                    // デバフ系の場合は効果対象を非表示
                    const conditionTargetContainer = modal.querySelector('#dict-condition-target-container');
                    if (effectType === 'DEBUFF') {
                        conditionTargetContainer.style.display = 'none';
                    } else {
                        conditionTargetContainer.style.display = 'block';
                    }
                };

                effectTypeSelect.addEventListener('change', updateCategoryOptions);

                // categoryが変更されたときも効果対象の表示を確認
                categorySelect.addEventListener('change', () => {
                    const effectType = effectTypeSelect.value;
                    if (effectType === 'DEBUFF') {
                        const conditionTargetContainer = modal.querySelector('#dict-condition-target-container');
                        conditionTargetContainer.style.display = 'none';
                    }
                });
            }

            modal.querySelector('#dictionary-add-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const effectName = modal.querySelector('#dict-effect-name-input').value.trim();
                const effectType = modal.querySelector('#dict-effect-type-select').value;
                const category = modal.querySelector('#dict-category-select').value;

                if (!effectName || !effectType || !category) {
                    alert('すべての項目を入力してください');
                    return;
                }

                const showTarget = modal.querySelector('#dict-show-target-checkbox').checked;
                const showConditionTarget = modal.querySelector('#dict-show-condition-target-checkbox').checked;

                try {
                    const response = await fetch('/api/admin/dictionary/add', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            effect_name: effectName,
                            effect_type: effectType,
                            category: category,
                            target: null,
                            condition_target: null,
                            show_target: showTarget,
                            show_condition_target: showConditionTarget
                        })
                    });
                    const data = await response.json();

                    if (data.success) {
                        alert('辞書に追加しました。ページをリロードします。');
                        modal.remove();
                        location.reload();
                    } else {
                        alert(`追加に失敗しました: ${data.error}`);
                    }
                } catch (error) {
                    console.error('辞書追加エラー:', error);
                    alert('辞書への追加に失敗しました');
                }
            });

            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        };

        /**
         * 未登録効果を辞書管理モーダルで表示
         */
        async function loadUnregisteredContent(modal) {
            const content = modal.querySelector('#dictionary-content');
            content.innerHTML = '<p>読み込み中...</p>';

            try {
                const response = await fetch('/api/admin/get-unregistered');
                const data = await response.json();

                if (!data.success || !data.effects || data.effects.length === 0) {
                    content.innerHTML = '<p>未登録効果がありません。</p>';
                    return;
                }

                content.innerHTML = `
                <div style="margin-bottom: 1vh;">
                    <strong>未登録効果一覧 (${data.effects.length}件)</strong>
                </div>
                ${data.effects.map(effect => `
                    <div style="border: 1px solid #ff8800; padding: 1vh; margin-bottom: 1vh; border-radius: 0.5vh;">
                        <div><strong>${effect.effect_name}</strong></div>
                        <div style="font-size: 1.2vh; color: #aaa; margin-top: 0.3vh;">
                            使用件数: ${effect.usage_count}<br>
                            使用skill_text数: ${effect.skill_texts ? effect.skill_texts.length : 0}
                        </div>
                        <button class="control-button" onclick="window.selectDictionaryEffect('${effect.effect_name.replace(/'/g, "\\'")}')" 
                                style="margin-top: 0.5vh;">この効果名に置換</button>
                    </div>
                `).join('')}
            `;
            } catch (error) {
                console.error('未登録効果表示エラー:', error);
                content.innerHTML = '<p>未登録効果の取得に失敗しました。</p>';
            }
        }

        /**
         * 未登録効果を辞書管理モーダルで表示（旧関数、後方互換性のため残す）
         */
        window.showUnregisteredInDictionary = async function () {
            try {
                const response = await fetch('/api/admin/get-unregistered');
                const data = await response.json();

                if (!data.success || !data.effects || data.effects.length === 0) {
                    alert('未登録効果がありません');
                    return;
                }

                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.style.display = 'flex';
                modal.innerHTML = `
                <div class="modal-content" style="max-height: 90vh; overflow-y: auto; width: 90vw; max-width: 60vh;">
                    <h2 style="margin-top: 0;">未登録効果一覧 (${data.effects.length}件)</h2>
                    <div id="unregistered-list" style="max-height: 70vh; overflow-y: auto;">
                        ${data.effects.map(effect => `
                            <div style="border: 1px solid #ff8800; padding: 1vh; margin-bottom: 1vh; border-radius: 0.5vh;">
                                <div><strong>${effect.effect_name}</strong></div>
                                <div style="font-size: 1.2vh; color: #aaa; margin-top: 0.3vh;">
                                    使用件数: ${effect.usage_count}<br>
                                    使用skill_text数: ${effect.skill_texts ? effect.skill_texts.length : 0}
                                </div>
                                <button class="control-button" onclick="window.selectDictionaryEffect('${effect.effect_name.replace(/'/g, "\\'")}')" 
                                        style="margin-top: 0.5vh;">この効果名に置換</button>
                            </div>
                        `).join('')}
                    </div>
                    <button class="control-button" style="margin-top: 1vh;" onclick="this.closest('.modal-overlay').remove()">閉じる</button>
                </div>
            `;

                document.body.appendChild(modal);

                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            } catch (error) {
                console.error('未登録効果表示エラー:', error);
                alert('未登録効果の表示に失敗しました');
            }
        };

        /**
         * 変更を追加
         */
        function addPendingChange(change) {
            // 同じ効果の変更がある場合は上書き（複数回編集しても最初と最後の差分だけ保持）
            if (change.type === 'update' || change.type === 'delete') {
                // 既存の変更を削除（同じskill_textとeffect_nameのもの）
                pendingChanges = pendingChanges.filter(c =>
                    !(c.skill_text === change.skill_text &&
                        c.effect_name === change.effect_name &&
                        (c.type === 'update' || c.type === 'delete'))
                );
            } else if (change.type === 'add') {
                // 追加の場合も、同じskill_textとeffect_nameがあれば削除（削除→追加の場合は追加に統一）
                pendingChanges = pendingChanges.filter(c =>
                    !(c.skill_text === change.skill_text &&
                        c.effect_name === change.effect_name &&
                        c.type === 'delete')
                );
            }

            pendingChanges.push(change);
            updateAdminUI();
        }
        /**
         * 変更を一括でDBに適用
         */
        async function applyChanges() {
            if (pendingChanges.length === 0) {
                alert('適用する変更がありません');
                return;
            }

            // 変更内容を確認UIで表示（オーバーレイ形式）
            const overlay = document.getElementById('apply-changes-overlay');
            const container = document.getElementById('apply-changes-container');
            const content = document.getElementById('apply-changes-content');
            if (!overlay || !container || !content) {
                // フォールバック: 確認ダイアログを使用
                const changeList = pendingChanges.map((c, i) => {
                    const typeMap = { add: '追加', update: '更新', delete: '削除' };
                    return `${i + 1}. ${typeMap[c.type]}: ${c.skill_text} - ${c.effect_name || '(新規)'}`;
                }).join('\n');
                if (!confirm(`以下の変更を適用しますか？\n\n${changeList}`)) {
                    return;
                }
                await applyChangesInternal();
            } else {
                // UIで確認メッセージを表示
                const typeMap = { add: '追加', update: '更新', delete: '削除', dictionary_update: '辞書更新' };
                const changeList = pendingChanges.map((c, i) => {
                    if (c.type === 'dictionary_update') {
                        return `<div style="font-size: 1.3vh; margin-bottom: 0.3vh;">${i + 1}. ${typeMap[c.type]}: ${c.effect_name || '(新規)'}</div>`;
                    }
                    return `<div style="font-size: 1.3vh; margin-bottom: 0.3vh;">${i + 1}. ${typeMap[c.type]}: ${c.skill_text} - ${c.effect_name || '(新規)'}</div>`;
                }).join('');

                content.innerHTML = `
                <div style="margin-bottom: 1vh;">
                    <h3 style="margin-top: 0; font-size: 1.6vh; color: #ff8800;">以下の変更を適用しますか？</h3>
                    <div style="max-height: 30vh; overflow-y: auto; margin-bottom: 1vh;">
                        ${changeList}
                    </div>
                    <div style="display: flex; gap: 1vh; justify-content: flex-end;">
                        <button class="control-button" id="apply-changes-confirm" style="background-color: #ff8800; color: white;">適用</button>
                        <button class="control-button" id="apply-changes-cancel">キャンセル</button>
                    </div>
                </div>
            `;
                overlay.style.display = 'flex';

                // オーバーレイをクリックで閉じる
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        overlay.style.display = 'none';
                    }
                }, { once: true });

                // 確認待ち
                const confirmed = await new Promise((resolve) => {
                    document.getElementById('apply-changes-confirm').addEventListener('click', () => {
                        overlay.style.display = 'none';
                        resolve(true);
                    }, { once: true });
                    document.getElementById('apply-changes-cancel').addEventListener('click', () => {
                        overlay.style.display = 'none';
                        resolve(false);
                    }, { once: true });
                });

                if (!confirmed) return;
                // 実際の適用処理を続行
                await applyChangesInternal();
            }
        }
        /**
         * 変更を実際に適用する（内部関数）
         */
        async function applyChangesInternal() {
            // dictionary_updateタイプを分離
            const skillChanges = pendingChanges.filter(c => c.type !== 'dictionary_update');
            const dictionaryUpdates = pendingChanges.filter(c => c.type === 'dictionary_update');

            try {
                // 辞書更新を先に処理
                for (const dictUpdate of dictionaryUpdates) {
                    try {
                        const response = await fetch('/api/admin/dictionary/update-show-flags', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                effect_name: dictUpdate.effect_name,
                                category: dictUpdate.category,
                                show_target: dictUpdate.show_target,
                                show_condition_target: dictUpdate.show_condition_target
                            })
                        });
                        const data = await response.json();
                        if (!data.success) {
                            throw new Error(data.error || '辞書更新に失敗しました');
                        }
                    } catch (error) {
                        console.error('辞書更新エラー:', error);
                        throw error;
                    }
                }

                // スキル変更を処理
                if (skillChanges.length === 0 && dictionaryUpdates.length > 0) {
                    // 辞書更新のみの場合
                    pendingChanges = [];
                    updateAdminUI();
                    return {
                        success: true,
                        applied_count: dictionaryUpdates.length,
                        change_details: dictionaryUpdates.map(d => ({
                            type: 'dictionary_update',
                            effect_name: d.effect_name,
                            success: true
                        }))
                    };
                }

                if (skillChanges.length === 0) {
                    pendingChanges = [];
                    updateAdminUI();
                    return { success: true, applied_count: 0, change_details: [] };
                }

                const response = await fetch('/api/admin/apply-changes', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ changes: skillChanges })
                });
                const data = await response.json();

                // 辞書更新の詳細も追加
                if (dictionaryUpdates.length > 0) {
                    if (!data.change_details) data.change_details = [];
                    dictionaryUpdates.forEach(d => {
                        data.change_details.push({
                            type: 'dictionary_update',
                            effect_name: d.effect_name,
                            success: true
                        });
                    });
                    data.applied_count = (data.applied_count || 0) + dictionaryUpdates.length;
                }

                const overlay = document.getElementById('apply-changes-overlay');
                const container = document.getElementById('apply-changes-container');
                const content = document.getElementById('apply-changes-content');

                if (data.success) {
                    // 成功メッセージをUI表示
                    if (overlay && container && content) {
                        const typeMap = { add: '追加', update: '更新', delete: '削除', dictionary_update: '辞書更新' };
                        const fieldMap = {
                            'effect_name': '効果名',
                            'effect_type': '分類',
                            'category': 'カテゴリ',
                            'target': 'バフ/デバフ対象',
                            'condition_target': '効果対象',
                            'has_requirement': '要求',
                            'requirement_details': '要求詳細',
                            'requirement_count': '要求数'
                        };

                        let detailHtml = '';
                        if (data.change_details && data.change_details.length > 0) {
                            data.change_details.forEach((detail, index) => {
                                const typeText = typeMap[detail.type] || detail.type;
                                const statusIcon = detail.success ? '✓' : '✗';
                                const statusColor = detail.success ? '#4ade80' : '#f87171';

                                detailHtml += `<div style="border: 1px solid #4a5a6a; padding: 0.8vh; margin-bottom: 0.5vh; border-radius: 0.3vh; background-color: #2a3a4a;">`;
                                detailHtml += `<div style="display: flex; align-items: center; gap: 0.5vh; margin-bottom: 0.3vh;">`;
                                detailHtml += `<span style="color: ${statusColor}; font-size: 1.3vh; font-weight: bold;">${statusIcon}</span>`;
                                if (detail.type === 'dictionary_update') {
                                    detailHtml += `<span style="font-size: 1.3vh;">${index + 1}. ${typeText}: ${detail.effect_name || 'N/A'}</span>`;
                                } else {
                                    detailHtml += `<span style="font-size: 1.3vh;">${index + 1}. ${typeText}: ${detail.skill_text || 'N/A'} - ${detail.effect_name || detail.new_effect_name || 'N/A'}</span>`;
                                }
                                detailHtml += `</div>`;

                                // 変更フィールドの表示を非表示（判定が正確でないため）
                                // if (detail.type === 'update' && detail.changed_fields && detail.changed_fields.length > 0) {
                                //     const changedFieldsText = detail.changed_fields.map(f => fieldMap[f] || f).join(', ');
                                //     detailHtml += `<div style="font-size: 1.1vh; color: #aaa; margin-left: 2vh;">変更: ${changedFieldsText}</div>`;
                                // }

                                if (!detail.success && detail.error) {
                                    detailHtml += `<div style="color: #f87171; font-size: 1.1vh; margin-top: 0.3vh;">エラー: ${detail.error}</div>`;
                                }

                                detailHtml += `</div>`;
                            });
                        }

                        content.innerHTML = `
                        <div>
                            <h3 style="margin-top: 0; font-size: 1.6vh; color: #4ade80;">${data.applied_count}件の変更を適用しました</h3>
                            <div style="max-height: 40vh; overflow-y: auto; margin-bottom: 1vh;">
                                ${detailHtml || '<div style="font-size: 1.2vh; color: #aaa;">詳細情報がありません</div>'}
                            </div>
                            <div style="display: flex; gap: 1vh; justify-content: flex-end;">
                                <button class="control-button" id="apply-changes-continue" style="background-color: #ff8800; color: white;">管理を続ける</button>
                                <button class="control-button" id="apply-changes-finish" style="background-color: #4a5a6a;">管理を終了する</button>
                            </div>
                        </div>
                    `;
                        overlay.style.display = 'flex';

                        // オーバーレイをクリックで閉じないようにする（ボタンでのみ閉じる）
                        overlay.onclick = null;

                        document.getElementById('apply-changes-continue').addEventListener('click', () => {
                            overlay.style.display = 'none';
                            pendingChanges = [];
                            updateAdminUI();
                            // 管理モードを維持してリロード（ボタンを押した時点でリロード）
                            sessionStorage.setItem('adminModeAfterReload', 'true');
                            setTimeout(() => {
                                location.reload();
                            }, 100);
                        }, { once: true });

                        document.getElementById('apply-changes-finish').addEventListener('click', () => {
                            overlay.style.display = 'none';
                            pendingChanges = []; // すべての変更をクリア（skillChanges + dictionaryUpdates）
                            updateAdminUI();
                            // 通常のリロード（管理モード終了、ボタンを押した時点でリロード）
                            setTimeout(() => {
                                location.reload();
                            }, 100);
                        }, { once: true });
                    } else {
                        pendingChanges = [];
                        updateAdminUI();
                        // フォールバック時もリロード
                        setTimeout(() => {
                            location.reload();
                        }, 100);
                    }
                } else {
                    // エラーメッセージをUI表示
                    if (overlay && container && content) {
                        let errorDetailHtml = '';
                        if (data.change_details && data.change_details.length > 0) {
                            data.change_details.forEach((detail, index) => {
                                if (!detail.success) {
                                    errorDetailHtml += `<div style="border: 1px solid #f87171; padding: 0.8vh; margin-bottom: 0.5vh; border-radius: 0.3vh; background-color: #2a3a4a;">`;
                                    errorDetailHtml += `<div style="font-size: 1.3vh; color: #f87171;">${index + 1}. ${detail.skill_text || 'N/A'} - ${detail.effect_name || 'N/A'}</div>`;
                                    errorDetailHtml += `<div style="font-size: 1.1vh; color: #f87171; margin-top: 0.3vh;">エラー: ${detail.error || data.error}</div>`;
                                    errorDetailHtml += `</div>`;
                                }
                            });
                        }

                        content.innerHTML = `
                        <div>
                            <h3 style="margin-top: 0; font-size: 1.6vh; color: #f87171;">変更の適用に失敗しました</h3>
                            <div style="font-size: 1.2vh; color: #aaa; margin-bottom: 1vh;">${data.error || '不明なエラー'}</div>
                            ${errorDetailHtml ? `<div style="max-height: 40vh; overflow-y: auto; margin-bottom: 1vh;">${errorDetailHtml}</div>` : ''}
                            <div style="display: flex; justify-content: flex-end;">
                                <button class="control-button" id="apply-changes-error-close" style="background-color: #4a5a6a;">閉じる</button>
                            </div>
                        </div>
                    `;
                        overlay.style.display = 'flex';

                        // オーバーレイをクリックで閉じる
                        overlay.addEventListener('click', (e) => {
                            if (e.target === overlay) {
                                overlay.style.display = 'none';
                            }
                        }, { once: true });

                        document.getElementById('apply-changes-error-close').addEventListener('click', () => {
                            overlay.style.display = 'none';
                        }, { once: true });
                    } else {
                        alert(`変更の適用に失敗しました: ${data.error}`);
                    }
                }
            } catch (error) {
                console.error('変更適用エラー:', error);
                const overlay = document.getElementById('apply-changes-overlay');
                const container = document.getElementById('apply-changes-container');
                const content = document.getElementById('apply-changes-content');
                if (overlay && container && content) {
                    content.innerHTML = `
                    <div>
                        <h3 style="margin-top: 0; font-size: 1.6vh; color: #f87171;">変更の適用に失敗しました</h3>
                        <div style="font-size: 1.2vh; color: #aaa; margin-bottom: 1vh;">${error.message || '不明なエラー'}</div>
                        <div style="display: flex; justify-content: flex-end;">
                            <button class="control-button" id="apply-changes-error-close2" style="background-color: #4a5a6a;">閉じる</button>
                        </div>
                    </div>
                `;
                    overlay.style.display = 'flex';

                    // オーバーレイをクリックで閉じる
                    overlay.addEventListener('click', (e) => {
                        if (e.target === overlay) {
                            overlay.style.display = 'none';
                        }
                    }, { once: true });

                    document.getElementById('apply-changes-error-close2').addEventListener('click', () => {
                        overlay.style.display = 'none';
                    }, { once: true });
                } else {
                    alert('変更の適用に失敗しました');
                }
            }
        }

        // 管理ボタンのイベントリスナー
        const adminButtonHandler = async () => {
            if (isAdminMode) {
                await logoutAdmin(); // logoutAdmin関数内で確認処理が行われる
            } else {
                loginAdmin(); // モーダル表示のみ
            }
        };
        document.getElementById('admin-button').addEventListener('click', adminButtonHandler);
        document.querySelector('.admin-button-label').addEventListener('click', adminButtonHandler);

        const scrapeToggleButton = document.getElementById('scrape-button');
        const scrapeLabelButton = document.querySelector('.scrape-button-label');
        const scrapeDropdown = document.getElementById('scrape-dropdown');
        const scrapeContainerEl = document.querySelector('.header-scrape-container');

        async function runScrapeRequest(endpoint, payload = null) {
            const button = document.getElementById('scrape-button');
            const label = document.querySelector('.scrape-button-label');
            const originalLabel = label ? label.textContent : '';
            if (button) button.disabled = true;
            if (label) label.textContent = '実行中...';
            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: payload ? { 'Content-Type': 'application/json' } : undefined,
                    body: payload ? JSON.stringify(payload) : undefined
                });
                const data = await response.json().catch(() => ({}));
                if (!response.ok || !data.success) {
                    throw new Error(data.error || `HTTP ${response.status}`);
                }
                alert(data.message || '処理を開始しました。完了通知はDiscordで確認してください。');
            } finally {
                if (button) button.disabled = false;
                if (label) label.textContent = originalLabel;
            }
        }

        function toggleScrapeMenu(event) {
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
            if (!isAdminMode) return;
            setScrapeMenu(!isScrapeMenuOpen);
        }

        function closeScrapeMenu() {
            if (!isScrapeMenuOpen) return;
            setScrapeMenu(false);
        }

        async function triggerFullScrape() {
            if (!isAdminMode) return;
            closeScrapeMenu();
            if (!confirm('全体スクレイピングを実行しますか？\nこの処理には時間がかかる場合があります。\n公式Wikiへの負荷が大きくなるため、必要な場合のみ実行してください。')) {
                return;
            }
            try {
                await runScrapeRequest('/api/admin/trigger-full-scrape');
            } catch (error) {
                alert(`エラー: ${error.message || error}`);
            }
        }

        function triggerPartialScrape() {
            if (!isAdminMode) return;
            closeScrapeMenu();
            openScrapeInputModal({
                title: '部分スクレイピング',
                description: 'スクレイピングしたい図鑑No.を入力してください（例: 1601,1603-1605）。指定したIDは逆順スクレイピングとは別に強制取得します。',
                placeholder: '例: 1611,1614-1617',
                submitLabel: 'スクレイプ',
                onSubmit: (ids) => runScrapeRequest('/api/admin/trigger-partial-scrape', { ids })
            });
        }



        if (scrapeToggleButton) {
            scrapeToggleButton.addEventListener('click', toggleScrapeMenu);
        }
        if (scrapeLabelButton) {
            scrapeLabelButton.addEventListener('click', toggleScrapeMenu);
        }
        if (scrapeDropdown) {
            scrapeDropdown.addEventListener('click', (event) => {
                const button = event.target.closest('button[data-action]');
                if (!button) return;
                event.stopPropagation();
                const action = button.dataset.action;
                if (action === 'full') {
                    triggerFullScrape();
                } else if (action === 'partial') {
                    triggerPartialScrape();
                }
            });
        }
        document.addEventListener('click', (event) => {
            if (!isScrapeMenuOpen) return;
            if (scrapeContainerEl && scrapeContainerEl.contains(event.target)) return;
            closeScrapeMenu();
        });

        // 変更適応ボタン（ヘッダータイトル）のイベントリスナー
        document.getElementById('header-title').addEventListener('click', () => {
            if (isAdminMode && pendingChanges.length > 0) {
                applyChanges();
            }
        });

        // 辞書管理ボタンのイベントリスナー
        const dictionaryButtonHandler = () => {
            if (!isAdminMode) return;
            openDictionaryModal();
        };
        document.getElementById('dictionary-button').addEventListener('click', dictionaryButtonHandler);
        document.querySelector('.dictionary-button-label').addEventListener('click', dictionaryButtonHandler);
        /**
         * 個性・特技管理モーダルを開く
         */
        async function openSkillManagementModal(alienData, slotIndex) {
            if (!isAdminMode) return;

            // モーダルのHTMLを生成（簡易版 - 後で拡張）
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.style.display = 'flex';
            // 不整合チェック
            const hasInvalidData = checkInvalidData(alienData.id);
            const invalidSkillTypes = [];
            if (hasInvalidData) {
                for (const st of ['1', '2', '3', 'S']) {
                    const stText = st === 'S' ? alienData.s_skill_text : alienData[`skill_text${st}`];
                    if (stText && stText !== 'なし') {
                        const alienEffects = ALIEN_EFFECTS[String(alienData.id)];
                        if (alienEffects && alienEffects[st]) {
                            for (let i = 0; i < alienEffects[st].length; i++) {
                                const invalid = checkInvalidDataDetailed(alienData.id, st, i);
                                if (invalid) {
                                    if (!invalidSkillTypes.includes(st)) invalidSkillTypes.push(st);
                                    break;
                                }
                            }
                        }
                    }
                }
            }

            // エイリアンのアイコンパスと説明文を取得
            const alienIconPath = `/static/images/${alienData.id}.webp`;
            const skillText1 = alienData.skill_text1 || 'なし';
            const skillText2 = alienData.skill_text2 || 'なし';
            const skillText3 = alienData.skill_text3 || 'なし';
            const sSkillText = alienData.s_skill_text || 'なし';

            modal.innerHTML = `
            <div class="modal-content" style="max-height: 80vh; overflow-y: auto;">
                <!-- ヘッダー部分 -->
                <div style="border-bottom: 1px solid #4a5a6a; padding-bottom: 1vh; margin-bottom: 1vh;">
                    <div style="display: flex; align-items: center; gap: 1vh; margin-bottom: 1vh;">
                        <img src="${alienIconPath}" alt="${alienData.name}" style="width: 6vh; height: 6vh; object-fit: contain;" onerror="this.style.display='none'">
                        <div>
                            <h2 style="margin: 0; font-size: 2.5vh;">${alienData.name}</h2>
                        </div>
                    </div>
                    <div id="skill-management-tabs" style="display: flex; gap: 1vh; margin-bottom: 1vh;">
                        <button class="skill-tab-btn active ${invalidSkillTypes.includes('1') ? 'invalid-skill-tab' : ''}" data-skill-type="1" data-alien-id="${alienData.id}">個性1</button>
                        <button class="skill-tab-btn ${invalidSkillTypes.includes('2') ? 'invalid-skill-tab' : ''}" data-skill-type="2" data-alien-id="${alienData.id}">個性2</button>
                        <button class="skill-tab-btn ${invalidSkillTypes.includes('3') ? 'invalid-skill-tab' : ''}" data-skill-type="3" data-alien-id="${alienData.id}">個性3</button>
                        <button class="skill-tab-btn ${invalidSkillTypes.includes('S') ? 'invalid-skill-tab' : ''}" data-skill-type="S" data-alien-id="${alienData.id}">特技</button>
                    </div>
                    <div id="skill-description" style="font-size: 1.3vh; color: #aaa; padding: 0.5vh; background-color: #1a2a3a; border-radius: 0.3vh;">
                        ${skillText1}
                    </div>
                </div>
                <style>
                    .skill-tab-btn {
                        padding: 0.5vh 1vh;
                        background-color: #1a2a3a;
                        border: 1px solid #4a5a6a;
                        border-radius: 0.3vh;
                        color: var(--light-text);
                        cursor: pointer;
                        transition: all 0.2s;
                    }
                    .skill-tab-btn.active {
                        border: 2px solid var(--accent-green);
                        box-shadow: 0 0 0.5vh var(--accent-green);
                    }
                    .skill-tab-btn.invalid-skill-tab {
                        color: #ff6666;
                    }
                    .skill-tab-btn.invalid-skill-tab.active {
                        border-color: #ff6666;
                        box-shadow: 0 0 0.5vh #ff6666;
                    }
                </style>
                <div id="skill-management-content">
                    <!-- 内容は動的に生成 -->
                </div>
                <button class="control-button" style="margin-top: 1vh;" onclick="this.closest('.modal-overlay').remove()">閉じる</button>
            </div>
        `;

            document.body.appendChild(modal);

            // タブ切り替えとモーダル外クリックを統合
            modal.addEventListener('click', (e) => {
                // タブクリック処理
                const tabBtn = e.target.closest('.skill-tab-btn');
                if (tabBtn) {
                    e.preventDefault();
                    e.stopPropagation();
                    modal.querySelectorAll('.skill-tab-btn').forEach(b => b.classList.remove('active'));
                    tabBtn.classList.add('active');
                    const skillType = tabBtn.dataset.skillType;
                    // 説明文を更新
                    const descriptionEl = modal.querySelector('#skill-description');
                    if (descriptionEl) {
                        let descriptionText = '';
                        if (skillType === '1') descriptionText = skillText1;
                        else if (skillType === '2') descriptionText = skillText2;
                        else if (skillType === '3') descriptionText = skillText3;
                        else if (skillType === 'S') descriptionText = sSkillText;
                        descriptionEl.textContent = descriptionText;
                    }
                    loadSkillManagementContent(modal, alienData, skillType);
                    return;
                }

                // モーダル背景をクリックした場合のみ閉じる
                if (e.target === modal) {
                    modal.remove();
                }
            });

            // 不整合チェックを実行してタブの色を更新
            if (hasInvalidData) {
                modal.querySelectorAll('.skill-tab-btn').forEach(btn => {
                    const skillType = btn.dataset.skillType;
                    if (invalidSkillTypes.includes(skillType)) {
                        btn.classList.add('invalid-skill-tab');
                    }
                });
            }

            // 初期表示（個性1）
            loadSkillManagementContent(modal, alienData, '1');
        }

        /**
         * pendingChangesを考慮してeffectsをマージ
         * @param {Array} effects - 元の効果リスト
         * @param {string} skillText - 対象のskill_text
         * @returns {Array} - マージ後の効果リスト
         */
        function mergeEffectsWithPendingChanges(effects, skillText) {
            // 元の効果リストをコピー（削除マークは表示のみで除外しない）
            const allEffects = effects.map(e => ({ ...e }));

            // pendingChangesを適用（追加と更新のみ、削除は表示のみ）
            const pendingForSkill = pendingChanges.filter(change =>
                change.skill_text === skillText && (change.type === 'add' || change.type === 'update')
            );

            pendingForSkill.forEach(change => {
                if (change.type === 'add') {
                    // 新規追加
                    allEffects.push({
                        ...change.data,
                        _isPending: true,
                        _pendingType: 'add'
                    });
                } else if (change.type === 'update') {
                    // 既存の効果を更新
                    const index = allEffects.findIndex(e => e.effect_name === change.effect_name);
                    if (index >= 0) {
                        // 既存の効果を更新
                        allEffects[index] = {
                            ...allEffects[index],
                            ...change.data,
                            _isPending: true,
                            _pendingType: 'update'
                        };
                        // effect_nameが変更された場合
                        if (change.new_effect_name && change.new_effect_name !== change.effect_name) {
                            allEffects[index].effect_name = change.new_effect_name;
                        }
                    } else {
                        // 見つからない場合（effect_nameが変更された場合など）、新規として追加
                        const newEffect = {
                            ...change.data,
                            effect_name: change.new_effect_name || change.effect_name,
                            _isPending: true,
                            _pendingType: 'update'
                        };
                        allEffects.push(newEffect);
                    }
                }
            });

            return allEffects;
        }

        /**
         * 個性・特技管理モーダルのコンテンツを読み込む
         */
        function loadSkillManagementContent(modal, alienData, skillType) {
            const content = modal.querySelector('#skill-management-content');

            let skillText;
            if (skillType === 'S') {
                skillText = alienData.s_skill_text;
            } else {
                skillText = alienData[`skill_text${skillType}`];
            }

            if (!skillText || skillText === 'なし') {
                content.innerHTML = '<p>このスロットには個性/特技がありません。</p>';
                return;
            }

            // ALIEN_EFFECTSから直接データを取得（API呼び出し不要）
            const alienEffects = ALIEN_EFFECTS[String(alienData.id)];
            const effects = alienEffects && alienEffects[skillType] ? alienEffects[skillType] : [];

            renderSkillManagementEffects(content, skillText, effects, alienData, skillType);
        }
        /**
         * 効果管理リストを描画
         */
        function renderSkillManagementEffects(container, skillText, effects, alienData, skillType) {
            // skillTypeは引数として渡される

            // 不整合チェック
            const hasInvalidSkill = checkInvalidData(alienData.id);
            const invalidSkillTypes = [];
            if (hasInvalidSkill) {
                for (const st of ['1', '2', '3', 'S']) {
                    const stText = st === 'S' ? alienData.s_skill_text : alienData[`skill_text${st}`];
                    if (stText && stText !== 'なし') {
                        const alienEffects = ALIEN_EFFECTS[String(alienData.id)];
                        if (alienEffects && alienEffects[st]) {
                            for (let i = 0; i < alienEffects[st].length; i++) {
                                const invalid = checkInvalidDataDetailed(alienData.id, st, i);
                                if (invalid) {
                                    if (!invalidSkillTypes.includes(st)) invalidSkillTypes.push(st);
                                    break;
                                }
                            }
                        }
                    }
                }
            }

            // 効果リストを生成（pendingChangesも含める）- 共通関数を使用
            const allEffects = mergeEffectsWithPendingChanges(effects, skillText);

            // 削除マークを付ける効果を確認（表示のみ、実際の削除は変更適応時）
            const pendingDeletes = pendingChanges.filter(c =>
                c.skill_text === skillText && c.type === 'delete'
            );
            const deletedEffectNames = new Set(pendingDeletes.map(c => c.effect_name));

            // 不整合チェック（各効果ごと）- allEffects（pendingChangesをマージした後）を使用
            const invalidEffects = {};
            if (hasInvalidSkill && invalidSkillTypes.includes(skillType)) {
                // allEffectsを使って不整合チェック（pendingChangesを反映）
                // mergeEffectsWithPendingChangesで既に削除された効果は除外されている
                for (let i = 0; i < allEffects.length; i++) {
                    const effect = allEffects[i];
                    // checkInvalidDataDetailedの代わりに、allEffectsの各効果を直接チェック
                    const validTargetStrings = new Set(['自分', '味方全員', '敵全員', '敵単体']);
                    const validCodePatterns = {
                        'a': ['1', '2', '3', '4'],
                        'b': ['1', '2', '3', '4', '5'],
                        'c': ['1', '2'],
                        'd': ['1', '2', '3'],
                        'e': ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q'],
                        'boss': ['1'],
                    };

                    const invalidFields = [];

                    // effect_nameの検証（辞書に存在するか）
                    const effectDict = skillType === 'S' ? S_SKILL_EFFECTS : ALL_EFFECTS;
                    const matchingEffect = effectDict && effectDict.find(e => (e.correct_effect_names || e.effect_name) === effect.effect_name);

                    if (!matchingEffect) {
                        invalidFields.push('effect_name');
                        if (!effect.effect_type || !['BUFF', 'DEBUFF', 'STATUS'].includes(effect.effect_type)) {
                            invalidFields.push('effect_type');
                        }
                        if (!effect.category) {
                            invalidFields.push('category');
                        }
                    }

                    // targetの検証
                    if (effect.target) {
                        if (!validTargetStrings.has(effect.target)) {
                            const parts = effect.target.split(',');
                            for (const part of parts) {
                                const trimmed = part.trim();
                                if (!trimmed.includes(':')) {
                                    invalidFields.push('target');
                                    break;
                                }
                                const [cat, val] = trimmed.split(':');
                                if (!validCodePatterns[cat] || !validCodePatterns[cat].includes(val)) {
                                    invalidFields.push('target');
                                    break;
                                }
                            }
                        }
                    }

                    // condition_targetの検証
                    if (effect.condition_target) {
                        const parts = effect.condition_target.split(',');
                        for (const part of parts) {
                            const trimmed = part.trim();
                            if (!trimmed.includes(':')) {
                                invalidFields.push('condition_target');
                                break;
                            }
                            const [cat, val] = trimmed.split(':');
                            if (!validCodePatterns[cat] || !validCodePatterns[cat].includes(val)) {
                                invalidFields.push('condition_target');
                                break;
                            }
                        }
                    }

                    if (invalidFields.length > 0) {
                        invalidEffects[effect.effect_name] = invalidFields;
                    }
                }
            }

            // target/condition_targetを表示用に変換（アイコンまたは文字列）
            function formatTargetDisplay(targetValue) {
                if (!targetValue) return '';
                const validStrings = ['自分', '味方全員', '敵全員', '敵単体'];
                // 文字列形式の場合はそのまま返す
                if (validStrings.includes(targetValue)) {
                    return targetValue;
                }
                // カンマ区切りの場合
                const parts = targetValue.split(',').map(s => s.trim()).filter(s => s);
                return parts.map(part => {
                    // 文字列形式の場合はそのまま表示
                    if (validStrings.includes(part)) {
                        return `<span style="display: inline-flex; align-items: center; margin-right: 0.3vh;">${part}</span>`;
                    }
                    // :を含まない値（不正な値）はテキストのみ表示（オレンジ色）
                    if (!part.includes(':')) {
                        return `<span style="display: inline-flex; align-items: center; margin-right: 0.3vh; color: #ff8800;">${part}</span>`;
                    }
                    // コード形式の場合はアイコン表示
                    const [cat, val] = part.split(':');
                    if (cat && val) {
                        const iconUrl = `/static/icon/${cat}${val}.webp`;
                        return `<span style="display: inline-flex; align-items: center; margin-right: 0.3vh;">
                        <img src="${iconUrl}" style="width: 1.5vh; height: 1.5vh; margin-right: 0.2vh;" onerror="this.style.display='none'; this.nextElementSibling.style.marginLeft='0'">
                    </span>`;
                    } else {
                        // 不正な形式の場合はテキストのみ表示
                        return `<span style="display: inline-flex; align-items: center; margin-right: 0.3vh; color: #ff8800;">${part}</span>`;
                    }
                }).join('');
            }

            container.innerHTML = `
            <div id="effects-list">
                ${allEffects.length === 0 ? '<p style="text-align: center; color: #aaa; padding: 2vh;">効果が登録されていません。</p>' : ''}
                ${allEffects.map((effect, idx) => {
                const isPending = effect._isPending;
                const pendingType = effect._pendingType;
                const invalidFields = invalidEffects[effect.effect_name] || [];
                const borderStyle = isPending ? 'border: 2px dashed var(--accent-green);' : 'border: 1px solid #4a5a6a;';
                const pendingLabel = isPending ? `<span style="background-color: var(--accent-green); color: var(--dark-bg); padding: 0.2vh 0.5vh; border-radius: 0.2vh; font-size: 1.1vh; margin-left: 0.5vh;">${pendingType === 'add' ? '新規' : '変更'}</span>` : '';

                // 不整合フィールドの説明を生成
                let invalidFieldText = '';
                if (invalidFields.length > 0) {
                    const fieldNames = {
                        'effect_name': '効果名',
                        'effect_type': '分類',
                        'category': 'カテゴリ',
                        'target': 'バフ/デバフ対象',
                        'condition_target': '効果対象'
                    };
                    invalidFieldText = `<div style="font-size: 1.1vh; color: #ff6666; margin-top: 0.3vh; font-weight: bold;">⚠️ 不整合: ${invalidFields.map(f => fieldNames[f] || f).join(', ')}</div>`;
                }

                const effectTypeDisplay = effect.effect_type ? getEffectTypeDisplayName(effect.effect_type) : '(なし)';
                const categoryDisplay = effect.category ? getCategoryDisplayName(effect.category, effect.effect_type) : '(なし)';

                // 要求表示を生成（createRequirementIconのロジックを再利用）
                let requirementDisplay = 'なし';
                if (effect.has_requirement && effect.requirement_details) {
                    const reqParts = effect.requirement_details.split(',').map(s => s.trim());
                    const reqCount = effect.requirement_count || 1;
                    requirementDisplay = reqParts.map(reqPart => {
                        const isNot = reqPart.endsWith('!');
                        const reqValue = isNot ? reqPart.slice(0, -1) : reqPart;
                        const [type, value] = reqValue.split(':');
                        if (!type || !value) return '';
                        const iconName = `${type}${value}`;
                        const iconUrl = `/static/icon/${iconName}.webp`;
                        const notStyle = isNot ? 'transform: scaleY(-1);' : '';
                        const countHtml = reqCount > 1 ? `<span style="position: absolute; top: -0.3vh; right: -0.3vh; background-color: var(--accent-green); color: var(--dark-bg); border-radius: 50%; width: 1.2vh; height: 1.2vh; display: flex; align-items: center; justify-content: center; font-size: 1vh; font-weight: bold;">${reqCount}</span>` : '';
                        return `<span style="display: inline-flex; align-items: center; position: relative; margin-right: 0.3vh;">
                                <img src="${iconUrl}" style="width: 1.5vh; height: 1.5vh; ${notStyle}" onerror="this.style.display='none'">
                                ${countHtml}
                            </span>`;
                    }).join('');
                    if (!requirementDisplay) requirementDisplay = 'なし';
                }

                // 効果を一意に識別するためのIDを生成（インデックス + effect_nameの組み合わせ）
                const effectId = `${idx}_${effect.effect_name}_${skillText.substring(0, 20)}`;

                // 削除予定かどうか（新規追加の効果には適用しない）
                // 新規追加（pendingType === 'add'）の効果は削除マークを付けない（別スロットとして認識）
                const isMarkedForDelete = !effect._isPending && deletedEffectNames.has(effect.effect_name);
                const deleteLabel = isMarkedForDelete ? `<span style="background-color: #f87171; color: white; padding: 0.2vh 0.5vh; border-radius: 0.2vh; font-size: 1.1vh; margin-left: 0.5vh;">削除</span>` : '';
                const deleteBorderStyle = isMarkedForDelete ? 'border: 2px dashed #f87171; opacity: 0.6;' : '';
                const showTarget = effect.show_target !== false;
                const showConditionTarget = effect.show_condition_target !== false;
                const targetDisplayHtml = showTarget && effect.target
                    ? formatTargetDisplay(effect.target)
                    : '（表示しない設定）';
                const conditionDisplayHtml = showConditionTarget && effect.condition_target
                    ? formatTargetDisplay(effect.condition_target)
                    : '（表示しない設定）';
                const targetSpanAttr = invalidFields.includes('target')
                    ? 'style="color: #ff6666;"'
                    : (showTarget ? '' : 'style="color: #666;"');
                const conditionSpanAttr = invalidFields.includes('condition_target')
                    ? 'style="color: #ff6666;"'
                    : (showConditionTarget ? '' : 'style="color: #666;"');

                return `
                    <div class="effect-item" data-effect-id="${effectId}" data-effect-index="${idx}" style="${borderStyle} ${deleteBorderStyle} padding: 1vh; margin-bottom: 1vh; border-radius: 0.5vh; position: relative;">
                        ${isMarkedForDelete ? `<button onclick="cancelDeleteEffect('${skillText.replace(/'/g, "\\'")}', '${effect.effect_name.replace(/'/g, "\\'")}')" style="position: absolute; top: 0.3vh; right: 0.3vh; background-color: #4a5a6a; color: white; border: none; border-radius: 50%; width: 2vh; height: 2vh; cursor: pointer; font-size: 1.2vh; display: flex; align-items: center; justify-content: center; padding: 0;">✕</button>` : ''}
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5vh;">
                            <div><strong ${invalidFields.includes('effect_name') ? 'style="color: #ff6666;"' : ''}>${effect.effect_name}</strong>${pendingLabel}${deleteLabel}</div>
                            <div style="font-size: 1.2vh; color: #aaa;">${effectTypeDisplay}:${categoryDisplay}</div>
                        </div>
                        ${invalidFieldText}
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5vh; margin-bottom: 0.5vh; align-items: center; font-size: 1.2vh;">
                            <div>
                                <span style="color: #aaa;">バフ/デバフ対象:</span>
                                <span ${targetSpanAttr}>${targetDisplayHtml}</span>
                            </div>
                            <div>
                                <span style="color: #aaa;">効果対象:</span>
                                <span ${conditionSpanAttr}>${conditionDisplayHtml}</span>
                            </div>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; font-size: 1.2vh;">
                            <div>
                                <span style="color: #aaa;">要求:</span>
                                <span>${requirementDisplay}</span>
                            </div>
                            <div style="display: flex; gap: 0.3vh;">
                                <button class="control-button" onclick="editEffectByIndex('${escapeJsString(skillText)}', ${idx}, '${escapeJsString(effect.effect_name)}')" style="font-size: 1.3vh; padding: 0.4vh 0.8vh; ${isMarkedForDelete ? 'opacity: 0.5; pointer-events: none;' : ''}">編集</button>
                                <button class="control-button" onclick="markEffectForDelete('${escapeJsString(skillText)}', '${escapeJsString(effect.effect_name)}')" style="font-size: 1.3vh; padding: 0.4vh 0.8vh; ${isMarkedForDelete ? 'display: none;' : ''}">削除</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('')}
            </div>
            <div style="margin-top: 1.5vh; text-align: center;">
                <button class="control-button" onclick="addNewEffect('${escapeJsString(skillText)}')" style="background-color: var(--accent-green); color: var(--dark-bg); padding: 0.8vh 2vh;">効果を追加</button>
            </div>
        `;
            // グローバル関数として定義（onclickで使用するため）
            window.addNewEffect = (text) => {
                // skill_textが特技か個性かを判定
                const isSpecialSkill = skillType === 'S';
                const effectDict = isSpecialSkill ? S_SKILL_EFFECTS : ALL_EFFECTS;

                // 効果名リストを作成（カテゴリ別に整理）
                const effectNames = effectDict ? [...new Set(effectDict.map(e => e.correct_effect_names || e.effect_name))].sort() : [];

                // 効果名をカテゴリで分類
                const effectsByTypeAndCategory = {};
                effectDict.forEach(effect => {
                    const effectType = effect.effect_type || '';
                    const effectCategory = effect.category || '';
                    const key = `${effectType}_${effectCategory}`;
                    if (!effectsByTypeAndCategory[key]) {
                        effectsByTypeAndCategory[key] = [];
                    }
                    effectsByTypeAndCategory[key].push(effect);
                });

                // カテゴリ構造を定義
                let categoryStructure;
                if (isSpecialSkill) {
                    categoryStructure = {
                        '回復系': [],
                        'バフ系': [],
                        'デバフ(状態異常)系': []
                    };

                    Object.keys(effectsByTypeAndCategory).forEach(key => {
                        const [effectType, ...categoryParts] = key.split('_');
                        const category = categoryParts.join('_');
                        if (category === 'S_SKILL_HEAL') {
                            categoryStructure['回復系'].push(key);
                        } else if (category === 'S_SKILL_BUFF') {
                            categoryStructure['バフ系'].push(key);
                        } else if (category === 'S_SKILL_DEBUFF') {
                            categoryStructure['デバフ(状態異常)系'].push(key);
                        }
                    });
                } else {
                    categoryStructure = {
                        'バフ': {
                            'アップ系': [],
                            '軽減系': [],
                            '抵抗系': [],
                            'その他バフ': []
                        },
                        'デバフ': {
                            'ダウン系': [],
                            'その他デバフ': []
                        },
                        '状態異常': {
                            '毒系': [],
                            '気絶系': [],
                            'その他状態異常': []
                        }
                    };

                    Object.keys(effectsByTypeAndCategory).forEach(key => {
                        const [effectType, ...categoryParts] = key.split('_');
                        const category = categoryParts.join('_');
                        if (effectType === 'BUFF') {
                            if (category === 'BUFF_BOOST') {
                                categoryStructure['バフ']['アップ系'].push(key);
                            } else if (category === 'BUFF_REDUCE') {
                                categoryStructure['バフ']['軽減系'].push(key);
                            } else if (category === 'BUFF_RESIST') {
                                categoryStructure['バフ']['抵抗系'].push(key);
                            } else {
                                categoryStructure['バフ']['その他バフ'].push(key);
                            }
                        } else if (effectType === 'DEBUFF') {
                            if (category === 'DEBUFF_DOWN' || category === 'DEBUFF_REDUCE') {
                                categoryStructure['デバフ']['ダウン系'].push(key);
                            } else {
                                categoryStructure['デバフ']['その他デバフ'].push(key);
                            }
                        } else if (effectType === 'STATUS') {
                            if (category === 'STATUS_POISON') {
                                categoryStructure['状態異常']['毒系'].push(key);
                            } else if (category === 'STATUS_STUN') {
                                categoryStructure['状態異常']['気絶系'].push(key);
                            } else {
                                categoryStructure['状態異常']['その他状態異常'].push(key);
                            }
                        }
                    });
                }

                // ドロップダウンオプションを生成
                let optionsHtml = '<option value="">効果名を選択</option>';
                if (isSpecialSkill) {
                    Object.keys(categoryStructure).forEach(mainCategory => {
                        const categoryKeys = categoryStructure[mainCategory];
                        categoryKeys.forEach(categoryKey => {
                            const effects = effectsByTypeAndCategory[categoryKey] || [];
                            effects.forEach(effect => {
                                const effectName = effect.correct_effect_names || effect.effect_name || '';
                                if (effectName) {
                                    optionsHtml += `<option value="${effectName}">${mainCategory} - ${effectName}</option>`;
                                }
                            });
                        });
                    });
                } else {
                    Object.keys(categoryStructure).forEach(mainCategory => {
                        const subCategories = categoryStructure[mainCategory];
                        Object.keys(subCategories).forEach(subCategory => {
                            const categoryKeys = subCategories[subCategory];
                            categoryKeys.forEach(categoryKey => {
                                const effects = effectsByTypeAndCategory[categoryKey] || [];
                                effects.forEach(effect => {
                                    const effectName = effect.correct_effect_names || effect.effect_name || '';
                                    if (effectName) {
                                        optionsHtml += `<option value="${effectName}">${mainCategory}/${subCategory} - ${effectName}</option>`;
                                    }
                                });
                            });
                        });
                    });
                }

                // 新しいスロットを追加（破線ボーダー）
                const effectsList = container.querySelector('#effects-list');
                const newSlot = document.createElement('div');
                newSlot.className = 'effect-item';
                newSlot.style.cssText = 'border: 2px dashed var(--accent-green); padding: 1vh; margin-bottom: 1vh; border-radius: 0.5vh;';

                // 選択状態を保持する変数
                let newSlotSelectedTargets = [];
                let newSlotSelectedConditionTargets = [];
                let newSlotSelectedRequirements = [];
                let newSlotRequirementCount = 1;

                // 選択表示を更新する関数
                const updateNewSlotTargetDisplay = () => {
                    const targetContainer = newSlot.querySelector('#new-slot-target-selector');
                    targetContainer.innerHTML = '';
                    if (newSlotSelectedTargets.length === 0) {
                        targetContainer.innerHTML = '<span style="color: #aaa; font-size: 1.2vh;">未選択</span>';
                    } else {
                        newSlotSelectedTargets.forEach(target => {
                            const validStrings = ['自分', '味方全員', '敵全員', '敵単体'];
                            // 文字列形式または:を含まない値は画像として扱わない
                            if (validStrings.includes(target) || !target.includes(':')) {
                                targetContainer.innerHTML += `<span style="background-color: #2a4a5a; padding: 0.2vh 0.5vh; border-radius: 0.2vh; font-size: 1.2vh; margin-right: 0.3vh; ${!validStrings.includes(target) ? 'color: #ff8800;' : ''}">${target}</span>`;
                            } else {
                                const [cat, val] = target.split(':');
                                if (cat && val) {
                                    const iconUrl = `/static/icon/${cat}${val}.webp`;
                                    targetContainer.innerHTML += `<span style="display: inline-flex; align-items: center; background-color: #2a4a5a; padding: 0.2vh 0.5vh; border-radius: 0.2vh; margin-right: 0.3vh;">
                                    <img src="${iconUrl}" style="width: 1.5vh; height: 1.5vh; margin-right: 0.2vh;" onerror="this.style.display='none'">
                                    <span style="font-size: 1.2vh;">${target}</span>
                                </span>`;
                                } else {
                                    // 不正な形式の場合はテキストのみ表示
                                    targetContainer.innerHTML += `<span style="background-color: #2a4a5a; padding: 0.2vh 0.5vh; border-radius: 0.2vh; font-size: 1.2vh; margin-right: 0.3vh; color: #ff8800;">${target}</span>`;
                                }
                            }
                        });
                    }
                };

                const updateNewSlotConditionTargetDisplay = () => {
                    const conditionTargetContainer = newSlot.querySelector('#new-slot-condition-target-selector');
                    conditionTargetContainer.innerHTML = '';
                    if (newSlotSelectedConditionTargets.length === 0) {
                        conditionTargetContainer.innerHTML = '<span style="color: #aaa; font-size: 1.2vh;">未選択</span>';
                    } else {
                        newSlotSelectedConditionTargets.forEach(target => {
                            // 文字列形式（「レジェンドボス」など）または:を含まない値は画像として扱わない
                            if (!target.includes(':')) {
                                const displayText = target === 'boss:1' ? 'レジェンドボス' : target;
                                conditionTargetContainer.innerHTML += `<span style="background-color: #2a4a5a; padding: 0.2vh 0.5vh; border-radius: 0.2vh; font-size: 1.2vh; margin-right: 0.3vh;">${displayText}</span>`;
                            } else {
                                const [cat, val] = target.split(':');
                                if (cat && val) {
                                    const iconUrl = `/static/icon/${cat}${val}.webp`;
                                    conditionTargetContainer.innerHTML += `<span style="display: inline-flex; align-items: center; background-color: #2a4a5a; padding: 0.2vh 0.5vh; border-radius: 0.2vh; margin-right: 0.3vh;">
                                    <img src="${iconUrl}" style="width: 1.5vh; height: 1.5vh; margin-right: 0.2vh;" onerror="this.style.display='none'">
                                    <span style="font-size: 1.2vh;">${target}</span>
                                </span>`;
                                } else {
                                    // 不正な形式の場合はテキストのみ表示
                                    conditionTargetContainer.innerHTML += `<span style="background-color: #2a4a5a; padding: 0.2vh 0.5vh; border-radius: 0.2vh; font-size: 1.2vh; margin-right: 0.3vh; color: #ff8800;">${target}</span>`;
                                }
                            }
                        });
                    }
                };

                // 選択モーダルを開く関数（共通関数を使用）
                const openNewSlotTargetSelector = () => {
                    let tempSelectedTargets = [...newSlotSelectedTargets];
                    const selectorModal = document.createElement('div');
                    selectorModal.className = 'modal-overlay';
                    selectorModal.style.display = 'flex';

                    const updateButtonColors = () => {
                        selectorModal.querySelectorAll('button').forEach(btn => {
                            const onclickStr = btn.onclick ? btn.onclick.toString() : '';
                            if (onclickStr.includes('tempSelectTargetString')) {
                                const str = btn.textContent.trim();
                                if (['自分', '味方全員', '敵全員', '敵単体'].includes(str)) {
                                    btn.style.backgroundColor = tempSelectedTargets.includes(str) ? 'var(--accent-green)' : '#1a2a3a';
                                }
                            } else if (onclickStr.includes('tempSelectTargetCode')) {
                                const match = onclickStr.match(/tempSelectTargetCode\('([^']+)',\s*'([^']+)'\)/);
                                if (match) {
                                    const code = `${match[1]}:${match[2]}`;
                                    btn.style.backgroundColor = tempSelectedTargets.includes(code) ? 'var(--accent-green)' : '#1a2a3a';
                                }
                            }
                        });
                    };

                    selectorModal.innerHTML = createTargetSelectorHTML(
                        tempSelectedTargets,
                        'tempSelectTargetString',
                        'tempSelectTargetCode',
                        true
                    );

                    document.body.appendChild(selectorModal);
                    replaceIconImagesWithClones(selectorModal);

                    window.tempSelectTargetString = (str) => {
                        const validStrings = ['自分', '味方全員', '敵全員', '敵単体'];
                        if (tempSelectedTargets.includes(str)) {
                            tempSelectedTargets = tempSelectedTargets.filter(t => t !== str);
                        } else {
                            // 文字列形式を選択する場合、他の文字列形式を削除し、不正な値も削除
                            tempSelectedTargets = tempSelectedTargets.filter(t =>
                                !validStrings.includes(t) && t.includes(':') // 有効な文字列形式と不正な値（:を含まない）を削除
                            );
                            tempSelectedTargets.push(str);
                        }
                        updateButtonColors();
                    };

                    window.tempSelectTargetCode = (cat, val) => {
                        const code = `${cat}:${val}`;
                        if (tempSelectedTargets.includes(code)) {
                            tempSelectedTargets = tempSelectedTargets.filter(t => t !== code);
                        } else {
                            tempSelectedTargets.push(code);
                        }
                        updateButtonColors();
                    };

                    window.confirmTargetSelection = () => {
                        newSlotSelectedTargets = [...tempSelectedTargets];
                        updateNewSlotTargetDisplay();
                        selectorModal.remove();
                        window.cleanupTempTargetFunctions();
                    };

                    window.cleanupTempTargetFunctions = () => {
                        delete window.tempSelectTargetString;
                        delete window.tempSelectTargetCode;
                        delete window.confirmTargetSelection;
                        delete window.cleanupTempTargetFunctions;
                    };

                    selectorModal.addEventListener('click', (e) => {
                        if (e.target === selectorModal) {
                            selectorModal.remove();
                            window.cleanupTempTargetFunctions();
                        }
                    });
                };
                const openNewSlotConditionTargetSelector = () => {
                    let tempSelectedConditionTargets = [...newSlotSelectedConditionTargets];
                    const selectorModal = document.createElement('div');
                    selectorModal.className = 'modal-overlay';
                    selectorModal.style.display = 'flex';

                    const updateButtonColors = () => {
                        selectorModal.querySelectorAll('button').forEach(btn => {
                            const onclickStr = btn.onclick ? btn.onclick.toString() : '';
                            if (onclickStr.includes('tempSelectConditionTargetString')) {
                                const str = btn.textContent.trim();
                                const code = str === 'レジェンドボス' ? 'boss:1' : str;
                                btn.style.backgroundColor = tempSelectedConditionTargets.includes(code) ? 'var(--accent-green)' : '#1a2a3a';
                            } else if (onclickStr.includes('tempSelectConditionTargetCode')) {
                                const match = onclickStr.match(/tempSelectConditionTargetCode\('([^']+)',\s*'([^']+)'\)/);
                                if (match) {
                                    const code = `${match[1]}:${match[2]}`;
                                    btn.style.backgroundColor = tempSelectedConditionTargets.includes(code) ? 'var(--accent-green)' : '#1a2a3a';
                                }
                            }
                        });
                    };

                    selectorModal.innerHTML = `
                    <div class="modal-content" style="max-height: 80vh; overflow-y: auto; width: 90vw; max-width: 50vh;">
                        <h3 style="margin-top: 0; margin-bottom: 1vh; font-size: 1.6vh;">効果対象を選択</h3>
                        <div style="margin-bottom: 0.8vh;">
                            <div style="font-size: 1.4vh; margin-bottom: 0.5vh;"><strong>文字列形式:</strong></div>
                            <div style="display: flex; flex-wrap: wrap; gap: 0.6vh;">
                                <button type="button" onclick="tempSelectConditionTargetString('レジェンドボス')" 
                                        style="padding: 0.8vh 1.5vh; background-color: ${tempSelectedConditionTargets.includes('boss:1') ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh; color: var(--light-text); font-size: 1.4vh;">
                                    レジェンドボス
                                </button>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1vh;">
                            <div>
                                <div style="font-size: 1.4vh; margin-bottom: 0.5vh;"><strong>属性 (a):</strong></div>
                                <div style="display: flex; flex-wrap: wrap; gap: 0.6vh;">
                                    ${[1, 2, 3, 4].map(v => `
                                        <button type="button" onclick="tempSelectConditionTargetCode('a', '${v}')" 
                                                style="padding: 0.6vh; background-color: ${tempSelectedConditionTargets.includes(`a:${v}`) ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh;">
                                            <img src="/static/icon/a${v}.webp" style="width: 3vh; height: 3vh;">
                                        </button>
                                    `).join('')}
                                </div>
                            </div>
                            <div>
                                <div style="font-size: 1.4vh; margin-bottom: 0.5vh;"><strong>所属 (b):</strong></div>
                                <div style="display: flex; flex-wrap: wrap; gap: 0.6vh;">
                                    ${[1, 2, 3, 4, 5].map(v => `
                                        <button type="button" onclick="tempSelectConditionTargetCode('b', '${v}')" 
                                                style="padding: 0.6vh; background-color: ${tempSelectedConditionTargets.includes(`b:${v}`) ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh;">
                                            <img src="/static/icon/b${v}.webp" style="width: 3vh; height: 3vh;">
                                        </button>
                                    `).join('')}
                                </div>
                            </div>
                            <div>
                                <div style="font-size: 1.4vh; margin-bottom: 0.5vh;"><strong>攻撃はんい (c):</strong></div>
                                <div style="display: flex; flex-wrap: wrap; gap: 0.6vh;">
                                    ${[1, 2].map(v => `
                                        <button type="button" onclick="tempSelectConditionTargetCode('c', '${v}')" 
                                                style="padding: 0.6vh; background-color: ${tempSelectedConditionTargets.includes(`c:${v}`) ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh;">
                                            <img src="/static/icon/c${v}.webp" style="width: 3vh; height: 3vh;">
                                        </button>
                                    `).join('')}
                                </div>
                            </div>
                            <div>
                                <div style="font-size: 1.4vh; margin-bottom: 0.5vh;"><strong>攻撃距離 (d):</strong></div>
                                <div style="display: flex; flex-wrap: wrap; gap: 0.6vh;">
                                    ${[1, 2, 3].map(v => `
                                        <button type="button" onclick="tempSelectConditionTargetCode('d', '${v}')" 
                                                style="padding: 0.6vh; background-color: ${tempSelectedConditionTargets.includes(`d:${v}`) ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh;">
                                            <img src="/static/icon/d${v}.webp" style="width: 3vh; height: 3vh;">
                                        </button>
                                    `).join('')}
                                </div>
                            </div>
                        </div>
                        <div style="display: flex; gap: 1vh; margin-top: 1vh; justify-content: flex-end; align-items: center; padding-top: 1vh; border-top: 1px solid #4a5a6a;">
                            <button class="control-button" onclick="window.confirmConditionTargetSelection()" style="padding: 0.8vh 2vh; font-size: 1.4vh; background-color: #ff8800; color: white; border: none; border-radius: 0.3vh; cursor: pointer;">決定</button>
                            <button class="control-button" onclick="this.closest('.modal-overlay').remove(); window.cleanupTempConditionTargetFunctions();" style="padding: 0.8vh 2vh; font-size: 1.4vh; background-color: #4a5a6a; color: var(--light-text); border: none; border-radius: 0.3vh; cursor: pointer;">キャンセル</button>
                        </div>
                    </div>
                `;

                    document.body.appendChild(selectorModal);
                    replaceIconImagesWithClones(selectorModal);

                    window.tempSelectConditionTargetString = (str) => {
                        const code = str === 'レジェンドボス' ? 'boss:1' : str;
                        if (tempSelectedConditionTargets.includes(code)) {
                            tempSelectedConditionTargets = tempSelectedConditionTargets.filter(t => t !== code);
                        } else {
                            tempSelectedConditionTargets.push(code);
                        }
                        updateButtonColors();
                    };

                    window.tempSelectConditionTargetCode = (cat, val) => {
                        const code = `${cat}:${val}`;
                        if (tempSelectedConditionTargets.includes(code)) {
                            tempSelectedConditionTargets = tempSelectedConditionTargets.filter(t => t !== code);
                        } else {
                            tempSelectedConditionTargets.push(code);
                        }
                        updateButtonColors();
                    };

                    window.confirmConditionTargetSelection = () => {
                        newSlotSelectedConditionTargets = [...tempSelectedConditionTargets];
                        updateNewSlotConditionTargetDisplay();
                        selectorModal.remove();
                        window.cleanupTempConditionTargetFunctions();
                    };

                    window.cleanupTempConditionTargetFunctions = () => {
                        delete window.tempSelectConditionTargetString;
                        delete window.tempSelectConditionTargetCode;
                        delete window.confirmConditionTargetSelection;
                        delete window.cleanupTempConditionTargetFunctions;
                    };

                    selectorModal.addEventListener('click', (e) => {
                        if (e.target === selectorModal) {
                            selectorModal.remove();
                            window.cleanupTempConditionTargetFunctions();
                        }
                    });
                };
                // 要求表示を更新する関数
                const updateNewSlotRequirementDisplay = () => {
                    const requirementContainer = newSlot.querySelector('#new-slot-requirement-selector');
                    requirementContainer.innerHTML = '';
                    if (newSlotSelectedRequirements.length === 0) {
                        requirementContainer.innerHTML = '<span style="color: #aaa; font-size: 1.2vh;">未選択</span>';
                    } else {
                        newSlotSelectedRequirements.forEach(req => {
                            const iconName = `${req.type}${req.value}`;
                            const iconUrl = `/static/icon/${iconName}.webp`;
                            const notStyle = req.is_not ? 'transform: scaleY(-1);' : '';
                            const countHtml = newSlotRequirementCount > 1 ? `<span style="position: absolute; top: -0.3vh; right: -0.3vh; background-color: var(--accent-green); color: var(--dark-bg); border-radius: 50%; width: 1.2vh; height: 1.2vh; display: flex; align-items: center; justify-content: center; font-size: 1vh; font-weight: bold;">${newSlotRequirementCount}</span>` : '';
                            requirementContainer.innerHTML += `<span style="display: inline-flex; align-items: center; position: relative; background-color: #2a4a5a; padding: 0.2vh 0.5vh; border-radius: 0.2vh; margin-right: 0.3vh;">
                            <img src="${iconUrl}" style="width: 1.5vh; height: 1.5vh; margin-right: 0.2vh; ${notStyle}" onerror="this.style.display='none'">
                            ${countHtml}
                        </span>`;
                        });
                    }
                };
                // 要求選択モーダルを開く関数
                const openNewSlotRequirementSelector = () => {
                    let tempSelectedRequirements = [...newSlotSelectedRequirements];
                    const selectorModal = document.createElement('div');
                    selectorModal.className = 'modal-overlay';
                    selectorModal.style.display = 'flex';

                    // 改善された要求選択UI（チェックボックスで「◯以外」を選択）
                    selectorModal.innerHTML = `
                    <div class="modal-content" style="max-height: 85vh; overflow-y: auto; width: 95vw; max-width: 70vh;">
                        <h3 style="margin-top: 0; margin-bottom: 1vh; font-size: 1.6vh;">要求（味方編成条件）を選択</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1vh; margin-bottom: 1vh;">
                            <div>
                                <div style="font-size: 1.3vh; margin-bottom: 0.5vh; font-weight: bold;">属性 (a):</div>
                                <div style="display: flex; flex-wrap: wrap; gap: 0.5vh;">
                                    ${[1, 2, 3, 4].map(v => {
                        const isSelected = tempSelectedRequirements.some(r => r.type === 'a' && r.value === String(v));
                        return `
                                            <button type="button" onclick="tempSelectRequirementCode('a', '${v}')" 
                                                    style="padding: 0.5vh; background-color: ${isSelected ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh; position: relative;">
                                                <img src="/static/icon/a${v}.webp" style="width: 2.5vh; height: 2.5vh;">
                                            </button>
                                        `;
                    }).join('')}
                                </div>
                            </div>
                            <div>
                                <div style="font-size: 1.3vh; margin-bottom: 0.5vh; font-weight: bold;">所属 (b):</div>
                                <div style="display: flex; flex-wrap: wrap; gap: 0.5vh;">
                                    ${[1, 2, 3, 4, 5].map(v => {
                        const isSelected = tempSelectedRequirements.some(r => r.type === 'b' && r.value === String(v));
                        return `
                                            <button type="button" onclick="tempSelectRequirementCode('b', '${v}')" 
                                                    style="padding: 0.5vh; background-color: ${isSelected ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh; position: relative;">
                                                <img src="/static/icon/b${v}.webp" style="width: 2.5vh; height: 2.5vh;">
                                            </button>
                                        `;
                    }).join('')}
                                </div>
                            </div>
                            <div>
                                <div style="font-size: 1.3vh; margin-bottom: 0.5vh; font-weight: bold;">攻撃はんい (c):</div>
                                <div style="display: flex; flex-wrap: wrap; gap: 0.5vh;">
                                    ${[1, 2].map(v => {
                        const isSelected = tempSelectedRequirements.some(r => r.type === 'c' && r.value === String(v));
                        return `
                                            <button type="button" onclick="tempSelectRequirementCode('c', '${v}')" 
                                                    style="padding: 0.5vh; background-color: ${isSelected ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh; position: relative;">
                                                <img src="/static/icon/c${v}.webp" style="width: 2.5vh; height: 2.5vh;">
                                            </button>
                                        `;
                    }).join('')}
                                </div>
                            </div>
                            <div>
                                <div style="font-size: 1.3vh; margin-bottom: 0.5vh; font-weight: bold;">攻撃距離 (d):</div>
                                <div style="display: flex; flex-wrap: wrap; gap: 0.5vh;">
                                    ${[1, 2, 3].map(v => {
                        const isSelected = tempSelectedRequirements.some(r => r.type === 'd' && r.value === String(v));
                        return `
                                            <button type="button" onclick="tempSelectRequirementCode('d', '${v}')" 
                                                    style="padding: 0.5vh; background-color: ${isSelected ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh; position: relative;">
                                                <img src="/static/icon/d${v}.webp" style="width: 2.5vh; height: 2.5vh;">
                                            </button>
                                        `;
                    }).join('')}
                                </div>
                            </div>
                        </div>
                        <div style="margin-bottom: 1vh;">
                            <div style="font-size: 1.3vh; margin-bottom: 0.5vh; font-weight: bold;">タイプ (e):</div>
                            <div style="display: flex; flex-wrap: wrap; gap: 0.5vh;">
                                ${['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q'].map(v => {
                        const isSelected = tempSelectedRequirements.some(r => r.type === 'e' && r.value === String(v));
                        return `
                                        <button type="button" onclick="tempSelectRequirementCode('e', '${v}')" 
                                                style="padding: 0.5vh; background-color: ${isSelected ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh; position: relative;">
                                            <img src="/static/icon/e${v}.webp" style="width: 2.5vh; height: 2.5vh;">
                                        </button>
                                    `;
                    }).join('')}
                            </div>
                        </div>
                        <div style="display: flex; gap: 1vh; margin-top: 1vh; justify-content: space-between; align-items: center; padding-top: 1vh; border-top: 1px solid #4a5a6a;">
                            <label style="display: flex; align-items: center; gap: 0.5vh; font-size: 1.3vh; cursor: pointer;">
                                <input type="checkbox" id="temp-requirement-not-checkbox" 
                                       ${tempSelectedRequirements.some(r => r.is_not) ? 'checked' : ''}
                                       style="width: 1.5vh; height: 1.5vh; cursor: pointer;">
                                <span>選択した条件以外</span>
                            </label>
                            <div style="display: flex; gap: 1vh;">
                                <button class="control-button" onclick="tempConfirmRequirementSelection()" style="padding: 0.8vh 2vh; font-size: 1.4vh; background-color: #ff8800; color: white; border: none; border-radius: 0.3vh; cursor: pointer;">決定</button>
                                <button class="control-button" onclick="this.closest('.modal-overlay').remove(); cleanupTempRequirementFunctions();" style="padding: 0.8vh 2vh; font-size: 1.4vh; background-color: #4a5a6a; color: var(--light-text); border: none; border-radius: 0.3vh; cursor: pointer;">キャンセル</button>
                            </div>
                        </div>
                    </div>
                `;

                    document.body.appendChild(selectorModal);
                    replaceIconImagesWithClones(selectorModal);

                    let tempRequirementNotChecked = tempSelectedRequirements.some(r => r.is_not);

                    window.tempSelectRequirementCode = (type, value) => {
                        const existing = tempSelectedRequirements.find(r => r.type === type && r.value === value);
                        if (existing) {
                            // 既存の選択を削除
                            tempSelectedRequirements.splice(tempSelectedRequirements.indexOf(existing), 1);
                        } else {
                            // 新しい選択を追加（他の選択をクリア）
                            tempSelectedRequirements.splice(0, tempSelectedRequirements.length);
                            tempSelectedRequirements.push({ type, value, is_not: false });
                        }

                        // 「以外」チェックボックスの状態を適用
                        const notCheckbox = selectorModal.querySelector('#temp-requirement-not-checkbox');
                        if (notCheckbox && notCheckbox.checked && tempSelectedRequirements.length > 0) {
                            tempSelectedRequirements.forEach(r => r.is_not = true);
                        }

                        // ボタンの色を更新
                        selectorModal.querySelectorAll('button[onclick*="tempSelectRequirementCode"]').forEach(btn => {
                            const onclickStr = btn.onclick ? btn.onclick.toString() : '';
                            if (onclickStr.includes(`'${type}', '${value}'`)) {
                                const isSelected = tempSelectedRequirements.some(r => r.type === type && r.value === value);
                                btn.style.backgroundColor = isSelected ? 'var(--accent-green)' : '#1a2a3a';
                            }
                        });
                    };

                    // 「以外」チェックボックスのイベントリスナー
                    const notCheckbox = selectorModal.querySelector('#temp-requirement-not-checkbox');
                    if (notCheckbox) {
                        notCheckbox.addEventListener('change', (e) => {
                            tempRequirementNotChecked = e.target.checked;
                            if (tempSelectedRequirements.length > 0) {
                                tempSelectedRequirements.forEach(r => r.is_not = tempRequirementNotChecked);
                            }
                        });
                    }

                    window.tempConfirmRequirementSelection = () => {
                        // 「以外」チェックボックスの状態を適用
                        const notCheckbox = selectorModal.querySelector('#temp-requirement-not-checkbox');
                        if (notCheckbox && notCheckbox.checked && tempSelectedRequirements.length > 0) {
                            tempSelectedRequirements.forEach(r => r.is_not = true);
                        }
                        newSlotSelectedRequirements = [...tempSelectedRequirements];
                        updateNewSlotRequirementDisplay();
                        selectorModal.remove();
                        cleanupTempRequirementFunctions();
                    };

                    window.cleanupTempRequirementFunctions = () => {
                        delete window.tempSelectRequirementCode;
                        delete window.tempConfirmRequirementSelection;
                        delete window.cleanupTempRequirementFunctions;
                    };

                    selectorModal.addEventListener('click', (e) => {
                        if (e.target === selectorModal) {
                            selectorModal.remove();
                            cleanupTempRequirementFunctions();
                        }
                    });
                };

                newSlot.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5vh;">
                    <div>
                        <select id="new-effect-name-select" style="padding: 0.5vh; background-color: #1a2a3a; border: 1px solid #4a5a6a; border-radius: 0.3vh; color: var(--light-text); font-size: 1.2vh; width: 20vh;">
                            ${optionsHtml}
                        </select>
                    </div>
                    <div id="new-slot-effect-type-display" style="font-size: 1.2vh; color: #aaa;"></div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1vh; margin-bottom: 0.5vh;">
                    <div>
                        <label style="display: block; margin-bottom: 0.3vh; font-size: 1.2vh;"><strong>バフ/デバフ対象:</strong></label>
                        <div id="new-slot-target-selector" style="display: flex; flex-wrap: wrap; gap: 0.5vh; border: 1px solid #4a5a6a; padding: 0.5vh; border-radius: 0.3vh; min-height: 3vh; background-color: #1a2a3a; cursor: pointer;">
                            <span style="color: #aaa; font-size: 1.2vh;">未選択</span>
                        </div>
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 0.3vh; font-size: 1.2vh;"><strong>効果対象:</strong></label>
                        <div id="new-slot-condition-target-selector" style="display: flex; flex-wrap: wrap; gap: 0.5vh; border: 1px solid #4a5a6a; padding: 0.5vh; border-radius: 0.3vh; min-height: 3vh; background-color: #1a2a3a; cursor: pointer;">
                            <span style="color: #aaa; font-size: 1.2vh;">未選択</span>
                        </div>
                    </div>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div style="flex: 1;">
                        <label style="display: block; margin-bottom: 0.3vh; font-size: 1.2vh;"><strong>要求:</strong></label>
                        <div id="new-slot-requirement-selector" style="display: flex; flex-wrap: wrap; gap: 0.5vh; border: 1px solid #4a5a6a; padding: 0.5vh; border-radius: 0.3vh; min-height: 3vh; background-color: #1a2a3a; cursor: pointer;">
                            <span style="color: #aaa; font-size: 1.2vh;">未選択</span>
                        </div>
                        <input type="number" id="new-slot-requirement-count" value="1" min="1" style="width: 5vh; margin-top: 0.3vh; padding: 0.3vh; background-color: #1a2a3a; border: 1px solid #4a5a6a; border-radius: 0.3vh; color: var(--light-text); font-size: 1.2vh;">
                    </div>
                    <div style="display: flex; gap: 0.3vh;">
                        <button class="control-button new-confirm-btn" data-skill-text="${text.replace(/'/g, "\\'")}" style="font-size: 1.3vh; padding: 0.4vh 0.8vh;">決定</button>
                        <button class="control-button new-cancel-btn" style="font-size: 1.3vh; padding: 0.4vh 0.8vh;">キャンセル</button>
                    </div>
                </div>
            `;
                effectsList.appendChild(newSlot);

                // 選択関数をスロット内で定義
                newSlot.querySelector('#new-slot-target-selector').addEventListener('click', openNewSlotTargetSelector);
                newSlot.querySelector('#new-slot-condition-target-selector').addEventListener('click', openNewSlotConditionTargetSelector);
                newSlot.querySelector('#new-slot-requirement-selector').addEventListener('click', openNewSlotRequirementSelector);

                // 効果名選択時に効果タイプを表示
                newSlot.querySelector('#new-effect-name-select').addEventListener('change', () => {
                    const selectedEffectName = newSlot.querySelector('#new-effect-name-select').value;
                    if (selectedEffectName) {
                        const selectedEffect = effectDict.find(e => (e.correct_effect_names || e.effect_name) === selectedEffectName);
                        if (selectedEffect) {
                            const effectTypeDisplay = selectedEffect.effect_type ? getEffectTypeDisplayName(selectedEffect.effect_type) : '';
                            const categoryDisplay = selectedEffect.category ? getCategoryDisplayName(selectedEffect.category, selectedEffect.effect_type) : '';
                            newSlot.querySelector('#new-slot-effect-type-display').textContent = effectTypeDisplay ? `${effectTypeDisplay}:${categoryDisplay}` : '';
                        }
                    } else {
                        newSlot.querySelector('#new-slot-effect-type-display').textContent = '';
                    }
                });

                // 要求数入力の変更を監視
                newSlot.querySelector('#new-slot-requirement-count').addEventListener('change', () => {
                    newSlotRequirementCount = parseInt(newSlot.querySelector('#new-slot-requirement-count').value) || 1;
                    updateNewSlotRequirementDisplay();
                });

                // 決定ボタンの処理（イベントリスナーで処理）
                newSlot.querySelector('.new-confirm-btn').addEventListener('click', () => {
                    const skillText = newSlot.querySelector('.new-confirm-btn').dataset.skillText;
                    const select = newSlot.querySelector('#new-effect-name-select');
                    const selectedEffectName = select.value;
                    if (!selectedEffectName) {
                        alert('効果名を選択してください');
                        return;
                    }

                    // 選択された効果の情報を取得
                    const selectedEffect = effectDict.find(e => (e.correct_effect_names || e.effect_name) === selectedEffectName);
                    if (!selectedEffect) {
                        alert('効果情報が見つかりません');
                        return;
                    }

                    // 直接addPendingChangeを呼ぶ
                    const target = newSlotSelectedTargets.length > 0 ? newSlotSelectedTargets.join(',') : null;
                    const conditionTarget = newSlotSelectedConditionTargets.length > 0 ? newSlotSelectedConditionTargets.join(',') : null;
                    const hasRequirement = newSlotSelectedRequirements.length > 0;
                    const requirementDetails = hasRequirement && newSlotSelectedRequirements.length > 0
                        ? newSlotSelectedRequirements.map(r => `${r.type}:${r.value}${r.is_not ? '!' : ''}`).join(',')
                        : null;
                    const requirementCount = hasRequirement ? newSlotRequirementCount : null;

                    addPendingChange({
                        type: 'add',
                        skill_text: skillText,
                        effect_name: selectedEffectName,
                        data: {
                            effect_name: selectedEffectName,
                            effect_type: selectedEffect.effect_type,
                            category: selectedEffect.category,
                            target: target,
                            condition_target: conditionTarget,
                            has_requirement: hasRequirement,
                            requirement_details: requirementDetails,
                            requirement_count: requirementCount
                        }
                    });

                    // スロットを削除して再描画
                    newSlot.remove();
                    const parentModal = container.closest('.modal-overlay');
                    const activeTab = parentModal.querySelector('.skill-tab-btn.active');
                    if (activeTab) {
                        const currentSkillType = activeTab.dataset.skillType;
                        loadSkillManagementContent(parentModal, alienData, currentSkillType);
                    }
                });

                // キャンセルボタンの処理（イベントリスナーで処理）
                newSlot.querySelector('.new-cancel-btn').addEventListener('click', () => {
                    newSlot.remove();
                });
            };
            // インデックスベースの編集関数
            window.editEffectByIndex = (text, index, name) => {
                // containerとalienDataを再取得
                const skillManagementModal = document.querySelector('.modal-overlay:has(#skill-management-content)');
                if (!skillManagementModal) {
                    alert('管理モーダルが見つかりません');
                    return;
                }
                const currentContainer = skillManagementModal.querySelector('#skill-management-content');
                if (!currentContainer) {
                    alert('コンテンツエリアが見つかりません');
                    return;
                }
                const activeTab = skillManagementModal.querySelector('.skill-tab-btn.active');
                if (!activeTab) {
                    alert('アクティブなタブが見つかりません');
                    return;
                }
                const currentSkillType = activeTab.dataset.skillType;
                let alienIdStr = activeTab.dataset.alienId;
                // data-alien-idが存在しない場合は、モーダルのヘッダーから取得を試みる
                if (!alienIdStr) {
                    const headerName = skillManagementModal.querySelector('h2');
                    if (headerName) {
                        const alienName = headerName.textContent.trim();
                        // ALL_ALIENSから名前で検索
                        const foundAlien = Object.values(ALL_ALIENS).find(a => a.name === alienName);
                        if (foundAlien) {
                            alienIdStr = String(foundAlien.id);
                        }
                    }
                }
                if (!alienIdStr) {
                    alert('エイリアンIDが見つかりません');
                    return;
                }
                const currentAlienData = ALL_ALIENS[alienIdStr];
                if (!currentAlienData) {
                    alert('エイリアンデータが見つかりません');
                    return;
                }

                // 編集対象の効果データを取得（allEffectsからインデックスで取得）
                const alienEffects = ALIEN_EFFECTS[alienIdStr];
                const currentEffects = alienEffects && alienEffects[currentSkillType] ? alienEffects[currentSkillType] : [];
                const allEffectsForEdit = mergeEffectsWithPendingChanges(currentEffects, text);

                // インデックスで正確な効果を取得
                const effect = allEffectsForEdit[index];
                if (!effect) {
                    alert('効果データが見つかりません');
                    return;
                }

                // 既存の効果アイテムを探す（data-effect-indexで正確に識別）
                const effectsList = currentContainer.querySelector('#effects-list');
                const targetEffectItem = effectsList.querySelector(`.effect-item[data-effect-index="${index}"]`);

                if (!targetEffectItem) {
                    alert('効果アイテムが見つかりません');
                    return;
                }

                // 既存の効果アイテムを編集スロットに置き換え
                const isSpecialSkill = currentSkillType === 'S';
                const effectDict = isSpecialSkill ? S_SKILL_EFFECTS : ALL_EFFECTS;

                // 効果名をカテゴリで分類（addNewEffectと同じロジック）
                const effectsByTypeAndCategory = {};
                effectDict.forEach(e => {
                    const effectType = e.effect_type || '';
                    const effectCategory = e.category || '';
                    const key = `${effectType}_${effectCategory}`;
                    if (!effectsByTypeAndCategory[key]) {
                        effectsByTypeAndCategory[key] = [];
                    }
                    effectsByTypeAndCategory[key].push(e);
                });

                let categoryStructure;
                if (isSpecialSkill) {
                    categoryStructure = {
                        '回復系': [],
                        'バフ系': [],
                        'デバフ(状態異常)系': []
                    };
                    Object.keys(effectsByTypeAndCategory).forEach(key => {
                        const [effectType, ...categoryParts] = key.split('_');
                        const category = categoryParts.join('_');
                        if (category === 'S_SKILL_HEAL') {
                            categoryStructure['回復系'].push(key);
                        } else if (category === 'S_SKILL_BUFF') {
                            categoryStructure['バフ系'].push(key);
                        } else if (category === 'S_SKILL_DEBUFF') {
                            categoryStructure['デバフ(状態異常)系'].push(key);
                        }
                    });
                } else {
                    categoryStructure = {
                        'バフ': {
                            'アップ系': [],
                            '軽減系': [],
                            '抵抗系': [],
                            'その他バフ': []
                        },
                        'デバフ': {
                            'ダウン系': [],
                            'その他デバフ': []
                        },
                        '状態異常': {
                            '毒系': [],
                            '気絶系': [],
                            'その他状態異常': []
                        }
                    };
                    Object.keys(effectsByTypeAndCategory).forEach(key => {
                        const [effectType, ...categoryParts] = key.split('_');
                        const category = categoryParts.join('_');
                        if (effectType === 'BUFF') {
                            if (category === 'BUFF_BOOST') {
                                categoryStructure['バフ']['アップ系'].push(key);
                            } else if (category === 'BUFF_REDUCE') {
                                categoryStructure['バフ']['軽減系'].push(key);
                            } else if (category === 'BUFF_RESIST') {
                                categoryStructure['バフ']['抵抗系'].push(key);
                            } else {
                                categoryStructure['バフ']['その他バフ'].push(key);
                            }
                        } else if (effectType === 'DEBUFF') {
                            if (category === 'DEBUFF_DOWN' || category === 'DEBUFF_REDUCE') {
                                categoryStructure['デバフ']['ダウン系'].push(key);
                            } else {
                                categoryStructure['デバフ']['その他デバフ'].push(key);
                            }
                        } else if (effectType === 'STATUS') {
                            if (category === 'STATUS_POISON') {
                                categoryStructure['状態異常']['毒系'].push(key);
                            } else if (category === 'STATUS_STUN') {
                                categoryStructure['状態異常']['気絶系'].push(key);
                            } else {
                                categoryStructure['状態異常']['その他状態異常'].push(key);
                            }
                        }
                    });
                }

                // ドロップダウンオプションを生成
                let optionsHtml = '<option value="">効果名を選択</option>';
                if (isSpecialSkill) {
                    Object.keys(categoryStructure).forEach(mainCategory => {
                        const categoryKeys = categoryStructure[mainCategory];
                        categoryKeys.forEach(categoryKey => {
                            const effects = effectsByTypeAndCategory[categoryKey] || [];
                            effects.forEach(e => {
                                const effectName = e.correct_effect_names || e.effect_name || '';
                                if (effectName) {
                                    const selected = effectName === effect.effect_name ? 'selected' : '';
                                    optionsHtml += `<option value="${effectName}" ${selected}>${mainCategory} - ${effectName}</option>`;
                                }
                            });
                        });
                    });
                } else {
                    Object.keys(categoryStructure).forEach(mainCategory => {
                        const subCategories = categoryStructure[mainCategory];
                        Object.keys(subCategories).forEach(subCategory => {
                            const categoryKeys = subCategories[subCategory];
                            categoryKeys.forEach(categoryKey => {
                                const effects = effectsByTypeAndCategory[categoryKey] || [];
                                effects.forEach(e => {
                                    const effectName = e.correct_effect_names || e.effect_name || '';
                                    if (effectName) {
                                        const selected = effectName === effect.effect_name ? 'selected' : '';
                                        optionsHtml += `<option value="${effectName}" ${selected}>${mainCategory}/${subCategory} - ${effectName}</option>`;
                                    }
                                });
                            });
                        });
                    });
                }

                // 編集スロットを作成（addNewEffectと同じ構造）
                const editSlot = document.createElement('div');
                editSlot.className = 'effect-item';
                editSlot.style.cssText = 'border: 2px dashed var(--accent-green); padding: 1vh; margin-bottom: 1vh; border-radius: 0.5vh;';

                // 既存の値を取得
                let editSlotSelectedTargets = effect.target ? effect.target.split(',').map(t => t.trim()).filter(t => t) : [];
                let editSlotSelectedConditionTargets = effect.condition_target ? effect.condition_target.split(',').map(t => t.trim()).filter(t => t) : [];
                let editSlotSelectedRequirements = [];
                let editSlotRequirementCount = effect.requirement_count || 1;

                if (effect.has_requirement && effect.requirement_details) {
                    const reqParts = effect.requirement_details.split(',').map(s => s.trim());
                    editSlotSelectedRequirements = reqParts.map(reqPart => {
                        const isNot = reqPart.endsWith('!');
                        const reqValue = isNot ? reqPart.slice(0, -1) : reqPart;
                        const [type, value] = reqValue.split(':');
                        return { type, value, is_not: isNot };
                    }).filter(r => r.type && r.value);
                }
                // 表示更新関数（addNewEffectと同じ）
                const updateEditSlotTargetDisplay = () => {
                    const targetContainer = editSlot.querySelector('#edit-slot-target-selector');
                    targetContainer.innerHTML = '';
                    if (editSlotSelectedTargets.length === 0) {
                        targetContainer.innerHTML = '<span style="color: #aaa; font-size: 1.2vh;">未選択</span>';
                    } else {
                        editSlotSelectedTargets.forEach(target => {
                            const validStrings = ['自分', '味方全員', '敵全員', '敵単体'];
                            // 文字列形式または:を含まない値は画像として扱わない
                            if (validStrings.includes(target) || !target.includes(':')) {
                                targetContainer.innerHTML += `<span style="background-color: #2a4a5a; padding: 0.2vh 0.5vh; border-radius: 0.2vh; font-size: 1.2vh; margin-right: 0.3vh; ${!validStrings.includes(target) ? 'color: #ff8800;' : ''}">${target}</span>`;
                            } else {
                                const [cat, val] = target.split(':');
                                if (cat && val) {
                                    const iconUrl = `/static/icon/${cat}${val}.webp`;
                                    targetContainer.innerHTML += `<span style="display: inline-flex; align-items: center; background-color: #2a4a5a; padding: 0.2vh 0.5vh; border-radius: 0.2vh; margin-right: 0.3vh;">
                                    <img src="${iconUrl}" style="width: 1.5vh; height: 1.5vh; margin-right: 0.2vh;" onerror="this.style.display='none'">
                                    <span style="font-size: 1.2vh;">${target}</span>
                                </span>`;
                                } else {
                                    // 不正な形式の場合はテキストのみ表示
                                    targetContainer.innerHTML += `<span style="background-color: #2a4a5a; padding: 0.2vh 0.5vh; border-radius: 0.2vh; font-size: 1.2vh; margin-right: 0.3vh; color: #ff8800;">${target}</span>`;
                                }
                            }
                        });
                    }
                };

                const updateEditSlotConditionTargetDisplay = () => {
                    const conditionTargetContainer = editSlot.querySelector('#edit-slot-condition-target-selector');
                    conditionTargetContainer.innerHTML = '';
                    if (editSlotSelectedConditionTargets.length === 0) {
                        conditionTargetContainer.innerHTML = '<span style="color: #aaa; font-size: 1.2vh;">未選択</span>';
                    } else {
                        editSlotSelectedConditionTargets.forEach(target => {
                            // 文字列形式（「レジェンドボス」など）または:を含まない値は画像として扱わない
                            if (!target.includes(':')) {
                                const displayText = target === 'boss:1' ? 'レジェンドボス' : target;
                                conditionTargetContainer.innerHTML += `<span style="background-color: #2a4a5a; padding: 0.2vh 0.5vh; border-radius: 0.2vh; font-size: 1.2vh; margin-right: 0.3vh;">${displayText}</span>`;
                            } else {
                                const [cat, val] = target.split(':');
                                if (cat && val) {
                                    const iconUrl = `/static/icon/${cat}${val}.webp`;
                                    conditionTargetContainer.innerHTML += `<span style="display: inline-flex; align-items: center; background-color: #2a4a5a; padding: 0.2vh 0.5vh; border-radius: 0.2vh; margin-right: 0.3vh;">
                                    <img src="${iconUrl}" style="width: 1.5vh; height: 1.5vh; margin-right: 0.2vh;" onerror="this.style.display='none'">
                                    <span style="font-size: 1.2vh;">${target}</span>
                                </span>`;
                                } else {
                                    // 不正な形式の場合はテキストのみ表示
                                    conditionTargetContainer.innerHTML += `<span style="background-color: #2a4a5a; padding: 0.2vh 0.5vh; border-radius: 0.2vh; font-size: 1.2vh; margin-right: 0.3vh; color: #ff8800;">${target}</span>`;
                                }
                            }
                        });
                    }
                };

                const updateEditSlotRequirementDisplay = () => {
                    const requirementContainer = editSlot.querySelector('#edit-slot-requirement-selector');
                    requirementContainer.innerHTML = '';
                    if (editSlotSelectedRequirements.length === 0) {
                        requirementContainer.innerHTML = '<span style="color: #aaa; font-size: 1.2vh;">未選択</span>';
                    } else {
                        editSlotSelectedRequirements.forEach(req => {
                            const iconName = `${req.type}${req.value}`;
                            const iconUrl = `/static/icon/${iconName}.webp`;
                            const notStyle = req.is_not ? 'transform: scaleY(-1);' : '';
                            const countHtml = editSlotRequirementCount > 1 ? `<span style="position: absolute; top: -0.3vh; right: -0.3vh; background-color: var(--accent-green); color: var(--dark-bg); border-radius: 50%; width: 1.2vh; height: 1.2vh; display: flex; align-items: center; justify-content: center; font-size: 1vh; font-weight: bold;">${editSlotRequirementCount}</span>` : '';
                            requirementContainer.innerHTML += `<span style="display: inline-flex; align-items: center; position: relative; background-color: #2a4a5a; padding: 0.2vh 0.5vh; border-radius: 0.2vh; margin-right: 0.3vh;">
                            <img src="${iconUrl}" style="width: 1.5vh; height: 1.5vh; margin-right: 0.2vh; ${notStyle}" onerror="this.style.display='none'">
                            ${countHtml}
                        </span>`;
                        });
                    }
                };

                // 選択モーダル関数（addNewEffectと同じ、名前を変更）
                const openEditSlotTargetSelector = () => {
                    let tempSelectedTargets = [...editSlotSelectedTargets];
                    const selectorModal = document.createElement('div');
                    selectorModal.className = 'modal-overlay';
                    selectorModal.style.display = 'flex';

                    const updateButtonColors = () => {
                        selectorModal.querySelectorAll('button').forEach(btn => {
                            const onclickStr = btn.onclick ? btn.onclick.toString() : '';
                            if (onclickStr.includes('tempEditSelectTargetString')) {
                                const str = btn.textContent.trim();
                                if (['自分', '味方全員', '敵全員', '敵単体'].includes(str)) {
                                    btn.style.backgroundColor = tempSelectedTargets.includes(str) ? 'var(--accent-green)' : '#1a2a3a';
                                }
                            } else if (onclickStr.includes('tempEditSelectTargetCode')) {
                                const match = onclickStr.match(/tempEditSelectTargetCode\('([^']+)',\s*'([^']+)'\)/);
                                if (match) {
                                    const code = `${match[1]}:${match[2]}`;
                                    btn.style.backgroundColor = tempSelectedTargets.includes(code) ? 'var(--accent-green)' : '#1a2a3a';
                                }
                            }
                        });
                    };

                    selectorModal.innerHTML = createTargetSelectorHTML(
                        tempSelectedTargets,
                        'tempEditSelectTargetString',
                        'tempEditSelectTargetCode',
                        true,
                        'tempEditConfirmTargetSelection',
                        'cleanupTempEditTargetFunctions'
                    );

                    document.body.appendChild(selectorModal);
                    replaceIconImagesWithClones(selectorModal);

                    window.tempEditSelectTargetString = (str) => {
                        const validStrings = ['自分', '味方全員', '敵全員', '敵単体'];
                        if (tempSelectedTargets.includes(str)) {
                            tempSelectedTargets = tempSelectedTargets.filter(t => t !== str);
                        } else {
                            // 文字列形式を選択する場合、他の文字列形式を削除し、不正な値も削除
                            tempSelectedTargets = tempSelectedTargets.filter(t =>
                                !validStrings.includes(t) && t.includes(':') // 有効な文字列形式と不正な値（:を含まない）を削除
                            );
                            tempSelectedTargets.push(str);
                        }
                        updateButtonColors();
                    };

                    window.tempEditSelectTargetCode = (cat, val) => {
                        const code = `${cat}:${val}`;
                        if (tempSelectedTargets.includes(code)) {
                            tempSelectedTargets = tempSelectedTargets.filter(t => t !== code);
                        } else {
                            tempSelectedTargets.push(code);
                        }
                        updateButtonColors();
                    };

                    window.tempEditConfirmTargetSelection = () => {
                        editSlotSelectedTargets = [...tempSelectedTargets];
                        updateEditSlotTargetDisplay();
                        selectorModal.remove();
                        window.cleanupTempEditTargetFunctions();
                    };

                    window.cleanupTempEditTargetFunctions = () => {
                        delete window.tempEditSelectTargetString;
                        delete window.tempEditSelectTargetCode;
                        delete window.tempEditConfirmTargetSelection;
                        delete window.cleanupTempEditTargetFunctions;
                    };

                    selectorModal.addEventListener('click', (e) => {
                        if (e.target === selectorModal) {
                            selectorModal.remove();
                            window.cleanupTempEditTargetFunctions();
                        }
                    });
                };

                const openEditSlotConditionTargetSelector = () => {
                    let tempSelectedConditionTargets = [...editSlotSelectedConditionTargets];
                    const selectorModal = document.createElement('div');
                    selectorModal.className = 'modal-overlay';
                    selectorModal.style.display = 'flex';

                    const updateButtonColors = () => {
                        selectorModal.querySelectorAll('button').forEach(btn => {
                            const onclickStr = btn.onclick ? btn.onclick.toString() : '';
                            if (onclickStr.includes('tempEditSelectConditionTargetString')) {
                                const str = btn.textContent.trim();
                                const code = str === 'レジェンドボス' ? 'boss:1' : str;
                                btn.style.backgroundColor = tempSelectedConditionTargets.includes(code) ? 'var(--accent-green)' : '#1a2a3a';
                            } else if (onclickStr.includes('tempEditSelectConditionTargetCode')) {
                                const match = onclickStr.match(/tempEditSelectConditionTargetCode\('([^']+)',\s*'([^']+)'\)/);
                                if (match) {
                                    const code = `${match[1]}:${match[2]}`;
                                    btn.style.backgroundColor = tempSelectedConditionTargets.includes(code) ? 'var(--accent-green)' : '#1a2a3a';
                                }
                            }
                        });
                    };

                    selectorModal.innerHTML = `
                    <div class="modal-content" style="max-height: 80vh; overflow-y: auto; width: 90vw; max-width: 50vh;">
                        <h3 style="margin-top: 0; margin-bottom: 1vh; font-size: 1.6vh;">効果対象を選択</h3>
                        <div style="margin-bottom: 0.8vh;">
                            <div style="font-size: 1.4vh; margin-bottom: 0.5vh;"><strong>文字列形式:</strong></div>
                            <div style="display: flex; flex-wrap: wrap; gap: 0.6vh;">
                                <button type="button" onclick="tempEditSelectConditionTargetString('レジェンドボス')" 
                                        style="padding: 0.8vh 1.5vh; background-color: ${tempSelectedConditionTargets.includes('boss:1') ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh; color: var(--light-text); font-size: 1.4vh;">
                                    レジェンドボス
                                </button>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1vh;">
                            <div>
                                <div style="font-size: 1.4vh; margin-bottom: 0.5vh;"><strong>属性 (a):</strong></div>
                                <div style="display: flex; flex-wrap: wrap; gap: 0.6vh;">
                                    ${[1, 2, 3, 4].map(v => `
                                        <button type="button" onclick="tempEditSelectConditionTargetCode('a', '${v}')" 
                                                style="padding: 0.6vh; background-color: ${tempSelectedConditionTargets.includes(`a:${v}`) ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh;">
                                            <img src="/static/icon/a${v}.webp" style="width: 3vh; height: 3vh;">
                                        </button>
                                    `).join('')}
                                </div>
                            </div>
                            <div>
                                <div style="font-size: 1.4vh; margin-bottom: 0.5vh;"><strong>所属 (b):</strong></div>
                                <div style="display: flex; flex-wrap: wrap; gap: 0.6vh;">
                                    ${[1, 2, 3, 4, 5].map(v => `
                                        <button type="button" onclick="tempEditSelectConditionTargetCode('b', '${v}')" 
                                                style="padding: 0.6vh; background-color: ${tempSelectedConditionTargets.includes(`b:${v}`) ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh;">
                                            <img src="/static/icon/b${v}.webp" style="width: 3vh; height: 3vh;">
                                        </button>
                                    `).join('')}
                                </div>
                            </div>
                            <div>
                                <div style="font-size: 1.4vh; margin-bottom: 0.5vh;"><strong>攻撃はんい (c):</strong></div>
                                <div style="display: flex; flex-wrap: wrap; gap: 0.6vh;">
                                    ${[1, 2].map(v => `
                                        <button type="button" onclick="tempEditSelectConditionTargetCode('c', '${v}')" 
                                                style="padding: 0.6vh; background-color: ${tempSelectedConditionTargets.includes(`c:${v}`) ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh;">
                                            <img src="/static/icon/c${v}.webp" style="width: 3vh; height: 3vh;">
                                        </button>
                                    `).join('')}
                                </div>
                            </div>
                            <div>
                                <div style="font-size: 1.4vh; margin-bottom: 0.5vh;"><strong>攻撃距離 (d):</strong></div>
                                <div style="display: flex; flex-wrap: wrap; gap: 0.6vh;">
                                    ${[1, 2, 3].map(v => `
                                        <button type="button" onclick="tempEditSelectConditionTargetCode('d', '${v}')" 
                                                style="padding: 0.6vh; background-color: ${tempSelectedConditionTargets.includes(`d:${v}`) ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh;">
                                            <img src="/static/icon/d${v}.webp" style="width: 3vh; height: 3vh;">
                                        </button>
                                    `).join('')}
                                </div>
                            </div>
                        </div>
                        <button class="control-button" onclick="tempEditConfirmConditionTargetSelection()" style="margin-top: 0.8vh; padding: 0.8vh 2vh; font-size: 1.4vh;">決定</button>
                        <button class="control-button" onclick="this.closest('.modal-overlay').remove(); cleanupTempEditConditionTargetFunctions();" style="margin-top: 0.8vh; padding: 0.8vh 2vh; font-size: 1.4vh;">キャンセル</button>
                    </div>
                `;

                    document.body.appendChild(selectorModal);
                    replaceIconImagesWithClones(selectorModal);

                    window.tempEditSelectConditionTargetString = (str) => {
                        const code = str === 'レジェンドボス' ? 'boss:1' : str;
                        if (tempSelectedConditionTargets.includes(code)) {
                            tempSelectedConditionTargets = tempSelectedConditionTargets.filter(t => t !== code);
                        } else {
                            tempSelectedConditionTargets.push(code);
                        }
                        updateButtonColors();
                    };

                    window.tempEditSelectConditionTargetCode = (cat, val) => {
                        const code = `${cat}:${val}`;
                        if (tempSelectedConditionTargets.includes(code)) {
                            tempSelectedConditionTargets = tempSelectedConditionTargets.filter(t => t !== code);
                        } else {
                            tempSelectedConditionTargets.push(code);
                        }
                        updateButtonColors();
                    };

                    window.tempEditConfirmConditionTargetSelection = () => {
                        editSlotSelectedConditionTargets = [...tempSelectedConditionTargets];
                        updateEditSlotConditionTargetDisplay();
                        selectorModal.remove();
                        cleanupTempEditConditionTargetFunctions();
                    };

                    window.cleanupTempEditConditionTargetFunctions = () => {
                        delete window.tempEditSelectConditionTargetString;
                        delete window.tempEditSelectConditionTargetCode;
                        delete window.tempEditConfirmConditionTargetSelection;
                        delete window.cleanupTempEditConditionTargetFunctions;
                    };

                    selectorModal.addEventListener('click', (e) => {
                        if (e.target === selectorModal) {
                            selectorModal.remove();
                            cleanupTempEditConditionTargetFunctions();
                        }
                    });
                };
                // 要求選択モーダル（addNewEffectと同じ、名前を変更）
                const openEditSlotRequirementSelector = () => {
                    let tempSelectedRequirements = [...editSlotSelectedRequirements];
                    const selectorModal = document.createElement('div');
                    selectorModal.className = 'modal-overlay';
                    selectorModal.style.display = 'flex';

                    // 改善された要求選択UI（チェックボックスで「◯以外」を選択）
                    selectorModal.innerHTML = `
                    <div class="modal-content" style="max-height: 85vh; overflow-y: auto; width: 95vw; max-width: 70vh;">
                        <h3 style="margin-top: 0; margin-bottom: 1vh; font-size: 1.6vh;">要求（味方編成条件）を選択</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1vh; margin-bottom: 1vh;">
                            <div>
                                <div style="font-size: 1.3vh; margin-bottom: 0.5vh; font-weight: bold;">属性 (a):</div>
                                <div style="display: flex; flex-wrap: wrap; gap: 0.5vh;">
                                    ${[1, 2, 3, 4].map(v => {
                        const isSelected = tempSelectedRequirements.some(r => r.type === 'a' && r.value === String(v));
                        return `
                                            <button type="button" onclick="tempEditSelectRequirementCode('a', '${v}')" 
                                                    style="padding: 0.5vh; background-color: ${isSelected ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh; position: relative;">
                                                <img src="/static/icon/a${v}.webp" style="width: 2.5vh; height: 2.5vh;">
                                            </button>
                                        `;
                    }).join('')}
                                </div>
                            </div>
                            <div>
                                <div style="font-size: 1.3vh; margin-bottom: 0.5vh; font-weight: bold;">所属 (b):</div>
                                <div style="display: flex; flex-wrap: wrap; gap: 0.5vh;">
                                    ${[1, 2, 3, 4, 5].map(v => {
                        const isSelected = tempSelectedRequirements.some(r => r.type === 'b' && r.value === String(v));
                        return `
                                            <button type="button" onclick="tempEditSelectRequirementCode('b', '${v}')" 
                                                    style="padding: 0.5vh; background-color: ${isSelected ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh; position: relative;">
                                                <img src="/static/icon/b${v}.webp" style="width: 2.5vh; height: 2.5vh;">
                                            </button>
                                        `;
                    }).join('')}
                                </div>
                            </div>
                            <div>
                                <div style="font-size: 1.3vh; margin-bottom: 0.5vh; font-weight: bold;">攻撃はんい (c):</div>
                                <div style="display: flex; flex-wrap: wrap; gap: 0.5vh;">
                                    ${[1, 2].map(v => {
                        const isSelected = tempSelectedRequirements.some(r => r.type === 'c' && r.value === String(v));
                        return `
                                            <button type="button" onclick="tempEditSelectRequirementCode('c', '${v}')" 
                                                    style="padding: 0.5vh; background-color: ${isSelected ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh; position: relative;">
                                                <img src="/static/icon/c${v}.webp" style="width: 2.5vh; height: 2.5vh;">
                                            </button>
                                        `;
                    }).join('')}
                                </div>
                            </div>
                            <div>
                                <div style="font-size: 1.3vh; margin-bottom: 0.5vh; font-weight: bold;">攻撃距離 (d):</div>
                                <div style="display: flex; flex-wrap: wrap; gap: 0.5vh;">
                                    ${[1, 2, 3].map(v => {
                        const isSelected = tempSelectedRequirements.some(r => r.type === 'd' && r.value === String(v));
                        return `
                                            <button type="button" onclick="tempEditSelectRequirementCode('d', '${v}')" 
                                                    style="padding: 0.5vh; background-color: ${isSelected ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh; position: relative;">
                                                <img src="/static/icon/d${v}.webp" style="width: 2.5vh; height: 2.5vh;">
                                            </button>
                                        `;
                    }).join('')}
                                </div>
                            </div>
                        </div>
                        <div style="margin-bottom: 1vh;">
                            <div style="font-size: 1.3vh; margin-bottom: 0.5vh; font-weight: bold;">タイプ (e):</div>
                            <div style="display: flex; flex-wrap: wrap; gap: 0.5vh;">
                                ${['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q'].map(v => {
                        const isSelected = tempSelectedRequirements.some(r => r.type === 'e' && r.value === String(v));
                        return `
                                        <button type="button" onclick="tempEditSelectRequirementCode('e', '${v}')" 
                                                style="padding: 0.5vh; background-color: ${isSelected ? 'var(--accent-green)' : '#1a2a3a'}; border: 1px solid #4a5a6a; border-radius: 0.3vh; position: relative;">
                                            <img src="/static/icon/e${v}.webp" style="width: 2.5vh; height: 2.5vh;">
                                        </button>
                                    `;
                    }).join('')}
                            </div>
                        </div>
                        <div style="display: flex; gap: 1vh; margin-top: 1vh; justify-content: space-between; align-items: center; padding-top: 1vh; border-top: 1px solid #4a5a6a;">
                            <label style="display: flex; align-items: center; gap: 0.5vh; font-size: 1.3vh; cursor: pointer;">
                                <input type="checkbox" id="temp-edit-requirement-not-checkbox" 
                                       ${tempSelectedRequirements.some(r => r.is_not) ? 'checked' : ''}
                                       style="width: 1.5vh; height: 1.5vh; cursor: pointer;">
                                <span>選択した条件以外</span>
                            </label>
                            <div style="display: flex; gap: 1vh;">
                                <button class="control-button" onclick="tempEditConfirmRequirementSelection()" style="padding: 0.8vh 2vh; font-size: 1.4vh; background-color: #ff8800; color: white; border: none; border-radius: 0.3vh; cursor: pointer;">決定</button>
                                <button class="control-button" onclick="this.closest('.modal-overlay').remove(); cleanupTempEditRequirementFunctions();" style="padding: 0.8vh 2vh; font-size: 1.4vh; background-color: #4a5a6a; color: var(--light-text); border: none; border-radius: 0.3vh; cursor: pointer;">キャンセル</button>
                            </div>
                        </div>
                    </div>
                `;

                    document.body.appendChild(selectorModal);
                    replaceIconImagesWithClones(selectorModal);

                    let tempEditRequirementNotChecked = tempSelectedRequirements.some(r => r.is_not);

                    window.tempEditSelectRequirementCode = (type, value) => {
                        const existing = tempSelectedRequirements.find(r => r.type === type && r.value === value);
                        if (existing) {
                            // 既存の選択を削除
                            tempSelectedRequirements.splice(tempSelectedRequirements.indexOf(existing), 1);
                        } else {
                            // 新しい選択を追加（他の選択をクリア）
                            tempSelectedRequirements.splice(0, tempSelectedRequirements.length);
                            tempSelectedRequirements.push({ type, value, is_not: false });
                        }

                        // 「以外」チェックボックスの状態を適用
                        const notCheckbox = selectorModal.querySelector('#temp-edit-requirement-not-checkbox');
                        if (notCheckbox && notCheckbox.checked && tempSelectedRequirements.length > 0) {
                            tempSelectedRequirements.forEach(r => r.is_not = true);
                        }

                        // ボタンの色を更新
                        selectorModal.querySelectorAll('button[onclick*="tempEditSelectRequirementCode"]').forEach(btn => {
                            const onclickStr = btn.onclick ? btn.onclick.toString() : '';
                            if (onclickStr.includes(`'${type}', '${value}'`)) {
                                const isSelected = tempSelectedRequirements.some(r => r.type === type && r.value === value);
                                btn.style.backgroundColor = isSelected ? 'var(--accent-green)' : '#1a2a3a';
                            }
                        });
                    };

                    // 「以外」チェックボックスのイベントリスナー
                    const notCheckbox = selectorModal.querySelector('#temp-edit-requirement-not-checkbox');
                    if (notCheckbox) {
                        notCheckbox.addEventListener('change', (e) => {
                            tempEditRequirementNotChecked = e.target.checked;
                            if (tempSelectedRequirements.length > 0) {
                                tempSelectedRequirements.forEach(r => r.is_not = tempEditRequirementNotChecked);
                            }
                        });
                    }

                    window.tempEditConfirmRequirementSelection = () => {
                        // 「以外」チェックボックスの状態を適用
                        const notCheckbox = selectorModal.querySelector('#temp-edit-requirement-not-checkbox');
                        if (notCheckbox && notCheckbox.checked && tempSelectedRequirements.length > 0) {
                            tempSelectedRequirements.forEach(r => r.is_not = true);
                        }
                        editSlotSelectedRequirements = [...tempSelectedRequirements];
                        updateEditSlotRequirementDisplay();
                        selectorModal.remove();
                        cleanupTempEditRequirementFunctions();
                    };

                    window.cleanupTempEditRequirementFunctions = () => {
                        delete window.tempEditSelectRequirementCode;
                        delete window.tempEditConfirmRequirementSelection;
                        delete window.cleanupTempEditRequirementFunctions;
                    };

                    selectorModal.addEventListener('click', (e) => {
                        if (e.target === selectorModal) {
                            selectorModal.remove();
                            cleanupTempEditRequirementFunctions();
                        }
                    });
                };

                // スロットのHTML（addNewEffectと同じ構造）
                const selectedEffect = effectDict.find(e => (e.correct_effect_names || e.effect_name) === effect.effect_name);
                const effectTypeDisplay = selectedEffect && selectedEffect.effect_type ? getEffectTypeDisplayName(selectedEffect.effect_type) : '';
                const categoryDisplay = selectedEffect && selectedEffect.category ? getCategoryDisplayName(selectedEffect.category, selectedEffect.effect_type) : '';

                editSlot.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5vh;">
                    <div>
                        <select id="edit-effect-name-select" style="padding: 0.5vh; background-color: #1a2a3a; border: 1px solid #4a5a6a; border-radius: 0.3vh; color: var(--light-text); font-size: 1.2vh; width: 20vh;">
                            ${optionsHtml}
                        </select>
                    </div>
                    <div id="edit-slot-effect-type-display" style="font-size: 1.2vh; color: #aaa;">${effectTypeDisplay ? `${effectTypeDisplay}:${categoryDisplay}` : ''}</div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1vh; margin-bottom: 0.5vh;">
                    <div>
                        <label style="display: block; margin-bottom: 0.3vh; font-size: 1.2vh;"><strong>バフ/デバフ対象:</strong></label>
                        <div id="edit-slot-target-selector" style="display: flex; flex-wrap: wrap; gap: 0.5vh; border: 1px solid #4a5a6a; padding: 0.5vh; border-radius: 0.3vh; min-height: 3vh; background-color: #1a2a3a; cursor: pointer;">
                            <span style="color: #aaa; font-size: 1.2vh;">未選択</span>
                        </div>
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 0.3vh; font-size: 1.2vh;"><strong>効果対象:</strong></label>
                        <div id="edit-slot-condition-target-selector" style="display: flex; flex-wrap: wrap; gap: 0.5vh; border: 1px solid #4a5a6a; padding: 0.5vh; border-radius: 0.3vh; min-height: 3vh; background-color: #1a2a3a; cursor: pointer;">
                            <span style="color: #aaa; font-size: 1.2vh;">未選択</span>
                        </div>
                    </div>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div style="flex: 1;">
                        <label style="display: block; margin-bottom: 0.3vh; font-size: 1.2vh;"><strong>要求:</strong></label>
                        <div id="edit-slot-requirement-selector" style="display: flex; flex-wrap: wrap; gap: 0.5vh; border: 1px solid #4a5a6a; padding: 0.5vh; border-radius: 0.3vh; min-height: 3vh; background-color: #1a2a3a; cursor: pointer;">
                            <span style="color: #aaa; font-size: 1.2vh;">未選択</span>
                        </div>
                        <input type="number" id="edit-slot-requirement-count" value="${editSlotRequirementCount}" min="1" style="width: 5vh; margin-top: 0.3vh; padding: 0.3vh; background-color: #1a2a3a; border: 1px solid #4a5a6a; border-radius: 0.3vh; color: var(--light-text); font-size: 1.2vh;">
                    </div>
                    <div style="display: flex; gap: 0.3vh;">
                        <button class="control-button edit-confirm-btn" data-skill-text="${text.replace(/'/g, "\\'")}" data-effect-name="${name.replace(/'/g, "\\'")}" style="font-size: 1.3vh; padding: 0.4vh 0.8vh;">決定</button>
                        <button class="control-button edit-cancel-btn" data-effect-name="${name.replace(/'/g, "\\'")}" style="font-size: 1.3vh; padding: 0.4vh 0.8vh;">キャンセル</button>
                    </div>
                </div>
            `;
                // 既存の表示を更新
                updateEditSlotTargetDisplay();
                updateEditSlotConditionTargetDisplay();
                updateEditSlotRequirementDisplay();

                // イベントリスナーを設定
                editSlot.querySelector('#edit-slot-target-selector').addEventListener('click', openEditSlotTargetSelector);
                editSlot.querySelector('#edit-slot-condition-target-selector').addEventListener('click', openEditSlotConditionTargetSelector);
                editSlot.querySelector('#edit-slot-requirement-selector').addEventListener('click', openEditSlotRequirementSelector);

                // 効果名選択時に効果タイプを表示
                editSlot.querySelector('#edit-effect-name-select').addEventListener('change', () => {
                    const selectedEffectName = editSlot.querySelector('#edit-effect-name-select').value;
                    if (selectedEffectName) {
                        const selectedEffect = effectDict.find(e => (e.correct_effect_names || e.effect_name) === selectedEffectName);
                        if (selectedEffect) {
                            const effectTypeDisplay = selectedEffect.effect_type ? getEffectTypeDisplayName(selectedEffect.effect_type) : '';
                            const categoryDisplay = selectedEffect.category ? getCategoryDisplayName(selectedEffect.category, selectedEffect.effect_type) : '';
                            editSlot.querySelector('#edit-slot-effect-type-display').textContent = effectTypeDisplay ? `${effectTypeDisplay}:${categoryDisplay}` : '';
                        }
                    } else {
                        editSlot.querySelector('#edit-slot-effect-type-display').textContent = '';
                    }
                });

                // 要求数入力の変更を監視
                editSlot.querySelector('#edit-slot-requirement-count').addEventListener('change', () => {
                    editSlotRequirementCount = parseInt(editSlot.querySelector('#edit-slot-requirement-count').value) || 1;
                    updateEditSlotRequirementDisplay();
                });

                // 決定ボタンの処理（イベントリスナーで処理）
                editSlot.querySelector('.edit-confirm-btn').addEventListener('click', () => {
                    const skillText = editSlot.querySelector('.edit-confirm-btn').dataset.skillText;
                    const oldEffectName = editSlot.querySelector('.edit-confirm-btn').dataset.effectName;
                    const select = editSlot.querySelector('#edit-effect-name-select');
                    const selectedEffectName = select.value;
                    if (!selectedEffectName) {
                        alert('効果名を選択してください');
                        return;
                    }

                    // 選択された効果の情報を取得
                    const selectedEffect = effectDict.find(e => (e.correct_effect_names || e.effect_name) === selectedEffectName);
                    if (!selectedEffect) {
                        alert('効果情報が見つかりません');
                        return;
                    }

                    // 元の効果データと比較
                    const target = editSlotSelectedTargets.length > 0 ? editSlotSelectedTargets.join(',') : null;
                    const conditionTarget = editSlotSelectedConditionTargets.length > 0 ? editSlotSelectedConditionTargets.join(',') : null;
                    const hasRequirement = editSlotSelectedRequirements.length > 0;
                    const requirementDetails = hasRequirement && editSlotSelectedRequirements.length > 0
                        ? editSlotSelectedRequirements.map(r => `${r.type}:${r.value}${r.is_not ? '!' : ''}`).join(',')
                        : null;
                    const requirementCount = hasRequirement ? editSlotRequirementCount : null;

                    // 元の効果データを取得（pendingChangesを反映する前の状態、つまりDBの元の状態）
                    // currentEffectsはALIEN_EFFECTSから取得したDBの元の状態
                    const originalEffect = currentEffects.find(e => e.effect_name === oldEffectName);
                    if (originalEffect) {
                        // 元の状態と比較（null/undefinedを正規化）
                        const normalizeValue = (val) => {
                            if (val === null || val === undefined || val === '') return null;
                            return String(val);
                        };

                        const originalTarget = normalizeValue(originalEffect.target);
                        const originalConditionTarget = normalizeValue(originalEffect.condition_target);
                        const originalHasRequirement = originalEffect.has_requirement || false;
                        const originalRequirementDetails = normalizeValue(originalEffect.requirement_details);
                        const originalRequirementCount = normalizeValue(originalEffect.requirement_count);
                        const originalEffectName = originalEffect.effect_name;
                        const originalEffectType = originalEffect.effect_type || null;
                        const originalCategory = originalEffect.category || null;

                        const newTarget = normalizeValue(target);
                        const newConditionTarget = normalizeValue(conditionTarget);
                        const newRequirementDetails = normalizeValue(requirementDetails);
                        const newRequirementCount = normalizeValue(requirementCount);
                        const newEffectType = selectedEffect.effect_type || null;
                        const newCategory = selectedEffect.category || null;

                        // DBの元の状態と比較（すべてのフィールドを比較）
                        const isSame =
                            selectedEffectName === originalEffectName &&
                            newEffectType === originalEffectType &&
                            newCategory === originalCategory &&
                            newTarget === originalTarget &&
                            newConditionTarget === originalConditionTarget &&
                            hasRequirement === originalHasRequirement &&
                            newRequirementDetails === originalRequirementDetails &&
                            newRequirementCount === originalRequirementCount;

                        if (isSame) {
                            // 元の状態に戻った場合はpendingChangesから削除
                            pendingChanges = pendingChanges.filter(c =>
                                !(c.skill_text === skillText &&
                                    (c.effect_name === oldEffectName || c.effect_name === selectedEffectName) &&
                                    (c.type === 'update' || c.type === 'delete'))
                            );
                            updateAdminUI();
                        } else {
                            // 変更がある場合はaddPendingChangeを呼ぶ（既存の変更を上書き）
                            addPendingChange({
                                type: 'update',
                                skill_text: skillText,
                                effect_name: oldEffectName,
                                new_effect_name: selectedEffectName,
                                data: {
                                    effect_name: selectedEffectName,
                                    effect_type: selectedEffect.effect_type,
                                    category: selectedEffect.category,
                                    target: target,
                                    condition_target: conditionTarget,
                                    has_requirement: hasRequirement,
                                    requirement_details: requirementDetails,
                                    requirement_count: requirementCount
                                }
                            });
                        }
                    } else {
                        // 元の効果が見つからない場合は通常通り追加
                        addPendingChange({
                            type: 'update',
                            skill_text: skillText,
                            effect_name: oldEffectName,
                            new_effect_name: selectedEffectName,
                            data: {
                                effect_name: selectedEffectName,
                                effect_type: selectedEffect.effect_type,
                                category: selectedEffect.category,
                                target: target,
                                condition_target: conditionTarget,
                                has_requirement: hasRequirement,
                                requirement_details: requirementDetails,
                                requirement_count: requirementCount
                            }
                        });
                    }

                    // スロットを削除して再描画
                    editSlot.remove();
                    const parentModal = currentContainer.closest('.modal-overlay');
                    const activeTab = parentModal.querySelector('.skill-tab-btn.active');
                    if (activeTab) {
                        const currentSkillType = activeTab.dataset.skillType;
                        loadSkillManagementContent(parentModal, currentAlienData, currentSkillType);
                    }
                });

                // キャンセルボタンの処理（イベントリスナーで処理）
                editSlot.querySelector('.edit-cancel-btn').addEventListener('click', () => {
                    editSlot.remove();
                    // 再描画して元の状態に戻す
                    const parentModal = currentContainer.closest('.modal-overlay');
                    const activeTab = parentModal.querySelector('.skill-tab-btn.active');
                    if (activeTab) {
                        const currentSkillType = activeTab.dataset.skillType;
                        loadSkillManagementContent(parentModal, currentAlienData, currentSkillType);
                    }
                });

                // 既存の効果アイテムを編集スロットに置き換え
                targetEffectItem.replaceWith(editSlot);
            };

            // 削除マークを付ける関数（変更適応時に削除）
            window.markEffectForDelete = (text, name) => {
                addPendingChange({
                    type: 'delete',
                    skill_text: text,
                    effect_name: name
                });

                // 再描画
                const skillManagementModal = document.querySelector('.modal-overlay:has(#skill-management-content)');
                if (!skillManagementModal) return;
                const activeTab = skillManagementModal.querySelector('.skill-tab-btn.active');
                if (activeTab) {
                    const currentSkillType = activeTab.dataset.skillType;
                    let alienIdStr = activeTab.dataset.alienId;
                    if (!alienIdStr) {
                        const headerName = skillManagementModal.querySelector('h2');
                        if (headerName) {
                            const alienName = headerName.textContent.trim();
                            const foundAlien = Object.values(ALL_ALIENS).find(a => a.name === alienName);
                            if (foundAlien) {
                                alienIdStr = String(foundAlien.id);
                            }
                        }
                    }
                    if (alienIdStr) {
                        const alienData = ALL_ALIENS[alienIdStr];
                        if (alienData) {
                            loadSkillManagementContent(skillManagementModal, alienData, currentSkillType);
                        }
                    }
                }
            };

            // 削除マークをキャンセルする関数
            window.cancelDeleteEffect = (text, name) => {
                // pendingChangesから削除を削除
                pendingChanges = pendingChanges.filter(c =>
                    !(c.skill_text === text && c.effect_name === name && c.type === 'delete')
                );
                updateAdminUI();

                // 再描画
                const skillManagementModal = document.querySelector('.modal-overlay:has(#skill-management-content)');
                if (!skillManagementModal) return;
                const activeTab = skillManagementModal.querySelector('.skill-tab-btn.active');
                if (activeTab) {
                    const currentSkillType = activeTab.dataset.skillType;
                    let alienIdStr = activeTab.dataset.alienId;
                    if (!alienIdStr) {
                        const headerName = skillManagementModal.querySelector('h2');
                        if (headerName) {
                            const alienName = headerName.textContent.trim();
                            const foundAlien = Object.values(ALL_ALIENS).find(a => a.name === alienName);
                            if (foundAlien) {
                                alienIdStr = String(foundAlien.id);
                            }
                        }
                    }
                    if (alienIdStr) {
                        const alienData = ALL_ALIENS[alienIdStr];
                        if (alienData) {
                            loadSkillManagementContent(skillManagementModal, alienData, currentSkillType);
                        }
                    }
                }
            };
        }

        // openEffectFormModal関数は削除されました（インライン編集スロットに置き換え）

        // 起動時の認証状態確認は、管理モード維持処理の後に実行される

        createFilterButtons();
        renderAllParties(); // 全パーティを最初に描画
        renderDrawerPartyPreview(); // ドロワープレビューも初期化
        updatePartySelectorUI();

        // エイリアン一覧の初期表示を確実にする
        // DOMContentLoaded後に実行することで、allAliensDataが確実に構築される
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(() => applyFilters(), 100);
            });
        } else {
            setTimeout(() => applyFilters(), 100);
        }

        // ！！！ (★追加★) 全ての描画が終わった後に、判定処理を呼び出す ！！！
        // 少し遅延させることで、DOMの準備が整うのを待つ
        setTimeout(checkAllPartiesRealtime, 100);

        // 管理モードを維持してリロードした場合の処理
        if (sessionStorage.getItem('adminModeAfterReload') === 'true') {
            sessionStorage.removeItem('adminModeAfterReload');
            // パスワード入力モーダルを表示せずに自動でログイン状態を確認
            fetch('/api/admin/check-auth')
                .then(response => response.json())
                .then(data => {
                    if (data.logged_in) {  // is_adminではなくlogged_in
                        isAdminMode = true;
                        updateAdminUI();
                        loadEffectUsageStats().then(() => {
                            updateAdminUI();
                        });
                    } else {
                        // 認証が失敗した場合は自動ログアウト処理を実行
                        isAdminMode = false;
                        updateAdminUI();
                    }
                })
                .catch(error => {
                    console.error('管理モード確認エラー:', error);
                    isAdminMode = false;
                    updateAdminUI();
                });
        } else {
            // ページロード時は自動的にログアウト（管理モード維持処理がない場合のみ）
            if (isAdminMode) {
                (async () => {
                    await logoutAdmin();
                    isAdminMode = false;
                    updateAdminUI();
                })();
            }
        }

    </script>
</body>

</html>