<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>エリたま バフデータ作成ツール Ver. 4.3</title>
    <style>
        :root {
            --dark-bg: #1e2a38; --medium-bg: #2a3a4a; --light-bg: #3a4a5a;
            --text-color: #e1e1e1; --accent-color: #00ffc8; --border-color: #5a6a7a;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background-color: var(--dark-bg); color: var(--text-color); margin: 0; display: flex; flex-direction: column; height: 100vh; font-size: 14px; }
        .main-layout { display: flex; flex-grow: 1; overflow: hidden; }
        .sidebar { background-color: var(--medium-bg); padding: 15px; display: flex; flex-direction: column; width: 240px; border-right: 1px solid var(--border-color); }
        .main-content { padding: 25px; overflow-y: auto; flex-grow: 1; }
        .bottom-panel { background-color: var(--dark-bg); border-top: 2px solid var(--border-color); height: 200px; flex-shrink: 0; padding: 10px; overflow-y: auto; }
        h1, h2, h3 { color: var(--accent-color); border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-top: 0; }
        h4 { margin: 10px 0 5px 0; }
        button { padding: 8px 12px; border-radius: 4px; border: none; cursor: pointer; background-color: var(--light-bg); color: #fff; font-size: 12px; transition: background-color 0.2s; }
        button:hover { filter: brightness(1.2); }
        .loader { text-align: center; padding: 50px; font-size: 1.5em; color: var(--accent-color); }

        .alien-list-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px; }
        .alien-icon { cursor: pointer; text-align: center; position: relative; }
        .alien-icon img { width: 100%; max-width: 80px; border-radius: 8px; border: 3px solid transparent; }
        .alien-icon.active img { border-color: var(--accent-color); box-shadow: 0 0 10px var(--accent-color); }
        .alien-icon .status-marker { position: absolute; top: 2px; right: 2px; width: 12px; height: 12px; border-radius: 50%; border: 2px solid var(--medium-bg); }
        .alien-icon .status-marker.complete { background-color: #28a745; }
        .alien-icon .status-marker.unknown { background-color: #ffc107; }
        .alien-icon .status-marker.incomplete { background-color: #dc3545; }
        .alien-icon span { font-size: 10px; display: block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-top: 2px; }
        
        .buff-name-list { list-style: none; padding: 0; margin: 0; font-size: 12px; max-height: calc(50% - 40px); overflow-y: auto; }
        .buff-name-list li:nth-child(odd) { background-color: var(--light-bg); }

        .skill-card { background-color: var(--medium-bg); padding: 15px; border-radius: 8px; margin-bottom: 15px; }
        .skill-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 10px; }
        .skill-text { background-color: var(--dark-bg); padding: 10px; border-radius: 4px; margin: 10px 0; line-height: 1.6; }
        .buff-header { display: grid; grid-template-columns: 30px 1fr 130px 70px 80px 100px 50px 50px 50px 40px; gap: 8px; font-size: 10px; color: #aaa; margin-bottom: 5px; padding-left: 10px; }
        .buff-row { display: grid; grid-template-columns: 30px 1fr 130px 70px 80px 100px 50px 50px 50px 40px; align-items: center; gap: 8px; margin-bottom: 8px; font-size: 12px; }
        input, select { width: 100%; padding: 6px; border-radius: 4px; border: 1px solid var(--border-color); background-color: var(--dark-bg); color: #fff; box-sizing: border-box; }
        .buff-row input.is-debuff { background-color: rgba(0, 123, 255, 0.2); }
        .buff-row input.is-buff { background-color: rgba(220, 53, 69, 0.1); }
        .add-buff { background-color: #28a745; }
        .add-debuff { background-color: #007bff; }
        .delete-buff { background-color: #dc3545; }
        .no-buff { background-color: #ffc107; color: #000; }
        #save-btn { width: 100%; padding: 15px; font-size: 1.2em; background-color: #0d6efd; margin-top: 20px; }
        .toggle-buff { background-color: #6c757d; font-size: 10px; padding: 6px 4px; }
        .rename-section {
    margin-top: auto; /* サイドバーの一番下に配置 */
    padding-top: 15px;
    border-top: 1px solid var(--border-color);
        .modal-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    display: none; /* 初期状態は非表示 */
    align-items: center; justify-content: center;
    z-index: 1000;
}
.modal-content {
    background-color: var(--medium-bg);
    padding: 20px; border-radius: 8px;
    width: 90%; max-width: 400px;
    border: 1px solid var(--border-color);
}
.modal-content h4 { margin-top: 0; }
.modal-alien-list { list-style: none; padding: 0; margin: 0; max-height: 300px; overflow-y: auto; }
.modal-alien-list li { padding: 5px; cursor: pointer; }
.modal-alien-list li:hover { background-color: var(--light-bg); }
.modal-alien-list li:nth-child(odd) { background-color: #3a4a5a50; }
.modal-close { display: block; margin: 15px auto 0; }
}
    </style>
</head>
<body>
    <div class="main-layout">
        <aside class="sidebar">
            <h3>登録済み効果名</h3>
            <h4>バフ</h4>
            <ul id="buff-name-list-buffs" class="buff-name-list"></ul>
            <h4 style="margin-top: 15px;">デバフ</h4>
            <ul id="buff-name-list-debuffs" class="buff-name-list"></ul>
            <div class="rename-section">
    <h4 style="margin-top: 15px;">効果名の統合・変更</h4>
    <p style="font-size: 11px; color: #aaa; margin: 0 0 5px 0;">上のリストから項目をクリックすると「古い効果名」に自動入力されます。</p>
    <input type="text" id="old-effect-name" placeholder="古い効果名">
    <input type="text" id="new-effect-name" placeholder="新しい効果名" style="margin-top: 5px;">
    <button id="rename-btn" onclick="renameEffect()" style="width: 100%; margin-top: 8px; background-color: #ffc107; color: #000;">この内容で一括変更</button>
</div>
        </aside>
        <main class="main-content" id="main-content">
            <div id="editor-area"><h1>データ作成ツール</h1><p>下のリストからエイリアンを選択してください。</p></div>
        </main>
    </div>
    <footer class="bottom-panel">
        <h3>エイリアンリスト</h3>
        <div class="alien-list-container" id="alien-list">
            {% for alien in all_aliens %}
            <div class="alien-icon" id="alien-icon-{{ alien.id }}" data-id="{{ alien.id }}" onclick="loadAlien('{{ alien.id }}')">
                <img src="/static/images/{{ alien.id }}.png" alt="{{ alien.name }}" onerror="this.style.display='none'">
                <span title="{{ alien.name }}">{{ alien.name }}</span>
                <div class="status-marker {{ alien.status }}"></div>
            </div>
            {% endfor %}
        </div>
    </footer>
    <datalist id="buff-name-datalist"></datalist>

    <script>
const BUFF_TARGET_OPTIONS = {
    "SELF": "自分",
    "ALL_ALLIES": "味方全員",
    "ALLIES_EXCEPT_SELF": "自分以外",
    "ATTR_1": "動物属性", "ATTR_2": "昆虫属性", "ATTR_3": "機械属性", "ATTR_4": "ナゾ属性",
    "AFFIL_1": "宇宙連合", "AFFIL_2": "星間帝国", "AFFIL_3": "恒星連邦", "AFFIL_4": "unknown", "AFFIL_5": "銀河同盟",
    "AREA_1": "攻撃範囲:たんたい", "AREA_2": "攻撃範囲:はんい",
    "RANGE_1": "攻撃距離:ちかい", "RANGE_2": "攻撃距離:ふつう", "RANGE_3": "距離:とおい"
};
const DEBUFF_TARGET_OPTIONS = {
    "ALL_ENEMIES": "敵全員", // 「自分」を削除し、「味方全員」を「敵全員」に変更
    "ALLIES_EXCEPT_SELF": "自分以外",
    "ATTR_1": "動物属性", "ATTR_2": "昆虫属性", "ATTR_3": "機械属性", "ATTR_4": "ナゾ属性",
    "AFFIL_1": "宇宙連合", "AFFIL_2": "星間帝国", "AFFIL_3": "恒星連邦", "AFFIL_4": "unknown", "AFFIL_5": "銀河同盟",
    "AREA_1": "攻撃範囲:たんたい", "AREA_2": "攻撃範囲:はんい",
    "RANGE_1": "攻撃距離:ちかい", "RANGE_2": "攻撃距離:ふつう", "RANGE_3": "距離:とおい"
};
let currentAlienId = null;

document.addEventListener('DOMContentLoaded', async () => {
    await updateBuffNameList();
    const firstIncomplete = document.querySelector('.alien-icon .status-marker.incomplete, .alien-icon .status-marker.unknown');
    if (firstIncomplete) {
        loadAlien(firstIncomplete.closest('.alien-icon').dataset.id);
    }
});

async function loadAlien(alienId) {
    // 既に選択中のIDと同じ場合は何もしない
    if (currentAlienId === alienId) return;
    currentAlienId = alienId;

    document.querySelectorAll('.alien-icon.active').forEach(el => el.classList.remove('active'));
    document.getElementById(`alien-icon-${alienId}`).classList.add('active');

    const editor = document.getElementById('editor-area');
    editor.innerHTML = `<div class="loader">エイリアン情報を読み込み中...</div>`;

    // --- ▼▼▼ 修正箇所：非同期処理の競合を防止するチェックを追加 ▼▼▼ ---
    try {
        const response = await fetch(`/get-alien-data/${alienId}`);

        // データ取得後に、現在選択されているIDがこの関数の開始時のIDと一致するか確認
        // 一致しない場合、ユーザーは既に別のエイリアンを選択しているため、画面の描画を中断する
        if (currentAlienId !== alienId) {
            return; 
        }

        const alienData = await response.json();
    // --- ▲▲▲ 修正箇所 ▲▲▲ ---

        editor.innerHTML = `<h2>${alienData.name} (ID: ${alienData.id})</h2>`;

        for (let i = 1; i <= 3; i++) {
            const skillText = alienData[`skill_text${i}`];
            if (!skillText) continue;

            const card = document.createElement('div');
            card.id = `skill-card-${i}`;
            card.className = 'skill-card';
            card.innerHTML = `
                <div class="skill-header">
                    <h4>個性${i}: ${alienData[`skill_no${i}`]}</h4>
                    <label><input type="checkbox" class="skill-consumes-slot"> 個性名で1枠消費</label>
                </div>
                <div class="skill-text">${skillText.replace(/\n/g, '<br>')}</div>
                <div class="buff-header">
                    <span>Grp</span><span>効果名</span><span>対象</span><span>効果量</span><span>単位</span><span>持続(s)</span><span>確率(%)</span><span>覚醒</span><span>枠</span><span>切替</span><span></span>
                </div>
                <div class="buff-editor" id="buff-editor-${i}"></div>
                <button class="add-buff" onclick="addBuffRow(${i}, {}, false)">＋ バフ追加</button>
                <button class="add-debuff" onclick="addBuffRow(${i}, {}, true)">＋ デバフ追加</button>
                <button class="no-buff" onclick="setNoBuffs(${i})">効果なし</button>
            `;
            editor.appendChild(card);
            renderBuffEditor(i, alienData[`skill_${i}_data`]);
        }
        editor.innerHTML += `<button id="save-btn" onclick="saveLabels()">このエイリアンのデータを保存</button>`;

    } catch (error) {
        console.error("エイリアンデータの読み込み中にエラーが発生しました:", error);
        editor.innerHTML = `<p style="color: red;">データの読み込みに失敗しました。コンソールを確認してください。</p>`;
    }
}

function renderBuffEditor(skillIndex, effects) {
    const editor = document.getElementById(`buff-editor-${skillIndex}`);
    editor.innerHTML = '';
    if (effects && effects.length > 0) {
        effects.forEach(effect => addBuffRow(skillIndex, effect, effect.is_debuff));
    } else if (effects) { // effectsが空の配列[]の場合
        editor.innerHTML = '<p>（AIによる抽出効果なし）</p>';
    }
}

function addBuffRow(skillIndex, effect = {}, isDebuff = false) {
    const editor = document.getElementById(`buff-editor-${skillIndex}`);
    const noBuffP = editor.querySelector('p');
    if (noBuffP) noBuffP.remove();

    const row = document.createElement('div');
    row.className = 'buff-row';
    row.dataset.isDebuff = isDebuff;

    // --- ▼▼▼ 修正箇所：isDebuffに応じて対象オプションを切り替える ▼▼▼ ---
    let optionsHtml = '';
    const targetOptions = isDebuff ? DEBUFF_TARGET_OPTIONS : BUFF_TARGET_OPTIONS;
    for (const [value, text] of Object.entries(targetOptions)) {
        optionsHtml += `<option value="${value}" ${effect.target === value ? 'selected' : ''}>${text}</option>`;
    }
    // --- ▲▲▲ 修正箇所 ▲▲▲ ---

    row.innerHTML = `
        <input type="number" class="buff-group" placeholder="Gr" value="${effect.group_id || ''}" style="width: 40px;">
        <input type="text" class="buff-name ${isDebuff ? 'is-debuff' : 'is-buff'}" placeholder="${isDebuff ? 'デバフ名' : 'バフ名'}" value="${effect.name || ''}" list="buff-name-datalist">
        <select class="buff-target">${optionsHtml}</select>
        <input type="number" class="buff-value" placeholder="量" value="${effect.value !== undefined ? effect.value : 0}">
        <select class="buff-unit">
            <option value="PERCENT" ${effect.unit === 'PERCENT' ? 'selected' : ''}>%</option>
            <option value="FLAT" ${effect.unit === 'FLAT' ? 'selected' : ''}>単位なし</option>
            <option value="SECONDS" ${effect.unit === 'SECONDS' ? 'selected' : ''}>秒</option>
            <option value="COUNT" ${effect.unit === 'COUNT' ? 'selected' : ''}>回</option>
            <option value="NONE" ${!effect.unit || effect.unit === 'NONE' ? 'selected' : ''}>不明</option>
        </select>
        <input type="number" class="buff-duration" placeholder="秒" value="${effect.duration !== undefined ? effect.duration : 0}">
        <input type="number" class="buff-probability" placeholder="%" value="${effect.probability !== undefined ? effect.probability : 100}">
        <input type="checkbox" class="buff-awakening" ${effect.awakening_required ? 'checked' : ''} style="transform: scale(1.5);">
        <select class="buff-slot">
            <option value="true" ${effect.occupies_slot === true ? 'selected' : ''}>Y</option>
            <option value="false" ${effect.occupies_slot === false ? 'selected' : ''}>N</option>
            <option value="null" ${effect.occupies_slot === null || effect.occupies_slot === undefined ? 'selected' : ''}>?</option>
        </select>
        <button class="toggle-buff" onclick="toggleBuffDebuff(this)">切替</button>
        <button class="delete-buff" onclick="this.parentElement.remove()">×</button>
    `;
    editor.appendChild(row);
}

// --- ▼▼▼ 修正箇所：新しい関数をスクリプトの末尾に追加 ▼▼▼ ---
function toggleBuffDebuff(button) {
    const row = button.closest('.buff-row');
    const nameInput = row.querySelector('.buff-name');
    const targetSelect = row.querySelector('.buff-target');
    const isCurrentlyDebuff = row.dataset.isDebuff === 'true';
    const currentTargetValue = targetSelect.value;

    const isNowDebuff = !isCurrentlyDebuff;
    row.dataset.isDebuff = isNowDebuff;

    nameInput.classList.toggle('is-buff', !isNowDebuff);
    nameInput.classList.toggle('is-debuff', isNowDebuff);
    nameInput.placeholder = isNowDebuff ? 'デバフ名' : 'バフ名';

    // --- ▼▼▼ 修正箇所：対象のプルダウンを再生成する処理を追加 ▼▼▼ ---
    targetSelect.innerHTML = ''; // 選択肢をクリア
    const newTargetOptions = isNowDebuff ? DEBUFF_TARGET_OPTIONS : BUFF_TARGET_OPTIONS;
    for (const [value, text] of Object.entries(newTargetOptions)) {
        const option = document.createElement('option');
        option.value = value;
        option.textContent = text;
        targetSelect.appendChild(option);
    }

    // 値の変換と再設定
    if (isNowDebuff && currentTargetValue === 'ALL_ALLIES') {
        targetSelect.value = 'ALL_ENEMIES'; // 味方全員 -> 敵全員
    } else if (!isNowDebuff && currentTargetValue === 'ALL_ENEMIES') {
        targetSelect.value = 'ALL_ALLIES'; // 敵全員 -> 味方全員
    } else if (newTargetOptions[currentTargetValue]) {
        targetSelect.value = currentTargetValue; // 共通の項目は維持
    }
    // --- ▲▲▲ 修正箇所 ▲▲▲ ---
}

function setNoBuffs(skillIndex) {
    document.getElementById(`buff-editor-${skillIndex}`).innerHTML = '<p>（効果なしとしてマークしました）</p>';
}

async function saveLabels() {
    const btn = document.getElementById('save-btn');
    btn.disabled = true;
    btn.textContent = '保存中...';
    const dataToSave = [];

    for (let i = 1; i <= 3; i++) {
        const card = document.getElementById(`skill-card-${i}`);
        if (!card) continue;
        
        const output = [];
        let hasUnknownSlot = false;
        
        const skillConsumesSlot = card.querySelector('.skill-consumes-slot').checked;
        if (skillConsumesSlot) {
            output.push({
                group_id: 0,
                name: card.querySelector('h4').textContent.replace(`個性${i}: `, ''),
                target: "ALL_ALLIES",
                value: 0,
                unit: "NONE",
                duration: 0,
                probability: 100, // 個性名消費は確定発動
                occupies_slot: true,
                is_debuff: false,
                awakening_required: false
            });
        }

        if (!card.querySelector('p')) {
            card.querySelectorAll('.buff-row').forEach(row => {
                const name = row.querySelector('.buff-name').value;
                if(name) {
                    const slotValue = row.querySelector('.buff-slot').value;
                    if (slotValue === 'null') hasUnknownSlot = true;
                    // --- ▼▼▼ 修正箇所：「確率」の値を保存データに含める ▼▼▼ ---
                    output.push({
                        group_id: parseInt(row.querySelector('.buff-group').value) || 0,
                        name: name,
                        target: row.querySelector('.buff-target').value,
                        value: parseFloat(row.querySelector('.buff-value').value) || 0,
                        unit: row.querySelector('.buff-unit').value,
                        duration: parseInt(row.querySelector('.buff-duration').value) || 0,
                        probability: parseInt(row.querySelector('.buff-probability').value) || 100,
                        occupies_slot: slotValue === 'null' ? null : (slotValue === 'true'),
                        is_debuff: row.dataset.isDebuff === 'true',
                        awakening_required: row.querySelector('.buff-awakening').checked
                    });
                    // --- ▲▲▲ 修正箇所 ▲▲▲ ---
                }
            });
        }
        
        dataToSave.push({ 
            skill_id: `${currentAlienId}_${i}`, 
            text_input: card.querySelector('.skill-text').textContent.trim(), 
            output: output,
            status: hasUnknownSlot ? 'unknown' : 'complete'
        });
    }

    await fetch('/save-labels', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({data: dataToSave})
    });
    
    const icon = document.getElementById(`alien-icon-${currentAlienId}`);
    const hasUnknownAfterSave = dataToSave.some(d => d.status === 'unknown');
    const allProcessed = dataToSave.every(d => d.status === 'complete');
    
    let newStatus = 'incomplete';
    if(hasUnknownAfterSave) {
        newStatus = 'unknown';
    } else if (allProcessed) {
        newStatus = 'complete';
    }
    
    let marker = icon.querySelector('.status-marker');
    if (!marker) {
        marker = document.createElement('div');
        icon.appendChild(marker);
    }
    marker.className = `status-marker ${newStatus}`;

    await updateBuffNameList();
    btn.textContent = '保存完了！';
    setTimeout(() => {
        const nextIncompleteMarker = document.querySelector('.alien-icon .status-marker.incomplete');
        if (nextIncompleteMarker) {
            loadAlien(nextIncompleteMarker.closest('.alien-icon').dataset.id);
        } else {
            const nextUnknownMarker = document.querySelector('.alien-icon .status-marker.unknown');
            if (nextUnknownMarker) {
                loadAlien(nextUnknownMarker.closest('.alien-icon').dataset.id);
            } else {
                document.getElementById('editor-area').innerHTML = '<h2>全ての処理が完了しました！</h2>';
            }
        }
    }, 1000);
}

// --- ▼▼▼ 以下の2つの関数を <script> タグ内のどこかに追加 ▼▼▼ ---
function populateRenameForm(name) {
    document.getElementById('old-effect-name').value = name;
    document.getElementById('new-effect-name').focus();
    // この効果を持つエイリアン一覧を表示する関数を呼び出す
    showEffectUsers(name);
}
async function renameEffect() {
    const oldName = document.getElementById('old-effect-name').value.trim();
    const newName = document.getElementById('new-effect-name').value.trim();

    if (!oldName || !newName) {
        alert('古い効果名と新しい効果名の両方を入力してください。');
        return;
    }

    if (!confirm(`データセット内の全ての「${oldName}」を「${newName}」に置換します。\nこの操作は元に戻せません。よろしいですか？`)) {
        return;
    }

    const btn = document.getElementById('rename-btn');
    btn.disabled = true;
    btn.textContent = '処理中...';

    try {
        const response = await fetch('/rename-effect', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ old_name: oldName, new_name: newName })
        });

        if (response.ok) {
            alert('一括変更が完了しました。');
            document.getElementById('old-effect-name').value = '';
            document.getElementById('new-effect-name').value = '';
            await updateBuffNameList(); // リストを再読み込み
        } else {
            const errorData = await response.json();
            alert('エラーが発生しました: ' + errorData.error);
        }
    } catch (error) {
        alert('通信エラーが発生しました。');
        console.error("Rename request failed:", error);
    } finally {
        btn.disabled = false;
        btn.textContent = 'この内容で一括変更';
    }
}


// --- ▼▼▼ 既存の updateBuffNameList 関数を以下に差し替え ▼▼▼ ---
async function updateBuffNameList() {
    try {
        const res = await fetch('/get-unique-buff-names');
        if (!res.ok) {
            console.error("効果名リストの取得に失敗しました:", res.statusText);
            return;
        }
        const data = await res.json();
        const buffs = data && Array.isArray(data.buffs) ? data.buffs : [];
        const debuffs = data && Array.isArray(data.debuffs) ? data.debuffs : [];

        const buffList = document.getElementById('buff-name-list-buffs');
        const debuffList = document.getElementById('buff-name-list-debuffs');
        const datalist = document.getElementById('buff-name-datalist');
        
        if (!buffList || !debuffList || !datalist) {
            console.error("必要なUI要素が見つかりません。");
            return;
        }
        
        buffList.innerHTML = '';
        debuffList.innerHTML = '';
        datalist.innerHTML = '';

        const addToList = (listElement, name) => {
            const li = document.createElement('li');
            li.textContent = name;
            li.style.cursor = 'pointer';
            li.onclick = () => populateRenameForm(name); // クリックでフォームに名前をセット
            listElement.appendChild(li);

            const option = document.createElement('option');
            option.value = name;
            datalist.appendChild(option);
        };

        buffs.forEach(name => addToList(buffList, name));
        debuffs.forEach(name => {
            addToList(debuffList, name);
            if (!buffs.includes(name)) { // データリストに重複して追加しないように
                const option = document.createElement('option');
                option.value = name;
                datalist.appendChild(option);
            }
        });
    } catch (error) {
        console.error("updateBuffNameList関数でエラーが発生しました:", error);
    }
}
async function showEffectUsers(name) {
    const modal = document.getElementById('effect-user-modal');
    const title = document.getElementById('modal-effect-name');
    const list = document.getElementById('modal-alien-list');

    title.textContent = `「${name}」を持つエイリアン`;
    list.innerHTML = '<li>読み込み中...</li>';
    modal.style.display = 'flex';

    try {
        const response = await fetch('/get-aliens-by-effect', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ effect_name: name })
        });
        const data = await response.json();

        list.innerHTML = ''; // リストをクリア
        if (data.aliens && data.aliens.length > 0) {
            data.aliens.forEach(alien => {
                const li = document.createElement('li');
                li.textContent = `${alien.id}: ${alien.name}`;
                li.onclick = () => jumpToAlien(alien.id);
                list.appendChild(li);
            });
        } else {
            list.innerHTML = '<li>この効果を持つエイリアンは見つかりませんでした。</li>';
        }
    } catch (error) {
        list.innerHTML = '<li>エラーが発生しました。</li>';
    }
}

function closeEffectModal() {
    document.getElementById('effect-user-modal').style.display = 'none';
}

function jumpToAlien(alienId) {
    closeEffectModal();
    loadAlien(alienId);
    // エイリアンリストまでスクロール
    const icon = document.getElementById(`alien-icon-${alienId}`);
    if(icon) {
        icon.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
}

</script>
<div id="effect-user-modal" class="modal-overlay" onclick="closeEffectModal()">
    <div class="modal-content" onclick="event.stopPropagation()">
        <h4 id="modal-effect-name"></h4>
        <ul id="modal-alien-list" class="modal-alien-list"></ul>
        <button class="modal-close" onclick="closeEffectModal()">閉じる</button>
    </div>

</div>
</body>
</html>