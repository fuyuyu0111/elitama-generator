# エリたま編成ジェネレーター 開発ガイド

## 1. プロジェクト概要

このリポジトリは、スマートフォン向けゲーム「エイリアンのたまご(エリたま)」の非公式編成支援ツール、「エリたま編成ジェネレーター(エリジェネ)」の全ソースコードを管理しています。

### 目的
エリジェネは、ユーザーが直感的な操作でゲーム内のチーム編成（パーティ）を組み、各エイリアンが持つ「個性」（スキルや特性）の発動条件を満たしているかをリアルタイムで確認できるWebアプリケーションです。

**現在の開発状況**:
個性の発動条件判定機能は実装済みです。また、以下の主要機能も実装が完了しています。

**実装済みの機能**:
- ✅ **5パーティシステム**: 最大5つのパーティを作成・管理可能。スワイプ、スクロール、ドットクリックで切り替え可能。
- ✅ **ドラッグ＆ドロップによる編成入れ替え**: 同一パーティ内でエイリアンをドラッグして順番を直感的に入れ替え可能（PC/モバイル統一実装）。
- ✅ **スロット番号システム**: 各スロットに1〜5の固定番号が割り当てられており、編成を解除しても他のメンバーの位置は維持される。
- ✅ **リアルタイム条件判定**: パーティ構成が変わるたびに、各エイリアンの個性発動条件を満たしているかを自動判定し、アイコン横に◯/✗で表示。
- ✅ **絞り込み・ソート機能**: 属性、所属、攻撃範囲、攻撃距離、ロール、タイプなどで複数条件の絞り込みが可能。ID、名前、HP、パワーなどでソート可能。
- ✅ **レスポンシブデザイン**: モバイルファーストな設計で、スマートフォンでの操作性を最優先。
- ✅ **3列1行レイアウトの編成スロット**: キャラクター情報、ステータス、スキル（特技+個性1-3）を3列に分けて表示。
- ✅ **スキル説明文の展開機能**: クリック/タップでスキルの詳細説明を展開・収納。開いた状態はパーティごとに保持される。
- ✅ **スクロール制御**: 説明文のスクロール時はパーティ移動を無効化。ブラウザの戻るジェスチャー（左スワイプで←表示）も無効化。
- ✅ **ドロワー内パーティプレビュー**: ドロワーのヘッダー直下に現在のパーティ編成をミニアイコンで表示。ドラッグで順番入れ替え、ドロップゾーンへのドロップで編成解除、一覧のキャラアイコンへのドロップで直接入れ替えが可能。
- ✅ **現在のパーティのみの編成状態表示**: 一覧のキャラカードは現在編集中のパーティ（`currentPartyId`）への編成状態のみを表示。他のパーティに編成されているキャラは「編成中」と表示されない。重複編成は引き続き防止。
- ✅ **長押しプレビュー機能**: エイリアン一覧でアイコンを長押し（1秒）すると、そのキャラを編成した場合の条件判定結果をプレビュー表示。現在のパーティ（`currentPartyId`）のコンテキストに基づいて正確に判定。
- ✅ **パーティ全体概要表示**: 5つのパーティをグリッド形式で一覧表示。ドラッグ＆ドロップで異なるパーティ間でキャラクターを入れ替え可能。

**今後の拡張予定**:
- 個性のテキストからバフ・デバフ効果を自動抽出し、実際の戦闘シミュレーションを行う機能

### 設計理念
- **操作の簡潔さ**: 画面遷移を極力なくし、ユーザーのクリック回数を最小限に抑えることを目指します。
- **情報の一覧性**: 必要な情報のほとんどが1画面に集約されており、スクロール操作をできるだけ発生させないUIを追求します。
- **レスポンシブデザイン**: スマートフォンでの利用を主要なターゲットとし、モバイルファーストなデザインを採用しています。

---

## 2. アプリケーションの全体像とデータフロー

本プロジェクトは、大きく分けて3つの要素で構成されています。

1.  **メインアプリ (`app.py`, `templates/index.html`)**: ユーザーが実際に触れる編成ジェネレーター本体。
2.  **データ収集・加工スクリプト (`scripts/`)**: ゲーム攻略サイトからエイリアンのデータを収集し、データベースを構築するためのバッチ処理群。
3.  **AI学習データ作成アプリ (`date_create/`)**: 個性のテキストからバフ・デバフ情報を抽出するAIモデルの学習データセットを作成・管理するための内部向けツール。

### データフロー
本アプリケーションのデータは、以下の流れで構築・利用されます。

1.  **データ収集 (Scraping)**: `scripts/scraping/`内のスクリプトを使い、攻略サイトからエイリアンの基本情報、個性テキスト、画像などを自動で収集します。
2.  **データ変換・DB格納**: 収集したデータを`full_scraper.py`内の変換マップに基づき、データベースのスキーマに合わせた形式に変換して`alien`テーブルに格納します。
3.  **個性・条件の解析 (LLM)**: `scripts/llm/llm_skill_importer.py`が`alien`テーブルの個性テキストを読み込み、GoogleのGeminiモデルに問い合わせることで、個性の発動条件を解析し、構造化データとして`skill`テーブルに格納します。
4.  **バフ/デバフ情報のデータセット作成**: `date_create/`のWebアプリを使い、手動で個性テキストと発動するバフ効果を紐付け、`buff_finetuning_dataset_full.jsonl`というデータセットファイルを作成します。これは将来的なAIモデルのファインチューニングに利用します。
5.  **ユーザーへのデータ提供**: メインアプリ(`app.py`)が`alien`テーブルと`skill`テーブルからデータを読み込み、`index.html`に渡してユーザーに表示します。アプリケーションのパフォーマンス向上のため、データベースからの読み込み結果はキャッシュされます。

---

## 3. 各ファイル/ディレクトリの役割

### `/app.py`
- **役割**: メインとなる編成ジェネレーターのバックエンドアプリケーション。
- **フレームワーク**: Flask
- **主な機能**:
    - `get_initial_data()`: アプリケーション起動後の初回アクセス時に、DBから全エイリアンデータと全スキル条件データを一度に取得し、`@lru_cache`デコレータで結果をメモリにキャッシュします。これにより、2回目以降のアクセスを高速化しています。
    - `@app.route('/')`: メインページ(`index.html`)を描画します。この際、キャッシュした全エイリアンとスキル条件のデータをPythonオブジェクトとして直接テンプレートに渡します。APIを介さず、初回ロードですべてのデータをフロントエンドに渡す設計になっています。

### `/templates/index.html`
- **役割**: 編成ジェネレーターのフロントエンド。単一のHTMLファイルで全ての操作が完結するSPA(Single Page Application)です。
- **主な機能**:
    - **UI**: 3つのパーティを切り替えるためのスライダーとセレクター、5体のエイリアンを配置するパーティースロット、選択可能なエイリアン一覧を表示するドロワーで構成されます。
    - **データ管理**: Flaskから渡された全エイリアンデータ(`ALL_ALIENS`)と全スキル条件データ(`ALL_REQUIREMENTS`)をJavaScriptのグローバル変数として保持します。
    - **状態管理**: ユーザーが作成した3つのパーティ編成の状態は、JavaScriptの`parties`オブジェクト (`{'1': [], '2': [], '3': []}`) で一元管理されます。`currentPartyId`で現在表示中のパーティを追跡します。
    - **編成シミュレーション**: `addToParty()`や`removeFromParty()`といった関数で`parties`オブジェクトを更新し、`renderPartySlots()`を呼び出してUIを再描画します。
    - **条件判定 (`checkPartyRealtime`)**: パーティ構成が変更されるたびに、現在のパーティ全体の属性、所属、タイプなどの構成をリアルタイムで再計算し、各個性の発動条件を満たしているかを判定してアイコン横に「◯」や「✗」で表示します。
    - **UIインタラクション**: 絞り込み、ソート、パーティのスワイプ切り替え、ドラッグ＆ドロップによるメンバーの入れ替えなど、多彩なUI操作をJavaScriptで制御します。

### `/scripts/`
データ収集と加工を担当するスクリプト群です。

- **`scraping/full_scraper.py`**: 攻略サイトからエイリアンの全データをスクレイピングし、DBの`alien`テーブルを構築・更新します。画像のファイル名をDB格納用のIDに変換する`CONVERSION_MAP`を内包しています。
- **`scraping/image_scraper.py`**: エイリアンの画像を一括でダウンロードし、`/static/images/`に保存します。
- **`llm/llm_skill_importer.py`**: DB内の個性テキストをLLM(Gemini API)に送信し、「味方の構成に関する発動条件」を抽出して`skill`テーブルに保存します。
- **`llm/llm_buff_analyzer.py`**: （✅実装完了）DB内の個性テキストをGemini 2.5 Flash Liteで解析し、バフ・デバフ効果を`skill_complete`テーブルに保存します。460体（1380個性）を順次処理（4.1秒間隔）で約31分で完了。
- **`db/backup_skill_complete.py`**: `skill_complete`テーブルをJSONL形式でバックアップするスクリプト。`--truncate`での全削除前に必ずバックアップを実行します。

### `/date_create/`
将来のバフ効果シミュレーション機能のために、AIの学習データセットを作成する内部向けツールです。

- **`date_app.py`**: データセット作成ツールのバックエンド(Flask)。未解析の個性に対してLLMを用いてバフ・デバフ情報をJSON形式で提案する機能を持ちます。
- **`templates/templates/date_index.html`**: データセット作成ツールのフロントエンド。個性テキストを見ながら、発動するバフ効果を詳細な属性（効果名、対象、効果量など）と共にフォームに入力し、JSONL形式で保存できます。

---

## 4. データベーススキーマ

### `alien` テーブル
各エイリアンの静的な基本情報を格納します。

| 列名 | データ型 | 説明 |
| :--- | :--- | :--- |
| `id` | INTEGER | **主キー**。エイリアンの図鑑No。 |
| `name` | TEXT | エイリアン名。 |
| `attribute` | INTEGER | 属性 (1:動物, 2:昆虫, 3:機械, 4:ナゾ)。 |
| `affiliation` | INTEGER | 所属 (1:宇宙連合, 2:星間帝国, 3:恒星連邦, 4:unknown, 5:銀河同盟)。 |
| `attack_range` | INTEGER | 攻撃距離 (1:ちかい, 2:ふつう, 3:とおい)。 |
| `attack_area` | INTEGER | 攻撃範囲 (1:たんたい, 2:はんい)。 |
| `role` | INTEGER | ロール(役割) (1:攻撃, 2:防御, 3:支援, 4:回復)。 |
| `type_1`...`type_4` | TEXT | タイプ。海:A, 夜:B, 氷:C...など、最大4つまで。`CONVERSION_MAP`参照。 |
| `skill_no1`...`skill_no3` | TEXT | 個性1〜3の名前。 |
| `skill_text1`...`skill_text3` | TEXT | 個性1〜3の説明文全文。 |
| `S_Skill` | TEXT | 特技の名前。 |
| `S_Skill_text` | TEXT | 特技の説明文。 |
| `hp` `power` ... `speed` | INTEGER | （未使用）基本ステータス。 |

### `skill` テーブル
個性の発動条件のうち、「味方のチーム構成」に関するものだけを構造化して格納します。

| 列名 | データ型 | 説明 |
| :--- | :--- | :--- |
| `id` | INTEGER | **外部キー**。`alien.id`に対応。 |
| `skill_number` | INTEGER | 個性番号（1〜3）。 |
| `condition_type` | TEXT | 条件のカテゴリ (a:属性, b:所属, c:はんい, d:きょり, e:タイプ, f:ロール)。 |
| `condition_value`| TEXT | 条件の値。`condition_type`に対応するID。 |
| `condition_count`| INTEGER | 条件を満たすために必要な味方の数。 |

---

## 5. Copilotへの追加指示案


### 5.1. コーディング規約と技術スタック
- **バックエンド**: Python 3.x, Flask, psycopg2
- **フロントエンド**: HTML5, CSS3, Vanilla JavaScript (ES6+)。外部ライブラリは使用しない。
- **データベース**: PostgreSQL
- **スタイル**:
    - PythonはPEP8に準拠。
    - JavaScriptの変数名はキャメルケース(`camelCase`)。
    - UIの設計思想として、**シンプルさと即時性を最重視**する。非同期処理(`async/await`)を適切に使用し、UIのブロッキングを避けること。
    - **複雑なアニメーションやライブラリへの依存は避ける**: 過去の開発経験から、FLIP animations、仮想DOM、複雑な状態管理ライブラリなどは、バグの温床となり保守性を下げることが判明。基本的なDOM操作とCSS transitionで十分な場合は、それらを優先する。
    - **PC/モバイルの統一実装**: 別々のコードパスを作らず、ポインターイベント（mouse*/touch*）で統一的に実装することで、保守性と信頼性を向上させる。
    - **相対的な閾値とサイズ**: 画面サイズに依存する値（スワイプ距離、タップ判定など）は、絶対値ではなく`window.innerWidth`や`vh`単位を基準とした相対値で実装する。
    - **制約を最大限活用する**: システムに既存の制約（5スロット固定など）がある場合、その制約を変更するよりも、制約に例外を作る（プレビュー時のみ6スロット許可など）方が、シンプルで保守性の高い実装になることが多い。
    - **最もシンプルな解決策を選ぶ**: 複数の解決策が考えられる場合、以下の優先順位で選択する：
      1. 既存のロジックを再利用し、特別なケースのみ分岐
      2. 新しい引数や状態を追加するよりも、特別なIDやフラグで判定
      3. インデックスマッピングや複雑な変換よりも、データ構造そのものを変更

### 5.2. フロントエンドの主要なロジック
- **状態管理**:
    - **`parties`**: 5つのパーティ編成を管理するオブジェクト。キーは`'1'`, `'2'`, `'3'`, `'4'`, `'5'`。値はエイリアンのデータセットオブジェクトまたは`null`を格納した長さ5の配列。
    - **`currentPartyId`**: 現在表示・編集中のパーティID (`'1'`〜`'5'`) を示す文字列。
    - **`dragState`**: ドラッグ＆ドロップの状態を管理するオブジェクト。`{active: boolean, sourceIdx: number|null, currentHoverIdx: number|null, ghostElement: HTMLElement|null}`の構造。
    - **`allAliensData`**: 全エイリアンの詳細データとDOM要素を格納した配列。絞り込みやソートの元データとなる。
    - **`activeFilters`**: 現在適用されている絞り込み条件を格納するオブジェクト。
    - **`currentSort`**: 現在のソート条件を格納するオブジェクト。`{key: string, order: 'asc'|'desc'}`の構造。

- **主要な関数**:
    - **`renderPartySlots()`**: `parties[currentPartyId]`の状態に基づき、対応するパーティコンテナのHTMLを完全に再構築する最重要関数。スロットごとにmousedown/touchstartイベントを設定し、DnDを初期化する。
    - **`checkPartyRealtime()`**: 現在のパーティ構成を分析し、各個性の発動条件（属性、所属、タイプ、ロール、攻撃範囲、攻撃距離）を満たしているか判定して、UIの◯✗表示を更新する。
    - **`updateAlienGrid()`**: 絞り込み(`activeFilters`)と並び替え(`currentSort`)の状態に基づき、エイリアン一覧の表示を更新する。フィルター未選択時はグリッドを空にする。
    - **`updateAlienCardSelectedState()`**: 全パーティを走査して編成中のキャラを特定し、一覧のカードに`.selected`クラスを付与/削除する。重複編成を防止し、編成状態を正確に表示するための重要な関数。
    - **`switchParty(direction)`**: `currentPartyId`を更新（ループ構造: 5→1, 1→5）し、CSS `transform: translateX(-${(nextId - 1) * 100}%)` を使ってパーティ表示をスライドさせる。
    - **`addToParty(alienCardDataSet)`**: パーティの最初の空きスロットにエイリアンを追加する。満員または既に編成済みの場合は処理をスキップ。追加後に`updateAlienCardSelectedState()`を呼び出して一覧の表示を更新。
    - **`removeFromParty(slotIndex)`**: 指定したスロットのエイリアンを削除（`null`に設定）する。削除後に`updateAlienCardSelectedState()`を呼び出して一覧の表示を更新。

- **ドラッグ＆ドロップ（PC/モバイル統一実装）**:
    - **設計思想**: HTML5 Drag and Drop APIは使用せず、ポインターイベント（mousedown/touchstart, mousemove/touchmove, mouseup/touchend）で統一的に実装。アニメーションは一切使用せず、シンプルで確実な動作を優先。
    - **`handleDragStart(e, idx)`**: ドラッグ開始時に呼ばれる。`dragState.active`を`true`に設定し、ゴースト要素（拡大したエイリアン画像）を作成してカーソル/指に追従させる。パーティ切り替えを無効化。
    - **`handleDragMove(e)`**: ドラッグ中に呼ばれる。ゴースト要素の位置を更新し、`document.elementFromPoint()`でホバー中のスロットを検出して`.drag-over`クラスでハイライト。
    - **`handleDragEnd(e)`**: ドラッグ終了時に呼ばれる。配列の`splice`を使ってメンバーの順番を入れ替え、ゴースト要素を削除し、パーティ切り替えを再有効化。`dragState`をリセット。
    - **`updateGhostPosition(e)`**: ポインターの座標（`clientX/clientY`または`touches[0].clientX/clientY`）を読み取り、ゴースト要素の`left/top`を更新してカーソル/指の中心に配置。
    - **`disablePartySwitch(disabled)`**: パーティ切り替えボタンとドットの`pointerEvents`を制御し、ドラッグ中は誤操作を防止。

- **パーティ切り替え操作**:
    - **スワイプ**: タッチスタート・ムーブ・エンドで水平移動距離を検出。相対閾値（`window.innerWidth * 0.128`、390px幅で約50px）を超えたらパーティ切り替え。`touchMoved`フラグでタップとスワイプを区別。
    - **スクロール**: `wheel`イベントで水平/垂直スクロールを検出（`Math.abs(delta) > 30`）。Shiftキー不要で、マウスホイールやトラックパッドで操作可能。
    - **ドットクリック**: `.dot`要素の`data-party-id`を読み取り、直接目的のパーティに移動。ドット間の余白を広げて（`gap: 1.5vh`）タップしやすくしている。
    - **矢印ボタン**: 前後のパーティに移動。5→1、1→5のループ構造。

- **レイアウト設計**:
    - **ゼロマージン設計**: `body`のpaddingを0に、`.header`のmargin-bottomを0にして、画面端まで最大限に活用。
    - **パーティ表示エリアのパディング**: `.party-display-area`は下・左・右のみにパディング（`padding: 0 0.947vh 0.947vh 0.947vh`）を設定し、上部の余白を削除してヘッダーとの距離を最小化。
    - **スライダー構造**: `#party-slider-wrapper`は`width: 100%`で、各`.party-container`は`min-width: 100%; flex-shrink: 0`で横並び。`transform: translateX()`で切り替え。

### 5.3. 編成スロットのUI仕様（2025年10月20日 最終更新）

#### スロット構造（3列1行レイアウト）
編成スロットは左・中・右の3列構造で構成されます：

**左列（キャラクターエリア）**:
- **属性に応じたアイコン枠の色を適用**:
  - 動物(1): `#ffcccc` (薄い赤)
  - 昆虫(2): `#c4e5a0` (黄緑)
  - 機械(3): `#c4d9ff` (薄い青)
  - ナゾ(4): `#e0ccff` (薄い紫)
  - **注意**: 背景全体ではなく、アイコンの`border-color`に色を適用（`border-width: 0.355vh`）
- **レイアウト**:
  - 上部: エイリアン名（1行表示、最大9文字対応、フォントサイズ0.93vh、**白文字**、`margin-top: 0.5vh`で位置調整）
  - 下部: アイコン画像（正方形、中央配置、`margin-top/bottom: auto`）

**中列（ステータスエリア）**:
- **未編成時も編成時と同じ構造で表示**（空の値は`'---'`または空アイコン）
- **上部**: HP/パワー表示
  - フォーマット: `たいりょく: 12345` / `つよさ: 6789`
  - データソース: `alien.hp`, `alien.power`
  - 区切り線あり（インセットスタイル）
- **中部**: こうげき/所属
  - ラベル: 「こうげき/所属」（フォントサイズ0.532em = 30%削減）
  - 攻撃距離（`attack_range`）、攻撃範囲（`attack_area`）、所属（`affiliation`）のアイコン表示
  - 区切り線あり
- **下部**: タイプ
  - ラベル: 「タイプ」（フォントサイズ0.532em = 30%削減）
  - ロール（`role`）とタイプ1〜4（`type_1`〜`type_4`）のアイコン表示
- **レイアウト**: 縦方向flexboxで3セクションに分割

**右列（スキルエリア）**:
- **構成**: 高さを4等分し、上から順に配置
  1. 特技（`S_Skill`, `S_Skill_text`）
  2. 個性1（`skill_no1`, `skill_text1`）
  3. 個性2（`skill_no2`, `skill_text2`）
  4. 個性3（`skill_no3`, `skill_text3`）
- **特技と個性の境界**: 通常より太い線（`0.237vh solid`、通常の2倍）で区別
- **要求アイコンと条件判定**: 個性のみ表示（特技には発動条件が無いため表示しない）
  - 対応する要求タイプ: 属性(a), 所属(b), はんい(c), きょり(d), タイプ(e), ロール(f)
  - 条件を満たしている場合は◯、満たしていない場合は✗を表示

#### 説明文の展開機能
- **開閉操作**: スキルブロックをクリック/タップすると説明文が展開・収納される（トグル動作）
- **シンプルな実装**: 一度開いた説明文はもう一度クリック/タップするまで開いたまま（余白クリックでは閉じない）
- **開いた時の表示**:
  - `.skill-name-display`が上部に絶対配置で表示される
  - 内容: 「特技」または「個性1」などのラベル + スキル名 + 要求アイコン（個性のみ）
  - フォントサイズはそのまま（変更なし）
- **説明文のスクロール**:
  - 説明文が長い場合は`.skill-description`内でスクロール可能
  - 説明文上でホバー/タッチしている間は、スクロールジェスチャーがパーティ移動ではなく説明文のスクロールに優先される
  - テキストの折り返し: CSS `word-break: break-all`, `overflow-wrap: break-word` で実装（データベース内にはn改行文字が無いため）
- **編成解除・入れ替え時の動作**:
  - キャラを編成解除すると、そのスロットの開いていた説明文は自動的に閉じる
  - ドラッグ＆ドロップで順番を入れ替えると、移動範囲内（最小インデックス〜最大インデックス）の全てのスロットの開いていた説明文が閉じる
- **パーティ切り替え時の動作**:
  - 開いた説明文の状態は`openedSkills[partyId][slotIndex] = skillIndex`で保存される
  - パーティを切り替えても、各パーティごとに開いていた説明文は維持される
  - `renderPartySlots()`の最後で、保存された状態を読み取り、該当スキルに`.is-active`クラスを適用して復元

#### Grid Template設定
```css
grid-template-columns: 9.478vh 13.033vh 1fr;
grid-template-rows: 1fr;
grid-template-areas: "character stats skills";
```

従来の2行構造から、1行構造に変更。名前は左列（`character`エリア）に統合されました。

#### スワイプジェスチャーの制御
- **ブラウザの戻るジェスチャーの無効化**:
  ```css
  body {
      overscroll-behavior-x: none; /* 横方向のオーバースクロールを無効化 */
      touch-action: pan-y pinch-zoom; /* 縦スクロールとピンチズームのみ許可 */
  }
  .party-display-area {
      overscroll-behavior-x: none;
  }
  ```
  これにより、左スワイプで「←」（戻るボタン）が出現する問題を解決。

### 5.4. ドロワー内UX仕様（2025年10月21日 最終更新）

ドロワー（エイリアン一覧画面）において、直感的な編成操作とプレビュー機能を提供します。

#### ドロワー内パーティプレビュー（✅実装完了）
ドロワーのヘッダー直下に、現在編集中のパーティ(`currentPartyId`)の編成状況をリアルタイムでプレビュー表示します。

**構成**:
- **パーティ番号表示**: `P1`, `P2`, `P3`, `P4`, `P5` のテキスト表記
- **ミニアイコン**: 5つのスロット（編成済みの場合はエイリアンアイコン、未編成の場合は空スロット）
- **レイアウト**: 横一列で表示、左右の矢印ボタンでパーティ切り替え可能
- **アイコンサイズ**: 5.6vh × 5.6vh（一覧アイコンの70%サイズ）

**インタラクション**（すべて実装済み）:
1. **ドラッグ＆ドロップで順番入れ替え**: ミニアイコンをドラッグして、同一パーティ内での順番変更が可能
   - メインのパーティスロットと同じドラッグロジックを使用
   - ゴースト要素の表示（拡大アイコン、カーソル/指に追従）
   - ホバー中のスロットをハイライト（`.drag-over`クラス）
   - 配列の`splice`による入れ替え処理

2. **ドラッグして編成解除エリアにドロップ**: ミニアイコンをドラッグし、編成解除エリア（灰色→赤にハイライト）にドロップで編成解除
   - ドロップゾーンはparty-preview-areaの直下（`position: absolute; top: 100%`）に配置
   - 一覧を押しのけず、上にオーバーレイ表示（`z-index: 100`）
   - ホバー時に灰色から赤のグラデーションに変化

3. **ドラッグして一覧のキャラにドロップで直接入れ替え**: ミニアイコンをドラッグし、一覧のキャラアイコンにドロップすることで、編成中のキャラと直接入れ替え
   - 編成中のキャラ（`.selected`クラス付き）はハイライトせず、入れ替え対象から除外
   - 編成中でないキャラをホバーすると黄色の枠線と光るシャドウで強調（`.drag-swap-target`クラス）
   - ドロップ時に元のキャラを解除し、新しいキャラを同じスロットに配置
   - `updateAlienCardSelectedState()`を呼び出して、一覧の`.selected`クラスを更新

4. **パーティ切り替え連動**: ドロワー内でパーティを切り替えると、メイン画面のパーティ表示も同期して切り替わる
   - `currentPartyId`を更新し、`switchParty()`ロジックを共有

**設計思想**:
- ドロワーは「編成のプレビュー的な意味合い」を持ち、ユーザーが一覧を見ながら直感的にメンバーを追加・削除・入れ替えできる環境を提供
- シンプルで確実な動作を優先し、複雑なアニメーションは使用しない
- ドラッグ操作は3つのドロップターゲットを持つ：
  1. **ドロップゾーン** → 編成解除
  2. **一覧のキャラカード（編成中でない）** → キャラ入れ替え
  3. **他のプレビュースロット** → 順番入れ替え

**プレビュードラッグの実装詳細**:
- **`previewDragState`オブジェクト**: `{active, sourceIdx, currentHoverIdx, hoverAlienCard, ghostElement}`の構造でドラッグ状態を管理
- **`handlePreviewDragStart(e, idx)`**: ドラッグ開始時にゴースト要素を作成し、ドロップゾーンを表示（`.active`クラス）
- **`handlePreviewDragMove(e)`**: 
  - `document.elementFromPoint()`でカーソル位置の要素を検出
  - ドロップゾーン、一覧のカード、他のプレビュースロットの3種類を判定
  - 編成中のカード（`.selected`クラス付き）は検出から除外
  - ホバー中の要素に応じて適切なクラス（`.hover`, `.drag-swap-target`, `.drag-over`）を付与
- **`handlePreviewDragEnd(e)`**: 
  - ドロップ先を判定してそれぞれの処理を実行
  - 一覧のカードにドロップした場合：元のキャラを`null`に設定→新しいキャラを配置→`updateAlienCardSelectedState()`で`.selected`を更新
  - ドロップゾーンにドロップした場合：`removeFromParty(sourceIdx)`で編成解除
  - 他のプレビュースロットにドロップした場合：配列の`splice`で順番入れ替え
- **一覧のクリックイベント**: 全パーティをチェックして編成済みかどうかを判定し、編成済みの場合はそのパーティで解除、未編成の場合は現在のパーティに追加

#### 長押しプレビュー機能（✅実装完了）

**概要**:
エイリアン一覧のアイコンを長押し（1秒）すると、そのエイリアンを現在のパーティに追加した場合の条件判定結果をプレビュー表示する機能です。

**動作仕様**:
1. **トリガー**: アイコンを1秒間タッチ/クリックし続ける
2. **表示内容**:
   - 画面全体を暗くするオーバーレイ（`#long-press-overlay`）
   - 画面中央に、そのエイリアンのスロット（メインスロットの80%サイズ）を表示（`#long-press-preview`）
   - プレビュースロットには、そのエイリアンを**現在のパーティ（`currentPartyId`）**に追加した場合の条件判定結果（◯/✗）を表示
   - 各個性の要求を満たしているかをリアルタイムで判定
3. **終了**: オーバーレイをクリック/タップすると即座にプレビューを閉じる

**実装の重要ポイント**:
- **`showLongPressPreview(alienCardDataSet)`**: プレビュー表示の核となる関数
  - 引数として受け取った`alienCardDataSet`を使用してスロットHTMLを構築
  - **型安全なID比較**: `alienCardDataSet.id`を`parseInt()`で数値化し、`ALL_ALIENS`との比較時も型を統一
  - **現在のパーティコンテキストでの判定**: `parties[currentPartyId]`の既存メンバーとプレビューキャラを合わせて仮想的なパーティを構築し、`checkPartyRealtime()`で条件判定を実行
  - **満員時の特別処理**: パーティが満員（5体）の場合、プレビュー専用で6体目を追加し、`renderPartySlots()`で6スロットを描画。その後、プレビュー対象以外のスロットを削除して1スロットのみ表示
  - **suppressSelectedHighlightフラグ**: プレビュー表示中は`.selected`クラスを付与しないよう制御（他のパーティへの編成状態は無視）
  - **エラーハンドリング**: データ取得失敗時のエラーログを実装
  - **スキルトグル機能**: プレビュー内でスキルの詳細説明を展開・収納可能
  
- **`longPressState`オブジェクト**: `{timer: null, active: false, alienCard: null}`の構造で長押し状態を管理
  - `timer`: 1秒後にプレビューを表示するタイマーID
  - `active`: プレビューが表示中かどうか
  - `alienCard`: 長押し対象のDOM要素

- **`renderPartySlots()`の拡張**: 
  - プレビュー専用パーティ（partyId = 'preview'）の場合のみ、最大6スロットまで描画
  - 通常のパーティは従来どおり5スロット固定
  - これにより、満員時でも正確な条件判定が可能

- **イベントハンドリング**:
  - `mousedown`/`touchstart`: 1秒タイマーを開始、動いたらキャンセル
  - `mousemove`/`touchmove`: 5px以上動いたらタイマーキャンセル（ドラッグとの区別）
  - `mouseup`/`touchend`: タイマーをキャンセル（長押し判定前に離した場合）
  - オーバーレイの`click`: プレビューを閉じる（シンプルで確実な実装）

**設計思想**:
- **シンプルな実装**: アニメーションを使わず、オーバーレイ + プレビューのみで構成
- **現在のパーティに基づく判定**: 全パーティではなく、現在編集中のパーティ（`currentPartyId`）のコンテキストで条件判定を行うことで、ユーザーにとって意味のある情報を提供
- **タップとドラッグの競合回避**: 5px以上の移動を検出したら長押しをキャンセルすることで、ドラッグ操作と区別
- **HP/パワー表示の削除**: プレビュースロットは中列を非表示にすることで、スキル情報に集中できるようにする
- **制約を活用した解決**: 通常は5スロット制限だが、プレビュー専用で6スロット許可することで、インデックスマッピングなどの複雑な処理を回避

#### パーティ全体概要表示機能（✅実装完了）

**概要**:
5つのパーティすべてを一覧表示し、異なるパーティ間でキャラクターをドラッグ＆ドロップで入れ替え可能にする機能です。

**動作仕様**:
1. **トリガー**: ヘッダーの「パーティ全体概要」ボタンをクリック
2. **表示内容**:
   - 画面全体を覆うオーバーレイ（`#party-overview-overlay`）
   - 5つのパーティをグリッド形式で表示（`#party-overview-container`）
   - 各パーティは「P1」〜「P5」のラベルと、5体のキャラスロットで構成
   - 編成済みのスロットにはアイコンとキャラ名を表示
3. **インタラクション**:
   - **パーティ間ドラッグ＆ドロップ**: キャラをドラッグして別のパーティのスロットにドロップすることで、パーティ間の移動が可能
   - **空スロットへのドロップ**: 移動先パーティに空きがあれば追加
   - **既存キャラとの入れ替え**: 移動先スロットにキャラがいる場合は、2体を入れ替え
   - **同一パーティ内の並び替えは不可**: 同じパーティ内での移動は無視（メインスロットのDnDと役割分担）
4. **終了**: 「×」ボタンまたはオーバーレイの余白をクリックで閉じる

**実装の重要ポイント**:
- **`showPartyOverview()`**: 概要表示を構築する関数
  - 5つのパーティすべての現在の編成状態（`parties['1']`〜`parties['5']`）を読み取り
  - 各パーティのスロットHTMLを動的に生成
  - 各スロットに`data-party-id`と`data-slot-index`を設定してドロップ先を識別

- **`renderPartyOverview()`**: 概要表示を最新の状態に更新する関数
  - パーティデータが変更されたときに呼び出される
  - 既存の概要表示が開いている場合のみ再描画（閉じている場合は何もしない）

- **`overviewDragState`オブジェクト**: `{active, sourcePartyId, sourceSlotIdx, ghostElement, originalData}`の構造でドラッグ状態を管理

- **`handleOverviewDragStart(e, partyId, slotIdx)`**: ドラッグ開始
  - 元のスロットからデータを取得して`overviewDragState`に保存
  - ゴースト要素（拡大アイコン）を作成してカーソル/指に追従

- **`handleOverviewDragMove(e)`**: ドラッグ中
  - `document.elementFromPoint()`でホバー中の要素を検出
  - `.party-overview-slot`にホバー中の場合は`.drag-over`クラスでハイライト
  - ゴースト要素の位置を更新

- **`handleOverviewDragEnd(e)`**: ドロップ処理
  - ドロップ先の`.party-overview-slot`を取得し、`data-party-id`と`data-slot-index`を読み取り
  - **同一パーティ内のドロップは無視**: `sourcePartyId === targetPartyId`の場合は処理をスキップ
  - **異なるパーティへのドロップ**:
    - 移動元のスロットを`null`にする（`parties[sourcePartyId][sourceSlotIdx] = null`）
    - 移動先が空スロット（`null`）の場合: キャラを配置
    - 移動先に既にキャラがいる場合: 2体のデータを入れ替え（元の場所に相手を配置）
  - **5つのパーティすべてを再描画**: `renderPartySlots()`を5回呼び出し、全パーティコンテナの表示を更新
  - **概要表示も更新**: `renderPartyOverview()`で概要画面の表示を同期

**設計思想**:
- **メインスロットとの役割分担**: 
  - メインスロット: 同一パーティ内の順番入れ替え
  - 概要表示: 異なるパーティ間のキャラ移動
  - 両方を明確に分離することで、ユーザーの混乱を防ぐ
- **全パーティの即時反映**: ドロップ後は5つのパーティコンテナすべてを再描画することで、どのパーティを表示していても正確な状態を保証
- **シンプルな実装**: スロット間の距離や位置計算は不要。`document.elementFromPoint()`で確実にドロップ先を検出

### 編成状態管理の改善（✅実装完了）

**全パーティ対応の編成状態管理**から**現在のパーティのみの編成状態表示**への変更:

**背景**:
- 以前の実装では、`updateAlienCardSelectedState()`が全パーティ（P1〜P5）を走査し、どれか1つのパーティにでも編成されているキャラには`.selected`クラスが付与されていた
- これにより、ドロワーで一覧を見たときに、現在のパーティ（`currentPartyId`）とは無関係なパーティに編成されているキャラまで「編成中」と表示されてしまう問題が発生

**改善内容**:
- **`updateAlienCardSelectedState()`の修正**: 
  - 全パーティ（`Object.keys(parties)`）ではなく、**現在のパーティ（`currentPartyId`）のみ**を走査
  - `parties[currentPartyId]`の中に存在するキャラのみに`.selected`クラスを付与
  - これにより、ドロワーの一覧では「今編集中のパーティ」に編成されているかどうかだけが表示される
  
- **型安全な比較**: 
  - `alienCardDataSet.id`（文字列または数値）と`member.id`（通常は数値）を比較する際、両方を`parseInt()`で数値化
  - `parseInt(dataSet.id) === parseInt(member.id)`の形式で型不一致によるバグを防止

- **プレビュー表示での配慮**: 
  - 長押しプレビュー表示中は`suppressSelectedHighlight`フラグを`true`に設定
  - `showLongPressPreview()`の実行中に`updateAlienCardSelectedState()`が呼ばれても、`.selected`クラスの更新をスキップ
  - これにより、プレビュー中に一覧の表示がちらつくことを防止

**設計思想**:
- **スコープの明確化**: 「編成中」という状態は、全体ではなく「現在のパーティ」というコンテキストに限定されるべき
- **ユーザー体験の向上**: ドロワーで一覧を見たとき、「今編集中のパーティに追加できるかどうか」が一目でわかることが重要
- **重複編成の防止は保持**: パーティ間での重複編成（同じキャラを複数パーティに配置）は引き続き防止（`addToParty()`で全パーティをチェック）

#### 長押しプレビュー機能
エイリアン一覧のアイコンを長押し（1秒）すると、そのエイリアンを仮想的にパーティに追加した場合の条件判定結果をプレビュー表示します。

**動作仕様**:
1. **トリガー**: アイコンを1秒間タッチ/クリックし続ける
2. **表示内容**:
   - 画面全体を暗く（オーバーレイ）
   - 画面中央に、そのエイリアンのスロット（メインスロットの80%サイズ）を表示
   - プレビュースロットには、そのエイリアンを現在のパーティに追加した場合の条件判定結果（◯/✗）を表示
3. **終了**: もう一度タッチすると即座にプレビューを閉じる

**ビジュアルフィードバック**:
- 長押し中の視覚的フィードバックは**不要**
  - 理由: アニメーションによるバグリスクを回避し、シンプルな実装を優先
  - オーバーレイ + プレビュー表示で十分わかりやすい
- プレビュースロットはメインスロットと同じデザイン（属性背景色、アイコン、条件判定表示）を踏襲。スロットをそのまま小さくした形で表示

**実装時の注意**:
- プレビュー表示は既存の`checkPartyRealtime()`ロジックを利用し、仮想的なパーティ構成（`[...parties[currentPartyId], previewAlien]`）で条件判定を実行
- 実際のパーティ状態（`parties`オブジェクト）は変更しない（プレビューのみ）
- プレビュー中は他のUI操作（スクロール、タップなど）を無効化

#### メインパーティスロットのインタラクション
メイン画面のパーティスロットでは、タップによる編成解除は**実装しない**。

**理由**:
1. **操作の競合を回避**: フリックによるパーティ移動、ドラッグ＆ドロップによる順番入れ替え機能があり、タップを追加すると誤操作のリスクが高まる
2. **編成解除後の手間**: メインスロットで編成を解除すると、再編成のためにドロワーを開き直す必要があり、操作が煩雑になる
3. **意図的な設計**: ドロワーで編成解除を提供することで、一覧を見ながら調整できる操作性を重視

**現状の確認事項**:
- 過去のコードでタップ編成解除機能が存在したかは不明（「いつの間にか使えなくなっていた」）
- 該当コードが削除済みか、機能しないコードが残存しているかは未確認
- 再実装は行わず、ドロワーでの編成解除に一本化する

#### 実装の優先順位
```
【Phase 1】ドロワー内パーティプレビュー（最重要）
├─ 1-1. ヘッダー直下にプレビューエリアを追加
├─ 1-2. P# + 5つのミニアイコン表示（currentPartyIdに連動）
├─ 1-3. タップで編成解除機能の実装
├─ 1-4. 条件判定の即時更新
└─ 1-5. 動作確認

【Phase 2】ミニアイコンのドラッグ＆ドロップ
├─ 2-1. 既存のDnDロジックをミニアイコンに適用
├─ 2-2. ゴースト要素の作成とホバーハイライト
├─ 2-3. 配列の順番入れ替え処理
├─ 2-4. メイン画面との同期確認
└─ 2-5. 動作確認

【Phase 3】長押しプレビュー機能
├─ 3-1. 長押し検出ロジックの実装（1秒タイマー）
├─ 3-2. オーバーレイ表示の実装
├─ 3-3. プレビュースロットの生成（80%サイズ）
├─ 3-4. 仮想パーティでの条件判定実行
├─ 3-5. タッチ/クリック終了時の即時クローズ
└─ 3-6. 動作確認

【Phase 4】細部の調整
├─ 4-1. ミニアイコンのサイズ調整（実装時に確認）
├─ 4-2. プレビュー表示の位置・サイズの微調整
├─ 4-3. パーティ切り替え連動の動作確認
└─ 4-4. モバイル/PC両環境での操作性確認
```

### 5.5. バックエンドの主要なロジック
- **データ供給**:
    - `/`ルートは、`get_initial_data()`を通じて、アプリに必要なすべてのデータを初回ロード時に一括で`index.html`に埋め込む。これにより、以降の操作でサーバーへの問い合わせが不要になる。
- **パフォーマンス**:
    - `get_initial_data()`は`@lru_cache(maxsize=1)`でデコレートされており、DBへの高負荷なクエリはアプリケーション起動後の一度しか実行されない。

---

## 6. バフ・デバフシステムの設計（2025年10月更新）

### 6.1. 目的と設計思想

個性テキストから抽出したバフ・デバフ効果を構造化し、編成画面でリアルタイムにバフ枠の使用状況と効果一覧を表示する。将来的には戦闘シミュレーションにも活用する。

**設計の核心**:
- **1行 = 1バフ**: 検索性と競合チェックの容易さを優先
- **キャラ単位での作業**: 3個性をまとめて確認・修正
- **AI支援型反復学習**: 修正パターンを学習し、段階的に精度向上
- **シンプルなタスク**: ユーザーは「確認・修正」に集中、差分記録は自動化

### 6.2. データベース設計

#### skill_complete テーブル

```sql
CREATE TABLE skill_complete (
    -- 主キー（自動連番）
    effect_id SERIAL PRIMARY KEY,                 -- バフ1つにつき1行
    
    -- 基本情報
    alien_id INTEGER NOT NULL,                    -- エイリアンID (alien.idへの外部キー)
    skill_number INTEGER NOT NULL,                -- 個性番号 (1, 2, 3)
    group_id INTEGER NOT NULL,                    -- 同時発動する効果のグループID
    
    -- バフ・デバフの詳細
    name TEXT NOT NULL,                           -- 効果名 (例: "つよさアップ", "呪縛無効")
    target TEXT NOT NULL,                         -- 対象 (SELF, ALL_ALLIES, ALL_ENEMIES, RANDOM_ALLY...)
    value NUMERIC,                                -- 効果量 (130, 50, 0...)
    unit TEXT NOT NULL,                           -- 単位 (PERCENT, FLAT, SECONDS, COUNT, NONE)
    duration INTEGER DEFAULT 0,                   -- 持続時間 (0=永続, N=N秒間)
    probability INTEGER DEFAULT 100,              -- 発動確率 (%)
    occupies_slot BOOLEAN,                        -- バフ枠を使用するか (null=不明)
    is_debuff BOOLEAN DEFAULT false,              -- デバフかどうか
    awakening_required BOOLEAN DEFAULT false,     -- 覚醒(★6)が必要か
    
    -- 発動タイミング
    trigger_timing TEXT NOT NULL,                 -- 発動タイミング
    -- BATTLE_START: 戦闘開始時（無条件）
    -- BATTLE_START_CONDITIONAL: 戦闘開始時（要求条件あり）
    -- ON_FIRST_ATTACK: 初回攻撃時
    -- ON_ATTACK: 攻撃する毎に
    -- ON_DAMAGED: 攻撃される毎に
    -- ON_DEFEATED: 倒された時
    -- ON_ALLY_DEFEATED: 味方が倒された時
    -- ON_KILL: 敵を倒した時
    -- ON_HP_BELOW: HP◯%以下で
    -- ON_HP_ABOVE: HP◯%以上で
    -- ON_TIMER: ◯秒経過後
    -- ON_COUNT: ◯回〜した時
    -- WHILE_ALIVE: 自分が倒されるまで
    -- WHILE_CONDITION: 条件を満たしている間
    
    trigger_condition JSONB,                      -- 追加条件 (例: {"hp_threshold": 50, "count": 25})
    
    -- 要求（このバフ単体の発動条件）
    has_requirement BOOLEAN DEFAULT false,        -- 要求の有無
    requirement_type TEXT,                        -- 条件タイプ (a:属性, b:所属, c:はんい, d:きょり, e:タイプ, f:ロール)
    requirement_value TEXT,                       -- 条件値
    requirement_count INTEGER,                    -- 必要数
    
    -- 検証状態
    verification_status TEXT DEFAULT 'unverified', -- unverified, verified, on_hold
    verified_at TIMESTAMP,                         -- 検証完了日時
    
    -- 解析情報（開発中のみ使用）
    llm_model TEXT,                                -- 使用したモデル名（例: gemini-2.5-pro）
    llm_analyzed_at TIMESTAMP,                     -- LLM解析日時
    
    -- 修正履歴（誤り学習用）
    original_llm_values JSONB,                     -- LLMの最初の出力（修正前）
    -- 例: {"occupies_slot": true, "target": "SELF", "value": 100}
    
    corrections JSONB,                             -- 修正内容の記録（最終的な差分のみ）
    -- 例: {"occupies_slot": {"old": true, "new": false}, "value": {"old": 100, "new": 130}}
    -- 複数回修正した場合は最初のoldと最後のnewのみ記録
    
    notes TEXT,                                    -- メモ（保留理由など）
    
    -- 制約
    FOREIGN KEY (alien_id) REFERENCES alien(id) ON DELETE CASCADE
);

-- インデックス
CREATE INDEX idx_effect_alien ON skill_complete(alien_id, skill_number);
CREATE INDEX idx_effect_verification ON skill_complete(verification_status);
CREATE INDEX idx_effect_timing ON skill_complete(trigger_timing);
CREATE INDEX idx_effect_name ON skill_complete(name);
CREATE INDEX idx_effect_occupies_slot ON skill_complete(occupies_slot);
```

**設計のポイント**:
1. **1行 = 1バフ**: 「やるきアップ」「つよさデバフ無効」などを個別の行に保存。バフ枠の競合チェック（同じnameのバフが9個以上）が`COUNT(*) WHERE name = 'やるきアップ'`で簡単に実行できる。
2. **group_idで関連付け**: 「デバフ（つよさ・やるき・いどう・気絶）への抵抗力」のような複数バフは同じgroup_idを持つ。
3. **skill_name/skill_textは不要**: `alien`テーブルから`JOIN`で取得可能。
4. **occupies_slotはnull許可**: 不明な場合はnullのまま保存し、後で推定ロジックで埋める。

### 6.3. バフ確認UIの設計

#### 表示場所
編成画面のヘッダー左側に「バフ確認」ボタンを配置。押下するとバフ確認モードに入る。

#### 表示内容
キャラアイコンをクリックすると、編成スロットの**中列（ステータスエリア）の上に重なるように**バフ一覧を表示。

**UI構造**（ゲーム画面の右下バフ欄を参考）:
```
┌─────────────────────┐
│ [枠外バフ]           │ ← スロットを使わないバフ（箇条書き）
│ ・たいりょく+130%    │
│ ・つよさ+130%        │
│ ・与ダメ+100%(対動物)│
├─────────────────────┤
│ [枠使用バフ 7/9]     │ ← バフ枠を使用するバフ（縦並びリスト、スクロール可）
│ ┌─────────────────┐ │
│ │ つよさアップ      │ │ ← 効果名 + 効果量を表示
│ │ +60%             │ │
│ │ (個性3)          │ │ ← どの個性からのバフか
│ └─────────────────┘ │
│ ┌─────────────────┐ │
│ │ 呪縛無効         │ │
│ │ (個性1)          │ │
│ └─────────────────┘ │
│ ┌─────────────────┐ │
│ │ じどうかいふく   │ │
│ │ +3%              │ │
│ │ (個性1・覚醒)    │ │
│ └─────────────────┘ │
│ ... (スクロール)     │
└─────────────────────┘
```

**実装の注意**:
- **効果量の表示**: ゲーム内では明記されていないが、このジェネレーターでは表示する（例: "+130%", "+50", "無効"）
- **赤枠アイコンは不使用**: 画像データがないため、文字と数字のみで実装
- **group_idの活用**: 複数バフが同時発動する場合（例: 複数のデバフ無効）は、個別に登録してgroup_idを統一
- **左列と右列の操作**: バフ確認モード中も、左列でドラッグ＆ドロップによる順番入れ替え、右列で個性の詳細確認が可能

#### 相手が受けるデバフの表示
現在検討中。将来的には別エリアまたはタブで表示予定。

### 6.4. 個性解析管理アプリ（date_create改良版）

#### アプリの構成
現在の`date_create/date_app.py`を拡張し、総合的な個性解析管理システムとする。

**主要な機能**:
1. **キャラ単位での作業**: 3個性をまとめて表示・編集
2. **LLM解析結果の表示**: 自動解析された結果をそのまま表示
3. **修正と保存**: 間違いがあれば修正して保存（差分を自動記録）
4. **保留機能**: キャラを持っていない場合などに保留ボタンで後回し
5. **進捗管理**: 検証済み/未検証/保留の統計表示とフィルター
6. **名前の一括置換**: 表記ゆれの修正を全データに適用
7. **バフ枠推定の支援**: 統計的推定とルールベースの推定を併用

#### UI構造

```
┌─────────────────────────────────────────────────────┐
│ エリたま個性解析管理システム                          │
├─────────────────────────────────────────────────────┤
│ [全体統計] 検証済: 150/1440 | 保留: 23 | 未検証: 1267 │
├─────────────────────────────────────────────────────┤
│ [フィルター] ☑️未検証のみ ☐保留のみ ☐検証済みのみ     │
│ [検索] ID: [____] 名前: [_______] [検索]             │
├─────────────────────────────────────────────────────┤
│                                                       │
│ 【現在のキャラ】                                      │
│ エイリアン: #1483 "エクスカリバー" (480体中 23番目)   │
│                                                       │
│ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━      │
│ ▼ 個性1: スピリチュアルスピン                         │
│ ┌───────────────────────────────────────────┐      │
│ │機械/ナゾ属性からの被ダメージを70%軽減し、      │      │
│ │呪縛への抵抗力をつけるぞ！                  │      │
│ │＜個性覚醒(★６)＞味方全員のたいりょくを     │      │
│ │3%ずつ徐々に回復し続ける                    │      │
│ └───────────────────────────────────────────┘      │
│                                                       │
│ [要求] ☐なし ☑️あり                                  │
│   条件: 属性 ▼ | 値: 動物 ▼ | 必要数: 2              │
│   [+ 要求追加]                                        │
│                                                       │
│ [バフ・デバフ] (4件)                                  │
│ ┌─ Group 1 ────────────────────────────┐          │
│ │ [削除]                                        │          │
│ │ 効果名: 被ダメ軽減(対機械) ▼                  │          │
│ │ 対象: 自分 ▼ | 値: 70 | 単位: % ▼            │          │
│ │ 持続: 0秒 | 確率: 100%                       │          │
│ │ ☑️ バフ枠使用 ☐ デバフ ☐ 覚醒必要            │          │
│ │ 💡 推定: 使用しない (信頼度: 85%)              │          │ ← 推定表示
│ │    理由: 対象限定は枠不使用 [適用]            │          │
│ │ 発動: 戦闘開始時 ▼                            │          │
│ │ 追加条件: [なし ▼]                           │          │
│ │ 要求: ☐あり                                  │          │
│ └───────────────────────────────────┘          │
│ [+ バフ追加]                                          │
│                                                       │
│ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━      │
│ ▼ 個性2: ... (同様)                                  │
│ ▼ 個性3: ... (同様)                                  │
│                                                       │
│ 備考・メモ:                                           │
│ ┌───────────────────────────────────────────┐      │
│ │ (保留理由などを記入)                            │      │
│ └───────────────────────────────────────────┘      │
│                                                       │
│ [← 前のキャラ] [保留] [保存して次へ →]               │
│                                                       │
│ ※ 修正した場合、元のLLM出力との差分を自動記録          │
└─────────────────────────────────────────────────────┘
```

#### 入力フォームの要素

**現在の入力フォーム**（date_app.pyから継承）:
- バフ名（ドロップダウン、既存の名前リストから選択）
- 対象（SELF, ALL_ALLIES, ALL_ENEMIES...）
- 効果量（数値入力）
- 単位（PERCENT, FLAT, SECONDS, COUNT, NONE）
- 確率（%）
- バフ枠使用（チェックボックス）
- デバフか（チェックボックス）
- 覚醒必要（チェックボックス）

**追加する項目**:
- **発動タイミング**（ドロップダウン）: BATTLE_START, ON_ATTACK, ON_HP_BELOW...
- **発動条件**（JSONB入力 or 構造化フォーム）: 例 `{"hp_threshold": 50, "count": 25}`
- **要求の有無**（チェックボックス）: チェック時に要求入力エリアを表示
- **要求入力エリア**: 
  - 条件タイプ（属性/所属/タイプ/ロール/攻撃範囲/攻撃距離）
  - 条件値
  - 必要数

**名前管理機能**:
- **個別修正**: 個別に名前を変更（date_app.pyの既存機能を継続）
- **一括置換**: 「与ダメージアップ」→「与ダメアップ」を全データに適用
- **表記ゆれ検出**: LLMが「与ダメージアップ」「与ダメup」「ダメージアップ」を検出し、統一候補を提案

#### 保存時の動作

1. **修正なしの場合**: `verification_status='verified'`, 次の未検証キャラに遷移
2. **修正ありの場合**: 
   - 変更があったフィールドのみ`corrections`に記録
   - `original_llm_values`と現在の入力値を比較して差分を抽出
   - 複数回修正した場合は最初の`old`と最後の`new`のみ記録
   - `verification_status='verified'`, 次の未検証キャラに遷移
3. **保留の場合**: `verification_status='on_hold'`, `notes`にメモを保存

#### バフ枠推定機能

**統計的推定**:
```python
def estimate_occupies_slot(effect_name, target, has_requirement):
    """
    過去の検証済みデータから、同じ名前のバフの
    occupies_slot を統計的に推定
    """
    # 同じ名前のバフで検証済みのものを集計
    # 最多のoccupies_slot値を信頼度と共に返す
```

**ルールベース推定**:
```python
def rule_based_estimate(effect_name, target, has_requirement):
    """
    ルールベースでの推定
    """
    # 〇〇無効系 → true
    # 味方全員対象 → true
    # 条件付き自己バフ → false
    # (対〇〇)系 → false
```

**UI上での表示**:
- 推定結果を「💡 推定: 使用しない (信頼度: 85%)」のように表示
- 「適用」ボタンで推定値を入力欄に反映
- ユーザーは推定を参考に判断し、確信がない場合はnullのまま保存OK

### 6.5. LLM解析システム（✅Phase 1完了、Phase 2へ移行準備中）

#### 解析スクリプト: scripts/llm/llm_buff_analyzer.py

**現在の状態（2025年10月22日）**:
- ✅ 実装完了: Gemini 2.5 Flash Liteによる順次解析システム
- ⏳ 実行中: 460体（1380個性）の自動解析処理（予想時間: 約31分）
- ✅ レート制限対応: RPM=15制限に対応（4.1秒間隔の順次処理）
- ✅ バックアップ機能: `--truncate`実行前に自動でJSONLバックアップを作成

**技術的な詳細**:
- **使用モデル**: Gemini 2.5 Flash Lite（デフォルト）
  - RPM: 15リクエスト/分
  - RPD: 1000リクエスト/日
  - 無料枠で利用可能
- **処理方式**: 非同期順次処理（`asyncio`）
  - 1体ずつ処理し、各リクエスト後に4.1秒待機
  - 並列処理は使用しない（RPM制限を確実に守るため）
- **API キー**: 環境変数の優先順位
  1. `GEMINI_API_KEY_2`（主に使用）
  2. `GEMINI_API_KEY_1`（フォールバック）
  3. `GEMINI_API_KEY`（フォールバック）

**主要な関数**:
```python
def resolve_api_key():
    """環境変数から優先順位に従ってAPIキーを取得"""
    # GEMINI_API_KEY_2 → GEMINI_API_KEY_1 → GEMINI_API_KEY の順

async def process_aliens_parallel(aliens, batch_size, concurrency, model_name, model, rpm):
    """
    準並列処理でエイリアンを解析
    - 送信: 4.5秒間隔（60/15 + 0.5）で順次送信
    - 応答: 全リクエストを並行して待機
    - 戻り値: (全バッチの効果リスト, None応答のバッチリスト)
    """
    
async def process_one_batch_gemini(batch, batch_num, batch_size, model_name, model):
    """
    1体のエイリアンをGemini APIで解析
    loop.run_in_executor()で同期APIを非同期化
    """

def parse_llm_response(raw_text):
    """
    LLMの生テキスト出力からJSON部分を抽出
    - コードフェンス (```json ... ```) を除去
    - 最後の } または ] を探してJSON部分を切り出し
    - None/空文字チェックを先頭で実施
    """

def call_gemini(model, prompt):
    """
    Gemini APIに同期的にリクエスト送信
    model.generate_content(prompt).text を返す
    - None応答の場合は詳細なエラーメッセージ
    """
```

**実行方法**:
```bash
# 通常実行（既存データに追加）
python -m scripts.llm.llm_buff_analyzer

# テーブルを空にしてから実行（バックアップ自動作成）
python -m scripts.llm.llm_buff_analyzer --truncate

# モデル指定（デフォルト: gemini-2.5-flash-lite）
python -m scripts.llm.llm_buff_analyzer --model gemini-2.5-pro

# スキップ数指定（デバッグ用）
python -m scripts.llm.llm_buff_analyzer --skip 20
```

**自動リトライ機構**:
- **None応答の検出**: `call_gemini()`と`parse_llm_response()`でNone/空文字を検出し、RuntimeErrorを送出
- **失敗バッチの記録**: `process_aliens_parallel()`がエラーメッセージに"None"または"空"が含まれる場合、`failed_batches`リストに記録
- **自動再解析**: `main()`が初回解析完了後、`failed_batches`が空でない場合に自動で再解析を実行
- **RPM制限遵守**: 再解析も同じ4.5秒間隔で実行され、レート制限を確実に守る
- **結果の統合**: 再解析で得られた効果を`all_rows`に追加し、最終的に一括でDBに挿入
- **二重失敗の記録**: 再解析でも失敗したバッチは`retry_failed`に記録され、コンソールにログ出力

**出力データの構造**:
解析結果は`skill_complete`テーブルに以下の形式で保存されます：
```python
{
    "alien_id": 925,
    "skill_number": 1,
    "group_id": 1,
    "name": "つよさアップ",
    "target": "SELF",
    "value": 130,
    "unit": "PERCENT",
    "duration": 0,
    "probability": 100,
    "occupies_slot": True,  # LLMが推定
    "is_debuff": False,
    "awakening_required": False,
    "trigger_timing": "BATTLE_START",
    "trigger_condition": None,
    "has_requirement": True,
    "requirement_type": "a",  # a=属性
    "requirement_value": "1", # 1=動物
    "requirement_count": 2,
    "verification_status": "unverified",
    "llm_model": "gemini-2.5-flash-lite",
    "llm_analyzed_at": "2025-10-22 14:30:00"
}
```

**プロンプト設計の方針**（実装済み）:

既存の2つのプロンプトを統合:
1. `scripts/llm/llm_skill_importer.py`の要求判定プロンプト（精度90%）
2. `date_create/date_app.py`のバフ抽出プロンプト

**統合プロンプトの構造**:
```
# 第1段階: 文章のブロック分け
個性テキストを以下のブロックに分解:
- 要求ブロック: "味方に〇〇がいると"
- 開始直後発動ブロック: "WAVE開始時", "〜〜中"
- イベント駆動ブロック: "攻撃する毎に", "倒された時"
- 覚醒ブロック: "＜個性覚醒(★６)＞"

# 第2段階: 各ブロックから具体的な効果を抽出
- バフ名: 既存データの命名規則に従う
- 効果量: 数値を抽出
- 対象: SELF, ALL_ALLIES...
- バフ枠: 既存データと要求の有無を参考に推定

# 第3段階: 要求の抽出
- 条件タイプ: 属性/所属/タイプ/ロール...
- 条件値: 具体的な属性ID等
- 必要数: N体以上

# 出力形式
{
  "alien_id": 1483,
  "skill_number": 1,
  "requirements": [...],
  "effects": [
    {
      "group_id": 1,
      "name": "被ダメ軽減(対機械)",
      "target": "SELF",
      "value": 70,
      "unit": "PERCENT",
      "trigger_timing": "BATTLE_START",
      "occupies_slot": false,  // 推定値
      ...
    }
  ]
}
```

**注意事項**:
- ✅ プロンプトの詳細化は実装済み（Phase 1完了）
- ✅ 既存の検証済みデータ（142件）をFew-shot examplesとして活用
- ✅ 要求判定は既存のプロンプトが高精度（90%）なので参考にした

**次のステップ（Phase 2: 手動検証フェーズ）**:
1. ✅ 解析完了を待つ（約31分、1380個性）
2. データベースの`skill_complete`テーブルを確認
3. サンプル抽出（30-50個性）してLLM解析の精度を評価
4. `date_create/date_app.py`の拡張に着手:
   - キャラ単位での表示（3個性まとめて）
   - 修正内容の差分自動記録
   - 進捗管理機能（検証済み/未検証/保留）
   - バフ枠推定表示（統計的推定 + ルールベース推定）
5. 手動検証開始（1日10-20キャラ = 30-60個性を目標）

### 6.6. 実装計画とフェーズ分け（2025年10月23日 更新）

**現在の進捗**: Phase 1完了 → **Phase 2実装中**

```
【Phase 0】準備 (✅完了)
├─ ✅ skill_completeテーブル作成
├─ ✅ マイグレーションスクリプト実行
├─ ✅ 既存JSONLデータ（142件）の変換・投入
└─ ✅ テーブル動作確認

【Phase 1】解析スクリプト開発 (✅完了)
├─ ✅ llm_buff_analyzer.py 作成
│   - ✅ プロンプト統合（要求判定 + バフ抽出）
│   - ✅ 順次解析機能（4.5秒間隔でRPM=15を遵守）
│   - ✅ occupies_slot推定機能
│   - ✅ 全発動タイミングの抽出
│   - ✅ バックアップ機能（--truncate実行前）
│   - ✅ 自動リトライ機構（None応答を自動再解析）
├─ ✅ 全460体を解析完了（約1371個性のバフ・デバフ効果を抽出）
└─ ✅ Phase 1完了（解析精度: 99.3%）

【Phase 2】管理アプリ拡張（⏳実装中）

▼ Phase 2の詳細実装計画（2025年10月23日策定）

【Phase 2.1】データソース切り替え（最優先）✅着手中
目的: JSONL形式からskill_completeテーブルへの移行
├─ 1. date_app.py: load_processed_data() の改修
│   - skill_completeテーブルからデータ取得に変更
│   - verification_statusに基づくステータス管理
│   - original_llm_values の取得と保持
├─ 2. date_app.py: save_labels() の改修
│   - skill_completeテーブルへのUPSERT処理
│   - correctionsカラムへの差分記録
│   - verification_statusとverified_atの更新
├─ 3. date_app.py: get_alien_data() の改修
│   - skill_completeから個性データを取得
│   - LLM解析結果（original_llm_values）をフォームに自動入力
├─ 4. date_app.py: get_unique_buff_names() の改修
│   - skill_completeから効果名リストを取得
│   - バフ/デバフの分類を維持
└─ 5. 動作確認（既存機能が正常に動作するか）

【Phase 2.2】新規入力項目の追加
目的: skill_completeの全カラムに対応する入力欄を実装
├─ ✅ 6. date_index.html: 発動タイミング（trigger_timing）入力欄
│   - ドロップダウン（BATTLE_START, ON_ATTACK, ON_HP_BELOW...）
│   - 各バフ行に追加
├─ ✅ 7. date_index.html: 発動条件（trigger_condition）入力欄（保留）
│   - 現状は手動でJSONB入力が必要な複雑なケースのみ
│   - 将来的に必要に応じて構造化フォーム追加を検討
├─ ✅ 8. date_index.html: 要求（requirement_*）入力エリア
│   - チェックボックス「要求あり」
│   - ドロップダウンメニューで要求を選択（「属性：動物」「所属：宇宙連合」など項目と値をセットで表示）
│   - 必要数入力欄（1-5）と「以外」チェックボックスを同じ行に配置
│   - requirement_valueの末尾に"!"を付けて「以外」を表現
│   - 要求タイプマッピング（llm_buff_analyzer.pyのプロンプトと一致）:
│     - 属性 (a): 動物=1, 昆虫=2, 機械=3, ナゾ=4
│     - 所属 (b): 宇宙連合=1, 星間帝国=2, 恒星連邦=3, unknown=4, 銀河同盟=5
│     - 攻撃範囲 (c): たんたい=1, はんい=2
│     - 攻撃距離 (d): ちかい=1, ふつう=2, とおい=3
│     - ロール (f): 攻撃=1, 防御=2, 支援=3, 回復=4
│     - タイプ (e): 海=A, 夜=B, 氷=C, ラブ=D, 空=E, 音=F, 魔術=G, 熱=H, 大和=I, エレメント=J, 新星=K, チケット=L, 突然変異=M, 競技=N, 盗賊=O, 祈祷=P, 闇=Q, パックマン/カタログIP=AA
│   - 既存データ読み込み時の正しい処理（"!"の検出とチェックボックス反映）
│   - 不要なtemplateフォルダを削除（templatesフォルダのみ使用）
├─ ✅ 9. date_app.py: 拡張データの保存処理
│   - 新規カラムのINSERT/UPDATE処理を追加
└─ ✅ 10. 動作確認（全項目が正しく保存・読み込みされるか）
    - ドロップダウン形式: type:value形式（例: "a:1" = 属性：動物）
    - 「以外」機能: requirement_valueの末尾"!"で判定
    - 必要数: 1-5の数値入力
    - 既存データの正確な読み込み:
      - addBuffRow内で effect.has_requirement が true の場合、自動的に buildRequirementIconSelector を呼び出し
      - hidden inputs から既存の requirement_type, requirement_value, requirement_count を読み取り
      - ドロップダウンの選択、数値入力、「以外」チェックボックスを正しく復元

【Phase 2.3】差分記録機能（コア機能）✅完了
目的: LLMの出力と手動修正の差分を自動記録
├─ ✅ 11. date_app.py: 差分計算ロジックの実装
│   - calculate_corrections()関数で original_llm_values と現在値を比較
│   - 変更があったフィールドのみcorrectionsに記録
│   - 複数回修正時は最初のoldと最後のnewのみ保持
├─ ✅ 12. date_app.py: original_llm_valuesの初回保存
│   - save_labels()でLLM解析結果を初回保存時に記録
│   - verification_status='unverified'のレコードのみoriginal_llm_valuesを設定
│   - 2回目以降は既存のoriginal_llm_valuesを保持し、correctionsのみ更新
├─ ⏸️ 13. date_index.html: 修正箇所のハイライト表示（Phase 3で実装予定）
│   - original_llm_valuesと現在値が異なる項目を視覚的に強調
└─ ⏸️ 14. 動作確認（Phase 3で実施予定）

【Phase 2.4】進捗管理とバフ枠推定 ✅完了
目的: 検証作業の効率化と推定支援
├─ ✅ 15. date_app.py: 統計情報取得API (/get-stats)
│   - verification_statusごとのエイリアン数を集計
│   - verified, on_hold, unverified, totalを返す
├─ ✅ 16. date_index.html: 全体統計の表示エリア
│   - ヘッダー上部に「検証済み: X/1440 | 保留: Y | 未検証: Z」を表示
│   - フィルターチェックボックス（未検証のみ/保留のみ/検証済みのみ）実装
│   - applyFilter()でエイリアン一覧の表示/非表示を制御
├─ ✅ 17. date_app.py: バフ枠推定関数（統計的推定）
│   - 同じ効果名の検証済みデータから最多値を取得
│   - 信頼度（high/medium/low）を計算（データ数と一致率から）
├─ ✅ 18. date_app.py: バフ枠推定関数（ルールベース推定）
│   - estimate_by_rules()関数を実装
│   - 「無効/抵抗」→ true、「対〇〇」→ false
│   - ALL_ALLIES → true、条件付きSELF → false
├─ ✅ 19. date_app.py: 推定結果取得API (/estimate-slot)
│   - 統計的推定 + ルールベース推定の結果を返す
│   - occupies_slot, confidence, reasonを含むJSON形式
├─ ✅ 20. date_index.html: 推定機能の実装
│   - バフ枠選択の下に「推定」ボタンを追加
│   - estimateSlot()関数で/estimate-slot APIを呼び出し
│   - alertで推定結果、信頼度、理由を表示
│   - 推定値を自動的にバフ枠selectに反映
├─ ✅ 21. date_app.py: 保留機能 (/hold-alien)
│   - verification_status='on_hold'に更新
│   - notesカラムに保留理由を保存
└─ ✅ 22. date_index.html: 保留ボタンの追加
    - 「保留（後で確認）」ボタンをUIに配置
    - holdAlien()関数で/hold-alien APIを呼び出し
    - 保存後に統計情報を更新し、次の未検証エイリアンに移動

【Phase 2.5】動作確認とテスト（✅完了）
├─ ✅ 23. サンプル30個性での検証
│   - 正しく読み込み・保存できるか
│   - 差分記録が正確か
├─ ✅ 24. 修正パターンの確認
│   - correctionsカラムのデータ構造を確認
│   - 典型的な修正パターンを特定
└─ ✅ 25. Phase 3への移行準備
    - ワークフローの最適化
    - 一括読み込み方式に変更（起動高速化）
    - 4段階検証ステータスシステム完成

【Phase 3】AI支援型反復学習（プロンプト最適化）
目的: 手動検証データを蓄積し、LLMプロンプトを段階的に改善
├─ 1. 少数検証フェーズ（30-50個性）
│   - date_createアプリで手動検証
│   - correctionsカラムに修正パターンを蓄積
│   - 典型的な誤りの傾向を特定
├─ 2. プロンプト改善（1回目）
│   - 頻出する修正パターンをプロンプトに追加
│   - Few-shot examplesを10-15件追加
│   - サンプル30個性で精度検証
├─ 3. 中規模検証フェーズ（100個性まで）
│   - 改善したプロンプトで再解析
│   - さらに手動検証を継続
│   - 新たな修正パターンを発見
└─ 4. プロンプト改善（2回目）
    - Few-shot examplesを20件に拡充
    - ルールベースの推定ロジック追加
    - サンプル50個性で精度検証

【Phase 4】ファインチューニング準備（200-300個性検証）
目的: FT用データセットを構築し、LLMの精度を根本的に向上
├─ 1. 検証データの蓄積
│   - 200-300個性の手動検証完了
│   - correctionsデータを分析
│   - FT用データセット（JSONL形式）を生成
├─ 2. データセット品質チェック
│   - 多様性の確認（各パターンが網羅されているか）
│   - エッジケースの追加
└─ 3. Phase 5への移行判断
    - FT実行の準備完了
    - コスト試算と予算確認

【Phase 5】ファインチューニング実行
目的: Gemini 2.5 Flash LiteをFTし、高精度かつ高速なモデルを構築
├─ 1. FT実行（v1モデル）
│   - 200-300個性のデータセットでFT
│   - Gemini 2.5 Flash Liteを使用（理由: 高速、低コスト、無料枠）
├─ 2. FTモデルの精度検証
│   - 未検証データから100個性をサンプリング
│   - v1モデルで解析
│   - 手動検証して精度を測定（目標: 85%以上）
├─ 3. 精度が不十分な場合
│   - さらに100個性を手動検証
│   - データセットを400-500個性に拡充
│   - 2回目のFT（v2モデル）
└─ 4. 精度が十分な場合
    - Phase 6へ移行

【Phase 6】大規模再解析
目的: FTモデルで全未検証データを解析し、検証作業を大幅に効率化
├─ 1. 全未検証データの再解析
│   - v1（またはv2）モデルで残り1000個性以上を解析
│   - Flash Liteベースなので1日以内で完了
├─ 2. サンプル検証（100個性）
│   - 再解析結果をランダムに抽出
│   - 手動で精度を確認
│   - 精度が80%以上なら次へ
├─ 3. 残りの手動検証
│   - FTモデルの出力を元に、確認・修正作業
│   - 完全に正しいものはスキップ
│   - 誤りがあるもののみ修正
└─ 4. 全1440個性の検証完了
    - 目標: Phase 3開始から1-2ヶ月以内

【Phase 7】最終調整とファインチューニング（任意）
目的: さらに精度を高める場合、2回目または3回目のFTを実施
├─ 1. 全検証データでFT（v3モデル）
│   - 600-1000個性の高品質データセット
│   - 最終的な精度: 90%以上を目指す
├─ 2. 新規エイリアン追加時の自動解析
│   - v3モデルで新規キャラを自動解析
│   - 手動確認は最小限に
└─ 3. 定期的な再学習
    - ゲームアップデートで新キャラ追加時
    - 蓄積データでFTを更新

【Phase 8】メインアプリ統合（Phase 6と並行可）
├─ バフ確認UIの実装 (index.html)
│   - ヘッダーに「バフ確認」ボタン追加
│   - 中列へのバフ一覧表示
│   - 枠使用バフと枠外バフの分離表示
│   - requirement.value の末尾が"!"の場合に「◯◯以外」と解釈するロジックを追加
├─ バフ枠計算ロジック (app.py)
│   - 現在のパーティのバフ枠使用状況を集計
│   - 9枠制限のチェック
├─ app.pyのデータ供給拡張
│   - skill_completeテーブルからバフデータを取得
│   - 初回ロード時にバフデータもキャッシュ
└─ 動作テスト
```

**Phase 1で得られた知見**:
1. **DeepSeek APIの限界**: 当初「無制限」と聞いて試したが、実際はRPM=20, RPD=50の厳しい制限があった
2. **Gemini 2.5 Flash Liteの優位性**: RPM=15, RPD=1000で無料枠内で大量処理が可能
3. **並列処理の罠**: Semaphoreで並列数を制限しても、バッチごとに一斉送信されるとRPM違反になる
4. **準並列処理の有効性**: 送信タイミングを制御（4.5秒間隔）し、回答は並行待ちすることで効率を最大化
5. **RPM制限の微妙さ**: 4.0秒では理論上OK、4.1秒でも稀に違反、4.5秒で安定動作を確認
6. **API応答の不安定性**: 稀にNone応答が返されるため、明示的なチェックとエラーメッセージが必要
7. **接続タイムアウト対策**: 長時間処理（34分）では解析後に新しい接続を作成して挿入する必要がある
8. **バックアップの自動化**: `--truncate`実行前に自動バックアップすることで、誤削除のリスクを低減
9. **自動リトライ機構**: None応答のバッチを記録し、初回解析完了後に自動で再解析。エラーメッセージ表示だけでは不十分で、自動復旧の方が確実かつユーザーフレンドリー

**Phase 2の設計判断と注意点**:
1. **一括読み込み+キャッシュ方式**: メインアプリと同様に、`get_initial_data()`で全データを起動時に読み込み、`@lru_cache`でキャッシュ。保存・保留時に`cache_clear()`で再読み込み
2. **4段階検証ステータス**: verified（完全検証済み）、partial_verified（枠以外検証済み）、on_hold（保留）、unverified（未検証）
3. **original_llm_valuesの扱い**: Phase 1で既にskill_completeに格納済み。初回編集時はこのデータをフォームに自動入力
4. **複数回修正時の挙動**: 最初のoldと最後のnewのみ記録することで、修正の変遷を追跡
5. **データフローの変更**: `skill_complete (LLM解析済み) → get_initial_data()でキャッシュ → UI表示 → ユーザー修正 → skill_complete更新 → cache_clear()`

### 6.7. 設計の意図と補足

**なぜ1行=1バフなのか**:
- ゲーム内ではバフ枠が9個までの制限があり、「やるきアップ」のような同名バフが複数発動すると競合する
- 1行=1バフにすることで、`SELECT COUNT(*) WHERE name = 'やるきアップ' AND occupies_slot = true`で簡単に枠の使用数をカウントできる
- JSONB配列で複数バフを保存すると、特定のバフだけを検索・集計するクエリが複雑になる

**なぜキャラ単位で作業するのか**:
- ユーザーは1キャラの3個性をまとめて確認したい（個性間の関連性を把握しやすい）
- 1個性ずつ保存すると、3回保存ボタンを押す手間が発生
- キャラ単位で作業することで、1回の保存で3個性分のデータを処理できる

**なぜoccupies_slotにnullを許可するのか**:
- ユーザーはすべてのキャラを所持しておらず、完璧な情報を持っていない
- 不明な場合は無理に判断せず、nullのまま保存してOK
- 後で統計的推定やルールベースで埋められる可能性がある

**なぜAI支援型反復学習なのか**:
- 1440個性すべてを手動検証するのは時間がかかる（1日30個性でも48日）
- 100個性検証すればパターンが見えてくる → ルールベース修正で時短
- 300個性でFT → 精度向上 → 残りの検証が楽になる
- 段階的に精度を上げることで、ユーザーの負担を最小化

**なぜプロンプトを統合するのか**:
- 要求判定とバフ抽出を別々に実行すると、API呼び出しが2倍になる
- 個性テキストの文脈を一度に解釈することで、精度が向上する
- ブロック分けを先に行うことで、LLMが構造を理解しやすくなる

**複数バフのgroup_id管理**:
- 「デバフ（つよさ・やるき・いどう・気絶）への抵抗力」のような複数効果は、個別に登録（つよさデバフ無効、やるきデバフ無効、いどうデバフ無効、気絶無効）してgroup_idを統一
- 同じ個性内で別の効果（やるきアップ、与ダメアップなど）は別のgroup_idを割り当てる
- これにより「同時発動するバフのまとまり」と「独立したバフ」を区別できる

**5体バッチ解析の理由**:
- APIレート制限（100件/日）を考慮し、480体を効率的に処理
- 480体 ÷ 5体/リクエスト = 96リクエスト ≒ 1日で完了
- 個別解析（1440リクエスト）だと14日以上かかる
- コンテキストが混ざらない限り、バッチ処理でも精度は維持される

**タスクのシンプル化の意図**:
- ユーザーは「確認・修正」というシンプルなタスクに集中
- 差分記録、パターン分析、推定ロジックの更新は裏で自動実行
- 複雑な処理をバックグラウンドで行うことで、作業の心理的負担を軽減
- 決まったワークフローに集中できることで、長時間の作業でも疲労しにくい

---

## 7. コード品質とメンテナンス方針（2025年1月更新）

### 7.1. 現在のコードベース状況

**`templates/index.html`の成長**:
- **現在の行数**: 約2800行（2025年1月時点）
- **成長率**: プロジェクト初期から2〜3倍に拡大
- **主な増加要因**:
  - 長押しプレビュー機能（約200行）
  - パーティ全体概要表示機能（約300行）
  - ドロワー内パーティプレビューの拡張（約250行）
  - ドラッグ＆ドロップの各種対応（約150行）
  - スキル展開・条件判定ロジックの強化（約200行）

**コードの現状評価**:
- **✅ 構造的な問題は無し**: 機能ごとに明確に分離されており、保守性を損なっていない
- **✅ 関数の責務は明確**: `renderPartySlots()`, `checkPartyRealtime()`, `updateAlienCardSelectedState()`など、各関数の役割が明確
- **✅ 状態管理は適切**: `parties`, `openedSkills`, `dragState`, `longPressState`, `overviewDragState`など、各状態オブジェクトがそれぞれの責務を持つ
- **✅ シンプルな実装方針の維持**: アニメーションライブラリや仮想DOMを使わず、基本的なDOM操作で実装されている
- **✅ PC/モバイル統一実装**: ポインターイベントで統一的に実装され、別々のコードパスが無い

**行数増加の評価**:
- **自然な成長**: 機能追加に伴う増加であり、不必要な複雑化ではない
- **リファクタリングの必要性**: 現時点では低い。コードの可読性と保守性は十分に保たれている
- **将来的なファイル分割**: 5000行を超えたタイミングで検討（現在は不要）

### 7.2. 開発方針とベストプラクティス

**1. シンプルさを最優先**:
- ✅ 複雑なアニメーションライブラリは使用しない
- ✅ 仮想DOMや状態管理ライブラリは導入しない
- ✅ 基本的なDOM操作とCSS transitionで十分な場合は、それを優先
- ✅ 「動作する最もシンプルな実装」を選択

**2. バグの温床を避ける**:
- ✅ FLIP animations、複雑な状態管理ライブラリは過去の経験から除外
- ✅ 別々のコードパス（PC用/モバイル用）は作らない
- ✅ 型安全な比較（`parseInt()`で統一）を徹底
- ✅ エラーハンドリングを適切に実装（`console.error()`でデバッグ情報を記録）

**3. 機能追加時のチェックリスト**:
- [ ] 既存の関数を再利用できるか確認
- [ ] 新しい状態オブジェクトが必要か、既存の状態オブジェクトで対応できるか検討
- [ ] PC/モバイル両方で動作するか確認
- [ ] 型安全な比較を実装しているか確認
- [ ] エラーハンドリングを実装しているか確認
- [ ] 既存の機能との競合や副作用が無いか確認

**4. デバッグとエラー処理**:
- ✅ `console.log()`でステップごとの動作を確認
- ✅ `console.error()`でエラー発生時の詳細情報を記録
- ✅ データ取得失敗時の適切なフォールバック処理
- ✅ ユーザーに見える形でのエラー表示（将来的に検討）

**5. 今後のリファクタリング判断基準**:
- **実施しない条件**:
  - コードの可読性が保たれている
  - 保守性に問題が無い
  - 機能追加が困難でない
- **実施する条件**:
  - ファイルサイズが5000行を超えた
  - 同じロジックが3箇所以上で重複している
  - バグの頻発により保守性が低下した
  - 新機能追加が著しく困難になった

**6. 問題解決の思考プロセス（長押しプレビュー機能の教訓）**:
- **複雑な解決策に飛びつかない**: インデックスマッピングや置き換えロジックを考える前に、「制約そのものを緩和できないか」を検討する
- **既存の制約を疑う**: 「5スロット固定」という制約は、通常のパーティには必須だが、プレビュー専用では6スロットを許可しても問題ない
- **特別なケースの特別扱い**: 通常のロジックに無理やり合わせるのではなく、特別なケース（`partyId === 'preview'`）として明示的に分岐する方が、コードが読みやすく保守しやすい
- **データと表示の一致を保つ**: 「表示用の配列」と「判定用の配列」を分けると、整合性の管理が複雑になる。可能な限り同じデータ構造を使う
- **段階的なアプローチ**: 最初から完璧な解決策を目指さず、動作する最小限の実装から始めて、問題が出たら修正する

### 7.3. 技術的負債の管理

**現在の技術的負債**:
- **無し**: 現時点では重大な技術的負債は存在しない
- **将来的なリスク**: 
  - ファイルサイズの継続的な増加（5000行を超える可能性）
  - 新機能追加に伴う状態管理の複雑化

**予防策**:
1. **機能追加時の慎重な設計**: 新機能が既存の設計思想と矛盾しないか確認
2. **定期的なコードレビュー**: 3ヶ月ごとにコードベース全体を見直し
3. **ドキュメンテーションの維持**: カスタム指示書を常に最新の状態に保つ
4. **テストの充実**: 主要な機能には手動テストケースを用意

**リファクタリング計画（5000行到達時）**:
1. **ファイル分割**: 
   - `party-management.js`: パーティ管理関連
   - `drag-and-drop.js`: ドラッグ＆ドロップ関連
   - `preview-features.js`: プレビュー機能関連
   - `filter-sort.js`: 絞り込み・ソート関連
2. **共通ユーティリティの抽出**: 
   - `utils.js`: `parseInt()`を使った型安全比較、DOM操作ヘルパー
3. **状態管理の整理**: 
   - `state.js`: 全状態オブジェクトを1つのファイルで管理

---

## 9. 追加されたファイルとスクリプト（2025年10月22日）

### 9.1. scripts/llm/llm_buff_analyzer.py

**目的**: 
個性テキストからバフ・デバフ効果を自動抽出し、`skill_complete`テーブルに保存するスクリプト。Phase 1で実装完了。

**主要な機能**:
1. **準並列処理によるレート制限遵守**: RPM=15制限を守りつつ、リクエスト送信と回答待ちを並行化
   - リクエストを4.5秒間隔で順次送信（初回は即座）
   - 回答は全リクエスト並行して待つ
   - 送信完了まで約34分、回答待ち時間は並行処理のため追加なし
2. **統合プロンプト**: 要求判定（llm_skill_importer.py）とバフ抽出（date_app.py）を統合
3. **自動バックアップ**: `--truncate`実行前に`backup_skill_complete.py`を自動呼び出し
4. **接続タイムアウト対策**: 解析完了後に古い接続を閉じ、挿入前に新しい接続を作成
5. **環境変数管理**: GEMINI_API_KEY_2 → GEMINI_API_KEY_1 → GEMINI_API_KEY の優先順位でAPI キー取得

**技術的詳細**:
- **非同期処理**: `asyncio.create_task()`でリクエストを非同期化し、`await asyncio.sleep(4.5)`で送信間隔を制御
- **レート制限対策**: RPM=15に対して4.5秒間隔（60/15 + 0.5秒マージン）を設定し、確実に制限内に収める
- **準並列処理の仕組み**:
  ```python
  # リクエスト1送信 → 4.5秒待機 → リクエスト2送信 → 4.5秒待機 → ...
  # 全リクエストが並行して回答を待つ
  for idx, (batch, batch_num) in enumerate(batches):
      if idx > 0:
          await asyncio.sleep(interval)  # 送信前に待機（4.5秒）
      task = asyncio.create_task(process_one_batch_gemini(...))  # 非同期送信
      tasks.append(task)
  
  # 全タスクの完了を待つ
  for task in tasks:
      rows = await task
  ```
- **JSON解析**: コードフェンス除去 + 末尾の`}`または`]`を検索してJSON部分を抽出
- **エラーハンドリング**: 
  - None応答チェック: `call_gemini()`と`parse_llm_response()`で空応答を検出
  - 個別のバッチで失敗しても処理を継続、エラーログを記録
  - RPM違反時は該当バッチをスキップ（再試行は手動で実施）

**使用例**:
```bash
# 通常実行（既存データに追加）
python -m scripts.llm.llm_buff_analyzer

# テーブルをクリアしてから実行（自動バックアップあり）
python -m scripts.llm.llm_buff_analyzer --truncate

# モデル指定
python -m scripts.llm.llm_buff_analyzer --model gemini-2.5-pro

# 最初のN体をスキップ（デバッグ用）
python -m scripts.llm.llm_buff_analyzer --skip 20
```

**出力データ構造**:
```python
{
    "alien_id": 925,
    "skill_number": 1,
    "group_id": 1,
    "name": "つよさアップ",
    "target": "SELF",
    "value": 130,
    "unit": "PERCENT",
    "duration": 0,
    "probability": 100,
    "occupies_slot": True,
    "is_debuff": False,
    "awakening_required": False,
    "trigger_timing": "BATTLE_START",
    "trigger_condition": None,
    "has_requirement": True,
    "requirement_type": "a",
    "requirement_value": "1",
    "requirement_count": 2,
    "verification_status": "unverified",
    "llm_model": "gemini-2.5-flash-lite",
    "llm_analyzed_at": "2025-10-22 14:30:00"
}
```

**開発履歴と学び**:
1. **DeepSeek APIの試行**: 当初「無制限」という情報で試したが、RPM=20, RPD=50の制限があり断念
2. **並列処理の失敗**: Semaphoreで並列数を制限したが、バッチ単位で一斉送信されRPM違反
3. **順次処理への変更**: 4.1秒間隔の順次処理に変更し、確実にレート制限を遵守
4. **準並列処理への改良**: 送信タイミングを制御し、回答待ちを並行化することで効率を最大化
5. **RPM間隔の微調整**: 4.1秒では稀にRPM違反が発生したため、4.5秒（60/15 + 0.5秒）に変更
6. **None応答への対策**: API側の問題で空応答が返される場合があるため、`call_gemini()`と`parse_llm_response()`で明示的にチェック
7. **接続タイムアウト対策**: 解析（約34分）の間に接続が切れるため、解析後に新しい接続を作成して挿入
8. **Gemini 2.5 Flash Liteの選択**: RPM=15, RPD=1000で大量処理に最適、無料枠内で利用可能
9. **自動リトライ機構の実装**: None応答のバッチを記録し、初回解析完了後に自動で再解析。エラーメッセージ表示だけでは不十分で、自動復旧の方が確実かつユーザーフレンドリー

### 9.2. scripts/db/restore_skill_complete.py

**目的**: 
`skill_complete`テーブルをJSONLバックアップから復元するスクリプト。解析データの再利用や、エラー時のロールバックに使用。

**主要な機能**:
1. **JSONLファイルの読み込み**: 1行=1レコードのJSONL形式から全データを読み込み
2. **データ型変換**: JSON型フィールド（trigger_condition, original_llm_values, corrections）を適切に変換
3. **一括挿入**: `psycopg2.extras.execute_values`で高速挿入
4. **TRUNCATE オプション**: `--truncate`フラグで既存データを削除してから挿入

**目的**: 
`skill_complete`テーブルをJSONL形式でバックアップするスクリプト。`llm_buff_analyzer.py`の`--truncate`実行前に自動で呼び出される。

**主要な機能**:
1. **全データのエクスポート**: `skill_complete`テーブルの全レコードをJSONLファイルに保存
2. **タイムスタンプ付きファイル名**: `skill_complete_backup_YYYYMMDD_HHMMSS.jsonl`形式
3. **データ整合性チェック**: エクスポート前後でレコード数を比較

**使用例**:
```bash
# JSONLファイルから復元（既存データに追加）
python -m scripts.db.restore_skill_complete backups/skill_complete/backup.jsonl

# TRUNCATEしてから復元（完全置き換え）
python -m scripts.db.restore_skill_complete backups/skill_complete/backup.jsonl --truncate
```

### 9.3. scripts/db/backup_skill_complete.py

**目的**: 
`skill_complete`テーブルをJSONL形式でバックアップするスクリプト。`--truncate`での全削除前に必ずバックアップを実行します。

**主要な機能**:
1. **全データのエクスポート**: `skill_complete`テーブルの全レコードをJSONLファイルに保存
2. **タイムスタンプ付きファイル名**: `skill_complete_backup_YYYYMMDD_HHMMSS.jsonl`形式
3. **データ整合性チェック**: エクスポート前後でレコード数を比較

**使用例**:
```bash
# 手動バックアップ
python -m scripts.db.backup_skill_complete

# llm_buff_analyzer.pyから自動呼び出し（--truncate時）
# → backup_skill_complete.pyが自動実行される
```

**出力ファイル例**:
```
backups/skill_complete/skill_complete_20251022_143000.jsonl
```

**ファイル形式**:
```jsonl
{"alien_id": 925, "skill_number": 1, "group_id": 1, "name": "つよさアップ", ...}
{"alien_id": 925, "skill_number": 2, "group_id": 2, "name": "やるきアップ", ...}
...
```

### 9.4. データベーステーブル: skill_complete

**目的**: 
個性のバフ・デバフ効果を1行=1バフの構造で保存するテーブル。将来的なバフ枠計算、戦闘シミュレーション、AI学習データの基盤。

**スキーマ**:
```sql
CREATE TABLE skill_complete (
    -- 主キー
    effect_id SERIAL PRIMARY KEY,
    
    -- 基本情報
    alien_id INTEGER NOT NULL,
    skill_number INTEGER NOT NULL,
    group_id INTEGER NOT NULL,
    
    -- バフ・デバフの詳細
    name TEXT NOT NULL,
    target TEXT NOT NULL,
    value NUMERIC,
    unit TEXT NOT NULL,
    duration INTEGER DEFAULT 0,
    probability INTEGER DEFAULT 100,
    occupies_slot BOOLEAN,
    is_debuff BOOLEAN DEFAULT false,
    awakening_required BOOLEAN DEFAULT false,
    
    -- 発動タイミング
    trigger_timing TEXT NOT NULL,
    trigger_condition JSONB,
    
    -- 要求（このバフ単体の発動条件）
    has_requirement BOOLEAN DEFAULT false,
    requirement_type TEXT,
    requirement_value TEXT,
    requirement_count INTEGER,
    
    -- 検証状態
    verification_status TEXT DEFAULT 'unverified',
    verified_at TIMESTAMP,
    
    -- 解析情報
    llm_model TEXT,
    llm_analyzed_at TIMESTAMP,
    
    -- 修正履歴（誤り学習用）
    original_llm_values JSONB,
    corrections JSONB,
    notes TEXT,
    
    FOREIGN KEY (alien_id) REFERENCES alien(id) ON DELETE CASCADE
);

CREATE INDEX idx_effect_alien ON skill_complete(alien_id, skill_number);
CREATE INDEX idx_effect_verification ON skill_complete(verification_status);
CREATE INDEX idx_effect_timing ON skill_complete(trigger_timing);
CREATE INDEX idx_effect_name ON skill_complete(name);
CREATE INDEX idx_effect_occupies_slot ON skill_complete(occupies_slot);
```

**主要なカラムの説明**:
- **effect_id**: 自動連番の主キー、1バフ=1行を実現
- **group_id**: 同時発動する複数バフをまとめるID（例: 複数のデバフ無効）
- **occupies_slot**: バフ枠を使用するか（null許可、不明な場合はnull）
- **trigger_timing**: 発動タイミング（BATTLE_START, ON_ATTACK, ON_HP_BELOW...）
- **trigger_condition**: 追加条件をJSONBで格納（例: `{"hp_threshold": 50}`）
- **verification_status**: 検証状態（unverified, verified, on_hold）
- **corrections**: 手動修正の差分を記録（AI学習用）

**設計の利点**:
1. **バフ枠計算が簡単**: `SELECT COUNT(*) WHERE name = 'やるきアップ' AND occupies_slot = true`
2. **検索性の向上**: バフ名、発動タイミング、対象などで高速検索
3. **AI学習データの構築**: correctionsカラムで修正パターンを蓄積
4. **スケーラビリティ**: 新しいバフ効果を柔軟に追加可能

### 9.5. 今後の改善点

**バックアップ機能の修正が必要**:
- 現状: `backup_skill_complete.py`は解析用の接続を使うため、接続タイムアウト後はバックアップ失敗
- 改善案: バックアップ時に新しい接続を作成する、または解析前にバックアップを実行
- 優先度: 低（手動バックアップで対応可能）

**Phase 1の完了状態（2025年10月23日）**:
- ✅ 解析スクリプト完成（準並列処理、4.5秒間隔で安定動作）
- ✅ バックアップ・復元スクリプト完成
- ✅ skill_completeテーブル設計完了
- ✅ 自動リトライ機構実装（None応答を自動再解析）
- ⏳ 460体（1380個性）の解析実行中
  - 初回実行結果: 457/460バッチ成功（99.3%）
  - None応答: 2バッチ（自動リトライで解決予定）
  - RPM違反: 1バッチ（4.5秒間隔で再実行予定）
- 次: 全データ解析完了後、Phase 2へ移行

### 9.6. Phase 2で拡張予定のファイル

**date_create/date_app.py** と **date_create/templates/date_index.html**:
- 現在: 手動でバフデータをJSONL形式で入力するツール
- Phase 2での拡張:
  - キャラ単位での表示（3個性をまとめて確認・編集）
  - LLM解析結果の表示と修正
  - 差分自動記録（correctionsカラムに保存）
  - 進捗管理（検証済み/未検証/保留の統計とフィルター）
  - バフ枠推定表示（統計的推定 + ルールベース推定）
  - 一括置換機能（表記ゆれの統一）

### 9.7. 次のチャットへの引き継ぎ情報（2025年10月23日）

**Phase 1完了時の状態**:
- ✅ 460体のうち457体（99.3%）の解析完了
- ✅ 約1371個性のバフ・デバフ効果をskill_completeテーブルに格納
- ⚠️ 3体の解析失敗（RPM違反1件、None応答2件）

**失敗したバッチの対処**:
```sql
-- 失敗したバッチのalien_idを特定（解析ログから）
-- バッチ233, 392, 393の対象エイリアンを個別に再実行
python -m scripts.llm.llm_buff_analyzer --skip 232 --limit 3
```

**Phase 2の開始前に確認すること**:
1. `skill_complete`テーブルのレコード数確認（1380件前後が期待値）
2. 自動リトライの成功確認（None応答バッチの解析成功）
3. サンプル抽出（30-50個性）してLLM解析の精度を評価
4. 典型的なエラーパターンの特定（occupies_slot推定の精度、バフ名の表記ゆれなど）

**Phase 2の最初のタスク**:
1. `date_create/date_app.py`のデータベース接続を`skill_complete`テーブルに変更
2. キャラ単位での表示UI実装（3個性をまとめて表示）
3. LLM解析結果の表示（既存のフォームに自動入力）
4. 修正内容の差分記録機能（original_llm_values, correctionsカラム活用）

**自動リトライ機構の詳細**:
- **設計思想**: ユーザーの手動介入を最小化し、一時的なAPI障害を自動復旧
- **実装方法**:
  1. `process_aliens_parallel()`が(all_rows, failed_batches)のタプルを返す
  2. エラーメッセージに"None"または"空"が含まれる場合、`failed_batches`に追加
  3. `main()`が初回解析完了後、`failed_batches`をチェック
  4. 失敗バッチがあれば、同じ4.5秒間隔で自動再解析
  5. 再解析の結果を`all_rows`に追加し、一括でDBに挿入
- **メリット**:
  - ユーザーは解析完了を待つだけ（手動再実行不要）
  - 一時的なAPI障害（None応答）を自動で解決
  - RPM制限を守りながら確実にリトライ
- **制限事項**:
  - 二重失敗（再解析でも失敗）した場合はログ出力のみ
  - RPM違反エラーは自動リトライ対象外（手動再実行が必要）

---

## 10. 自動更新システムの設計（将来的な拡張）

※ 現在は計画段階。バフデータシステムの完成後に着手予定。

**目的**:
- 新規エイリアン追加時の自動データ収集
- 定期的なデータ更新の自動化
- ユーザーの手動作業を最小化

**想定機能**:
- スケジュール実行（12:00, 24:00など）
- 差分検出とLLM解析の自動実行
- エラー検知とアラート機能

詳細は後日計画予定。